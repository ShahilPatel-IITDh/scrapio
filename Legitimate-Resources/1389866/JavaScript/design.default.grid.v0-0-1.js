/*! Picturefill - v2.3.1 - 2015-04-09
* http://scottjehl.github.io/picturefill
* Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
	"use strict";

	// For browsers that support matchMedium api such as IE 9 and webkit
	var styleMedia = (window.styleMedia || window.media);

	// For those that don't support matchMedium
	if (!styleMedia) {
		var style       = document.createElement('style'),
			script      = document.getElementsByTagName('script')[0],
			info        = null;

		style.type  = 'text/css';
		style.id    = 'matchmediajs-test';

		script.parentNode.insertBefore(style, script);

		// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
		info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

		styleMedia = {
			matchMedium: function(media) {
				var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

				// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
				if (style.styleSheet) {
					style.styleSheet.cssText = text;
				} else {
					style.textContent = text;
				}

				// Test if media query is true or false
				return info.width === '1px';
			}
		};
	}

	return function(media) {
		return {
			matches: styleMedia.matchMedium(media || 'all'),
			media: media || 'all'
		};
	};
}());
/*! Picturefill - Responsive Images that work today.
*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
*  License: MIT/GPLv2
*  Spec: http://picture.responsiveimages.org/
*/
(function( w, doc, image ) {
	// Enable strict mode
	"use strict";

	function expose(picturefill) {
		/* expose picturefill */
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// CommonJS, just export
			module.exports = picturefill;
		} else if ( typeof define === "function" && define.amd ) {
			// AMD support
			define( "picturefill", function() { return picturefill; } );
		}
		if ( typeof w === "object" ) {
			// If no AMD and we are in the browser, attach to window
			w.picturefill = picturefill;
		}
	}

	// If picture is supported, well, that's awesome. Let's get outta here...
	if ( w.HTMLPictureElement ) {
		expose(function() { });
		return;
	}

	// HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
	doc.createElement( "picture" );

	// local object for method references and testing exposure
	var pf = w.picturefill || {};

	var regWDesc = /\s+\+?\d+(e\d+)?w/;

	// namespace
	pf.ns = "picturefill";

	// srcset support test
	(function() {
		pf.srcsetSupported = "srcset" in image;
		pf.sizesSupported = "sizes" in image;
		pf.curSrcSupported = "currentSrc" in image;
	})();

	// just a string trim workaround
	pf.trim = function( str ) {
		return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, "" );
	};

	/**
	 * Gets a string and returns the absolute URL
	 * @param src
	 * @returns {String} absolute URL
	 */
	pf.makeUrl = (function() {
		var anchor = doc.createElement( "a" );
		return function(src) {
			anchor.href = src;
			return anchor.href;
		};
	})();

	/**
	 * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
	 */
	pf.restrictsMixedContent = function() {
		return w.location.protocol === "https:";
	};
	/**
	 * Shortcut method for matchMedia ( for easy overriding in tests )
	 */

	pf.matchesMedia = function( media ) {
		return w.matchMedia && w.matchMedia( media ).matches;
	};

	// Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
	pf.getDpr = function() {
		return ( w.devicePixelRatio || 1 );
	};

	/**
	 * Get width in css pixel value from a "length" value
	 * http://dev.w3.org/csswg/css-values-3/#length-value
	 */
	pf.getWidthFromLength = function( length ) {
		var cssValue;
		// If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, abort.
        if ( !(length && length.indexOf( "%" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( "calc(" ) > -1 )) ) {
            return false;
        }

		/**
		 * If length is specified in  `vw` units, use `%` instead since the div we’re measuring
		 * is injected at the top of the document.
		 *
		 * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %
		 */
		length = length.replace( "vw", "%" );

		// Create a cached element for getting length value widths
		if ( !pf.lengthEl ) {
			pf.lengthEl = doc.createElement( "div" );

			// Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.
			pf.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden";

			// Add a class, so that everyone knows where this element comes from
			pf.lengthEl.className = "helper-from-picturefill-js";
		}

		pf.lengthEl.style.width = "0px";

        try {
		    pf.lengthEl.style.width = length;
        } catch ( e ) {}

		doc.body.appendChild(pf.lengthEl);

		cssValue = pf.lengthEl.offsetWidth;

		if ( cssValue <= 0 ) {
			cssValue = false;
		}

		doc.body.removeChild( pf.lengthEl );

		return cssValue;
	};

    pf.detectTypeSupport = function( type, typeUri ) {
        // based on Modernizr's lossless img-webp test
        // note: asynchronous
        var image = new w.Image();
        image.onerror = function() {
            pf.types[ type ] = false;
            picturefill();
        };
        image.onload = function() {
            pf.types[ type ] = image.width === 1;
            picturefill();
        };
        image.src = typeUri;

        return "pending";
    };
	// container of supported mime types that one might need to qualify before using
	pf.types = pf.types || {};

	pf.initTypeDetects = function() {
        // Add support for standard mime types
        pf.types[ "image/jpeg" ] = true;
        pf.types[ "image/gif" ] = true;
        pf.types[ "image/png" ] = true;
        pf.types[ "image/svg+xml" ] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
        pf.types[ "image/webp" ] = pf.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");
    };

	pf.verifyTypeSupport = function( source ) {
		var type = source.getAttribute( "type" );
		// if type attribute exists, return test result, otherwise return true
		if ( type === null || type === "" ) {
			return true;
		} else {
				var pfType = pf.types[ type ];
			// if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
			if ( typeof pfType === "string" && pfType !== "pending") {
				pf.types[ type ] = pf.detectTypeSupport( type, pfType );
				return "pending";
			} else if ( typeof pfType === "function" ) {
				pfType();
				return "pending";
			} else {
				return pfType;
			}
		}
	};

	// Parses an individual `size` and returns the length, and optional media query
	pf.parseSize = function( sourceSizeStr ) {
		var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
		return {
			media: match && match[1],
			length: match && match[2]
		};
	};

	// Takes a string of sizes and returns the width in pixels as a number
	pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
		// Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
		//                            or (min-width:30em) calc(30% - 15px)
		var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
			winningLength;

		for ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {
			// Match <media-condition>? length, ie ( min-width: 50em ) 100%
			var sourceSize = sourceSizeList[ i ],
				// Split "( min-width: 50em ) 100%" into separate strings
				parsedSize = pf.parseSize( sourceSize ),
				length = parsedSize.length,
				media = parsedSize.media;

			if ( !length ) {
				continue;
			}
			// if there is no media query or it matches, choose this as our winning length
			if ( (!media || pf.matchesMedia( media )) &&
				// pass the length to a method that can properly determine length
				// in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
				(winningLength = pf.getWidthFromLength( length )) ) {
				break;
			}
		}

		//if we have no winningLength fallback to 100vw
		return winningLength || Math.max(w.innerWidth || 0, doc.documentElement.clientWidth);
	};

	pf.parseSrcset = function( srcset ) {
		/**
		 * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
		 * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
		 *
		 * 1. Let input (`srcset`) be the value passed to this algorithm.
		 * 2. Let position be a pointer into input, initially pointing at the start of the string.
		 * 3. Let raw candidates be an initially empty ordered list of URLs with associated
		 *    unparsed descriptors. The order of entries in the list is the order in which entries
		 *    are added to the list.
		 */
		var candidates = [];

		while ( srcset !== "" ) {
			srcset = srcset.replace( /^\s+/g, "" );

			// 5. Collect a sequence of characters that are not space characters, and let that be url.
			var pos = srcset.search(/\s/g),
				url, descriptor = null;

			if ( pos !== -1 ) {
				url = srcset.slice( 0, pos );

				var last = url.slice(-1);

				// 6. If url ends with a U+002C COMMA character (,), remove that character from url
				// and let descriptors be the empty string. Otherwise, follow these substeps
				// 6.1. If url is empty, then jump to the step labeled descriptor parser.

				if ( last === "," || url === "" ) {
					url = url.replace( /,+$/, "" );
					descriptor = "";
				}
				srcset = srcset.slice( pos + 1 );

				// 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and
				// let that be descriptors.
				if ( descriptor === null ) {
					var descpos = srcset.indexOf( "," );
					if ( descpos !== -1 ) {
						descriptor = srcset.slice( 0, descpos );
						srcset = srcset.slice( descpos + 1 );
					} else {
						descriptor = srcset;
						srcset = "";
					}
				}
			} else {
				url = srcset;
				srcset = "";
			}

			// 7. Add url to raw candidates, associated with descriptors.
			if ( url || descriptor ) {
				candidates.push({
					url: url,
					descriptor: descriptor
				});
			}
		}
		return candidates;
	};

	pf.parseDescriptor = function( descriptor, sizesattr ) {
		// 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list
		// is the order in which entries are added to the list.
		var sizes = sizesattr || "100vw",
			sizeDescriptor = descriptor && descriptor.replace( /(^\s+|\s+$)/g, "" ),
			widthInCssPixels = pf.findWidthFromSourceSize( sizes ),
			resCandidate;

			if ( sizeDescriptor ) {
				var splitDescriptor = sizeDescriptor.split(" ");

				for (var i = splitDescriptor.length - 1; i >= 0; i--) {
					var curr = splitDescriptor[ i ],
						lastchar = curr && curr.slice( curr.length - 1 );

					if ( ( lastchar === "h" || lastchar === "w" ) && !pf.sizesSupported ) {
						resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
					} else if ( lastchar === "x" ) {
						var res = curr && parseFloat( curr, 10 );
						resCandidate = res && !isNaN( res ) ? res : 1;
					}
				}
			}
		return resCandidate || 1;
	};

	/**
	 * Takes a srcset in the form of url/
	 * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
	 *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
	 *     "images/pic-small.png"
	 * Get an array of image candidates in the form of
	 *      {url: "/foo/bar.png", resolution: 1}
	 * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
	 * If sizes is specified, resolution is calculated
	 */
	pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
		var candidates = pf.parseSrcset( srcset ),
			formattedCandidates = [];

		for ( var i = 0, len = candidates.length; i < len; i++ ) {
			var candidate = candidates[ i ];

			formattedCandidates.push({
				url: candidate.url,
				resolution: pf.parseDescriptor( candidate.descriptor, sizes )
			});
		}
		return formattedCandidates;
	};

	/**
	 * if it's an img element and it has a srcset property,
	 * we need to remove the attribute so we can manipulate src
	 * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
	 * this moves srcset's value to memory for later use and removes the attr
	 */
	pf.dodgeSrcset = function( img ) {
		if ( img.srcset ) {
			img[ pf.ns ].srcset = img.srcset;
			img.srcset = "";
			img.setAttribute( "data-pfsrcset", img[ pf.ns ].srcset );
		}
	};

	// Accept a source or img element and process its srcset and sizes attrs
	pf.processSourceSet = function( el ) {
		var srcset = el.getAttribute( "srcset" ),
			sizes = el.getAttribute( "sizes" ),
			candidates = [];

		// if it's an img element, use the cached srcset property (defined or not)
		if ( el.nodeName.toUpperCase() === "IMG" && el[ pf.ns ] && el[ pf.ns ].srcset ) {
			srcset = el[ pf.ns ].srcset;
		}

		if ( srcset ) {
			candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
		}
		return candidates;
	};

	pf.backfaceVisibilityFix = function( picImg ) {
		// See: https://github.com/scottjehl/picturefill/issues/332
		var style = picImg.style || {},
			WebkitBackfaceVisibility = "webkitBackfaceVisibility" in style,
			currentZoom = style.zoom;

		if (WebkitBackfaceVisibility) {
			style.zoom = ".999";

			WebkitBackfaceVisibility = picImg.offsetWidth;

			style.zoom = currentZoom;
		}
	};

	pf.setIntrinsicSize = (function() {
		var urlCache = {};
		var setSize = function( picImg, width, res ) {
            if ( width ) {
			    picImg.setAttribute( "width", parseInt(width / res, 10) );
            }
		};
		return function( picImg, bestCandidate ) {
			var img;
			if ( !picImg[ pf.ns ] || w.pfStopIntrinsicSize ) {
				return;
			}
			if ( picImg[ pf.ns ].dims === undefined ) {
				picImg[ pf.ns].dims = picImg.getAttribute("width") || picImg.getAttribute("height");
			}
			if ( picImg[ pf.ns].dims ) { return; }

			if ( bestCandidate.url in urlCache ) {
				setSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );
			} else {
				img = doc.createElement( "img" );
				img.onload = function() {
					urlCache[bestCandidate.url] = img.width;

                    //IE 10/11 don't calculate width for svg outside document
                    if ( !urlCache[bestCandidate.url] ) {
                        try {
                            doc.body.appendChild( img );
                            urlCache[bestCandidate.url] = img.width || img.offsetWidth;
                            doc.body.removeChild( img );
                        } catch(e){}
                    }

					if ( picImg.src === bestCandidate.url ) {
						setSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );
					}
					picImg = null;
					img.onload = null;
					img = null;
				};
				img.src = bestCandidate.url;
			}
		};
	})();

	pf.applyBestCandidate = function( candidates, picImg ) {
		var candidate,
			length,
			bestCandidate;

		candidates.sort( pf.ascendingSort );

		length = candidates.length;
		bestCandidate = candidates[ length - 1 ];

		for ( var i = 0; i < length; i++ ) {
			candidate = candidates[ i ];
			if ( candidate.resolution >= pf.getDpr() ) {
				bestCandidate = candidate;
				break;
			}
		}

		if ( bestCandidate ) {

			bestCandidate.url = pf.makeUrl( bestCandidate.url );

			if ( picImg.src !== bestCandidate.url ) {
				if ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, "http:".length).toLowerCase() === "http:" ) {
					if ( window.console !== undefined ) {
						console.warn( "Blocked mixed content image " + bestCandidate.url );
					}
				} else {
					picImg.src = bestCandidate.url;
					// currentSrc attribute and property to match
					// http://picture.responsiveimages.org/#the-img-element
					if ( !pf.curSrcSupported ) {
						picImg.currentSrc = picImg.src;
					}

					pf.backfaceVisibilityFix( picImg );
				}
			}

			pf.setIntrinsicSize(picImg, bestCandidate);
		}
	};

	pf.ascendingSort = function( a, b ) {
		return a.resolution - b.resolution;
	};

	/**
	 * In IE9, <source> elements get removed if they aren't children of
	 * video elements. Thus, we conditionally wrap source elements
	 * using <!--[if IE 9]><video style="display: none;"><![endif]-->
	 * and must account for that here by moving those source elements
	 * back into the picture element.
	 */
	pf.removeVideoShim = function( picture ) {
		var videos = picture.getElementsByTagName( "video" );
		if ( videos.length ) {
			var video = videos[ 0 ],
				vsources = video.getElementsByTagName( "source" );
			while ( vsources.length ) {
				picture.insertBefore( vsources[ 0 ], video );
			}
			// Remove the video element once we're finished removing its children
			video.parentNode.removeChild( video );
		}
	};

	/**
	 * Find all `img` elements, and add them to the candidate list if they have
	 * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
	 * a `srcset` attribute at all, and they haven’t been evaluated already.
	 */
	pf.getAllElements = function() {
		var elems = [],
			imgs = doc.getElementsByTagName( "img" );

		for ( var h = 0, len = imgs.length; h < len; h++ ) {
			var currImg = imgs[ h ];

			if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
			( currImg.getAttribute( "srcset" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {
				elems.push( currImg );
			}
		}
		return elems;
	};

	pf.getMatch = function( img, picture ) {
		var sources = picture.childNodes,
			match;

		// Go through each child, and if they have media queries, evaluate them
		for ( var j = 0, slen = sources.length; j < slen; j++ ) {
			var source = sources[ j ];

			// ignore non-element nodes
			if ( source.nodeType !== 1 ) {
				continue;
			}

			// Hitting the `img` element that started everything stops the search for `sources`.
			// If no previous `source` matches, the `img` itself is evaluated later.
			if ( source === img ) {
				return match;
			}

			// ignore non-`source` nodes
			if ( source.nodeName.toUpperCase() !== "SOURCE" ) {
				continue;
			}
			// if it's a source element that has the `src` property set, throw a warning in the console
			if ( source.getAttribute( "src" ) !== null && typeof console !== undefined ) {
				console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
			}

			var media = source.getAttribute( "media" );

			// if source does not have a srcset attribute, skip
			if ( !source.getAttribute( "srcset" ) ) {
				continue;
			}

			// if there's no media specified, OR w.matchMedia is supported
			if ( ( !media || pf.matchesMedia( media ) ) ) {
				var typeSupported = pf.verifyTypeSupport( source );

				if ( typeSupported === true ) {
					match = source;
					break;
				} else if ( typeSupported === "pending" ) {
					return false;
				}
			}
		}

		return match;
	};

	function picturefill( opt ) {
		var elements,
			element,
			parent,
			firstMatch,
			candidates,
			options = opt || {};

		elements = options.elements || pf.getAllElements();

		// Loop through all elements
		for ( var i = 0, plen = elements.length; i < plen; i++ ) {
			element = elements[ i ];
			parent = element.parentNode;
			firstMatch = undefined;
			candidates = undefined;

			// immediately skip non-`img` nodes
			if ( element.nodeName.toUpperCase() !== "IMG" ) {
				continue;
			}

			// expando for caching data on the img
			if ( !element[ pf.ns ] ) {
				element[ pf.ns ] = {};
			}

			// if the element has already been evaluated, skip it unless
			// `options.reevaluate` is set to true ( this, for example,
			// is set to true when running `picturefill` on `resize` ).
			if ( !options.reevaluate && element[ pf.ns ].evaluated ) {
				continue;
			}

			// if `img` is in a `picture` element
			if ( parent && parent.nodeName.toUpperCase() === "PICTURE" ) {

				// IE9 video workaround
				pf.removeVideoShim( parent );

				// return the first match which might undefined
				// returns false if there is a pending source
				// TODO the return type here is brutal, cleanup
				firstMatch = pf.getMatch( element, parent );

				// if any sources are pending in this picture due to async type test(s)
				// remove the evaluated attr and skip for now ( the pending test will
				// rerun picturefill on this element when complete)
				if ( firstMatch === false ) {
					continue;
				}
			} else {
				firstMatch = undefined;
			}

			// Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
			if ( ( parent && parent.nodeName.toUpperCase() === "PICTURE" ) ||
			( !pf.sizesSupported && ( element.srcset && regWDesc.test( element.srcset ) ) ) ) {
				pf.dodgeSrcset( element );
			}

			if ( firstMatch ) {
				candidates = pf.processSourceSet( firstMatch );
				pf.applyBestCandidate( candidates, element );
			} else {
				// No sources matched, so we’re down to processing the inner `img` as a source.
				candidates = pf.processSourceSet( element );

				if ( element.srcset === undefined || element[ pf.ns ].srcset ) {
					// Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
					pf.applyBestCandidate( candidates, element );
				} // Else, resolution-only `srcset` is supported natively.
			}

			// set evaluated to true to avoid unnecessary reparsing
			element[ pf.ns ].evaluated = true;
		}
	}

	/**
	 * Sets up picture polyfill by polling the document and running
	 * the polyfill every 250ms until the document is ready.
	 * Also attaches picturefill on resize
	 */
	function runPicturefill() {
		pf.initTypeDetects();
		picturefill();
		var intervalId = setInterval( function() {
			// When the document has finished loading, stop checking for new images
			// https://github.com/ded/domready/blob/master/ready.js#L15
			picturefill();

			if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
				clearInterval( intervalId );
				return;
			}
		}, 250 );

		var resizeTimer;
		var handleResize = function() {
	        picturefill({ reevaluate: true });
	    };
		function checkResize() {
		    clearTimeout(resizeTimer);
		    resizeTimer = setTimeout( handleResize, 60 );
		}

		if ( w.addEventListener ) {
			w.addEventListener( "resize", checkResize, false );
		} else if ( w.attachEvent ) {
			w.attachEvent( "onresize", checkResize );
		}
	}

	runPicturefill();

	/* expose methods for testing */
	picturefill._ = pf;

	expose( picturefill );

} )( window, window.document, new window.Image() );

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
 * Build: `lodash -o ./dist/lodash.compat.js`
 */
;(function(){function n(n,t,e){e=(e||0)-1;for(var r=n?n.length:0;++e<r;)if(n[e]===t)return e;return-1}function t(t,e){var r=typeof e;if(t=t.l,"boolean"==r||null==e)return t[e]?0:-1;"number"!=r&&"string"!=r&&(r="object");var u="number"==r?e:b+e;return t=(t=t[r])&&t[u],"object"==r?t&&-1<n(t,e)?0:-1:t?0:-1}function e(n){var t=this.l,e=typeof n;if("boolean"==e||null==n)t[n]=true;else{"number"!=e&&"string"!=e&&(e="object");var r="number"==e?n:b+n,t=t[e]||(t[e]={});"object"==e?(t[r]||(t[r]=[])).push(n):t[r]=true
}}function r(n){return n.charCodeAt(0)}function u(n,t){for(var e=n.m,r=t.m,u=-1,o=e.length;++u<o;){var a=e[u],i=r[u];if(a!==i){if(a>i||typeof a=="undefined")return 1;if(a<i||typeof i=="undefined")return-1}}return n.n-t.n}function o(n){var t=-1,r=n.length,u=n[0],o=n[r/2|0],a=n[r-1];if(u&&typeof u=="object"&&o&&typeof o=="object"&&a&&typeof a=="object")return false;for(u=l(),u["false"]=u["null"]=u["true"]=u.undefined=false,o=l(),o.k=n,o.l=u,o.push=e;++t<r;)o.push(n[t]);return o}function a(n){return"\\"+Y[n]
}function i(){return v.pop()||[]}function l(){return y.pop()||{k:null,l:null,m:null,"false":false,n:0,"null":false,number:null,object:null,push:null,string:null,"true":false,undefined:false,o:null}}function f(n){return typeof n.toString!="function"&&typeof(n+"")=="string"}function c(n){n.length=0,v.length<w&&v.push(n)}function p(n){var t=n.l;t&&p(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,y.length<w&&y.push(n)}function s(n,t,e){t||(t=0),typeof e=="undefined"&&(e=n?n.length:0);var r=-1;e=e-t||0;for(var u=Array(0>e?0:e);++r<e;)u[r]=n[t+r];
return u}function g(e){function v(n){return n&&typeof n=="object"&&!qe(n)&&we.call(n,"__wrapped__")?n:new y(n)}function y(n,t){this.__chain__=!!t,this.__wrapped__=n}function w(n){function t(){if(r){var n=s(r);je.apply(n,arguments)}if(this instanceof t){var o=nt(e.prototype),n=e.apply(o,n||arguments);return xt(n)?n:o}return e.apply(u,n||arguments)}var e=n[0],r=n[2],u=n[4];return ze(t,n),t}function Y(n,t,e,r,u){if(e){var o=e(n);if(typeof o!="undefined")return o}if(!xt(n))return n;var a=he.call(n);if(!V[a]||!Le.nodeClass&&f(n))return n;
var l=Te[a];switch(a){case L:case z:return new l(+n);case W:case M:return new l(n);case J:return o=l(n.source,S.exec(n)),o.lastIndex=n.lastIndex,o}if(a=qe(n),t){var p=!r;r||(r=i()),u||(u=i());for(var g=r.length;g--;)if(r[g]==n)return u[g];o=a?l(n.length):{}}else o=a?s(n):Ye({},n);return a&&(we.call(n,"index")&&(o.index=n.index),we.call(n,"input")&&(o.input=n.input)),t?(r.push(n),u.push(o),(a?Xe:tr)(n,function(n,a){o[a]=Y(n,t,e,r,u)}),p&&(c(r),c(u)),o):o}function nt(n){return xt(n)?Se(n):{}}function tt(n,t,e){if(typeof n!="function")return Ht;
if(typeof t=="undefined"||!("prototype"in n))return n;var r=n.__bindData__;if(typeof r=="undefined"&&(Le.funcNames&&(r=!n.name),r=r||!Le.funcDecomp,!r)){var u=be.call(n);Le.funcNames||(r=!A.test(u)),r||(r=B.test(u),ze(n,r))}if(false===r||true!==r&&1&r[1])return n;switch(e){case 1:return function(e){return n.call(t,e)};case 2:return function(e,r){return n.call(t,e,r)};case 3:return function(e,r,u){return n.call(t,e,r,u)};case 4:return function(e,r,u,o){return n.call(t,e,r,u,o)}}return Mt(n,t)}function et(n){function t(){var n=l?a:this;
if(u){var h=s(u);je.apply(h,arguments)}return(o||c)&&(h||(h=s(arguments)),o&&je.apply(h,o),c&&h.length<i)?(r|=16,et([e,p?r:-4&r,h,null,a,i])):(h||(h=arguments),f&&(e=n[g]),this instanceof t?(n=nt(e.prototype),h=e.apply(n,h),xt(h)?h:n):e.apply(n,h))}var e=n[0],r=n[1],u=n[2],o=n[3],a=n[4],i=n[5],l=1&r,f=2&r,c=4&r,p=8&r,g=e;return ze(t,n),t}function rt(e,r){var u=-1,a=ht(),i=e?e.length:0,l=i>=_&&a===n,f=[];if(l){var c=o(r);c?(a=t,r=c):l=false}for(;++u<i;)c=e[u],0>a(r,c)&&f.push(c);return l&&p(r),f}function ot(n,t,e,r){r=(r||0)-1;
for(var u=n?n.length:0,o=[];++r<u;){var a=n[r];if(a&&typeof a=="object"&&typeof a.length=="number"&&(qe(a)||dt(a))){t||(a=ot(a,t,e));var i=-1,l=a.length,f=o.length;for(o.length+=l;++i<l;)o[f++]=a[i]}else e||o.push(a)}return o}function at(n,t,e,r,u,o){if(e){var a=e(n,t);if(typeof a!="undefined")return!!a}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&X[typeof n]||t&&X[typeof t]))return false;if(null==n||null==t)return n===t;var l=he.call(n),p=he.call(t);if(l==T&&(l=G),p==T&&(p=G),l!=p)return false;switch(l){case L:case z:return+n==+t;
case W:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case J:case M:return n==ie(t)}if(p=l==$,!p){var s=we.call(n,"__wrapped__"),g=we.call(t,"__wrapped__");if(s||g)return at(s?n.__wrapped__:n,g?t.__wrapped__:t,e,r,u,o);if(l!=G||!Le.nodeClass&&(f(n)||f(t)))return false;if(l=!Le.argsObject&&dt(n)?oe:n.constructor,s=!Le.argsObject&&dt(t)?oe:t.constructor,l!=s&&!(jt(l)&&l instanceof l&&jt(s)&&s instanceof s)&&"constructor"in n&&"constructor"in t)return false}for(l=!u,u||(u=i()),o||(o=i()),s=u.length;s--;)if(u[s]==n)return o[s]==t;
var h=0,a=true;if(u.push(n),o.push(t),p){if(s=n.length,h=t.length,(a=h==s)||r)for(;h--;)if(p=s,g=t[h],r)for(;p--&&!(a=at(n[p],g,e,r,u,o)););else if(!(a=at(n[h],g,e,r,u,o)))break}else nr(t,function(t,i,l){return we.call(l,i)?(h++,a=we.call(n,i)&&at(n[i],t,e,r,u,o)):void 0}),a&&!r&&nr(n,function(n,t,e){return we.call(e,t)?a=-1<--h:void 0});return u.pop(),o.pop(),l&&(c(u),c(o)),a}function it(n,t,e,r,u){(qe(t)?Dt:tr)(t,function(t,o){var a,i,l=t,f=n[o];if(t&&((i=qe(t))||er(t))){for(l=r.length;l--;)if(a=r[l]==t){f=u[l];
break}if(!a){var c;e&&(l=e(f,t),c=typeof l!="undefined")&&(f=l),c||(f=i?qe(f)?f:[]:er(f)?f:{}),r.push(t),u.push(f),c||it(f,t,e,r,u)}}else e&&(l=e(f,t),typeof l=="undefined"&&(l=t)),typeof l!="undefined"&&(f=l);n[o]=f})}function lt(n,t){return n+de(Fe()*(t-n+1))}function ft(e,r,u){var a=-1,l=ht(),f=e?e.length:0,s=[],g=!r&&f>=_&&l===n,h=u||g?i():s;for(g&&(h=o(h),l=t);++a<f;){var v=e[a],y=u?u(v,a,e):v;(r?!a||h[h.length-1]!==y:0>l(h,y))&&((u||g)&&h.push(y),s.push(v))}return g?(c(h.k),p(h)):u&&c(h),s}function ct(n){return function(t,e,r){var u={};
if(e=v.createCallback(e,r,3),qe(t)){r=-1;for(var o=t.length;++r<o;){var a=t[r];n(u,a,e(a,r,t),t)}}else Xe(t,function(t,r,o){n(u,t,e(t,r,o),o)});return u}}function pt(n,t,e,r,u,o){var a=1&t,i=4&t,l=16&t,f=32&t;if(!(2&t||jt(n)))throw new le;l&&!e.length&&(t&=-17,l=e=false),f&&!r.length&&(t&=-33,f=r=false);var c=n&&n.__bindData__;return c&&true!==c?(c=s(c),c[2]&&(c[2]=s(c[2])),c[3]&&(c[3]=s(c[3])),!a||1&c[1]||(c[4]=u),!a&&1&c[1]&&(t|=8),!i||4&c[1]||(c[5]=o),l&&je.apply(c[2]||(c[2]=[]),e),f&&Ee.apply(c[3]||(c[3]=[]),r),c[1]|=t,pt.apply(null,c)):(1==t||17===t?w:et)([n,t,e,r,u,o])
}function st(){Q.h=F,Q.b=Q.c=Q.g=Q.i="",Q.e="t",Q.j=true;for(var n,t=0;n=arguments[t];t++)for(var e in n)Q[e]=n[e];t=Q.a,Q.d=/^[^,]+/.exec(t)[0],n=ee,t="return function("+t+"){",e=Q;var r="var n,t="+e.d+",E="+e.e+";if(!t)return E;"+e.i+";";e.b?(r+="var u=t.length;n=-1;if("+e.b+"){",Le.unindexedChars&&(r+="if(s(t)){t=t.split('')}"),r+="while(++n<u){"+e.g+";}}else{"):Le.nonEnumArgs&&(r+="var u=t.length;n=-1;if(u&&p(t)){while(++n<u){n+='';"+e.g+";}}else{"),Le.enumPrototypes&&(r+="var G=typeof t=='function';"),Le.enumErrorProps&&(r+="var F=t===k||t instanceof Error;");
var u=[];if(Le.enumPrototypes&&u.push('!(G&&n=="prototype")'),Le.enumErrorProps&&u.push('!(F&&(n=="message"||n=="name"))'),e.j&&e.f)r+="var C=-1,D=B[typeof t]&&v(t),u=D?D.length:0;while(++C<u){n=D[C];",u.length&&(r+="if("+u.join("&&")+"){"),r+=e.g+";",u.length&&(r+="}"),r+="}";else if(r+="for(n in t){",e.j&&u.push("m.call(t, n)"),u.length&&(r+="if("+u.join("&&")+"){"),r+=e.g+";",u.length&&(r+="}"),r+="}",Le.nonEnumShadows){for(r+="if(t!==A){var i=t.constructor,r=t===(i&&i.prototype),f=t===J?I:t===k?j:L.call(t),x=y[f];",k=0;7>k;k++)r+="n='"+e.h[k]+"';if((!(r&&x[n])&&m.call(t,n))",e.j||(r+="||(!x[n]&&t[n]!==A[n])"),r+="){"+e.g+"}";
r+="}"}return(e.b||Le.nonEnumArgs)&&(r+="}"),r+=e.c+";return E",n("d,j,k,m,o,p,q,s,v,A,B,y,I,J,L",t+r+"}")(tt,q,ce,we,d,dt,qe,kt,Q.f,pe,X,$e,M,se,he)}function gt(n){return Ve[n]}function ht(){var t=(t=v.indexOf)===zt?n:t;return t}function vt(n){return typeof n=="function"&&ve.test(n)}function yt(n){var t,e;return!n||he.call(n)!=G||(t=n.constructor,jt(t)&&!(t instanceof t))||!Le.argsClass&&dt(n)||!Le.nodeClass&&f(n)?false:Le.ownLast?(nr(n,function(n,t,r){return e=we.call(r,t),false}),false!==e):(nr(n,function(n,t){e=t
}),typeof e=="undefined"||we.call(n,e))}function mt(n){return He[n]}function dt(n){return n&&typeof n=="object"&&typeof n.length=="number"&&he.call(n)==T||false}function bt(n,t,e){var r=We(n),u=r.length;for(t=tt(t,e,3);u--&&(e=r[u],false!==t(n[e],e,n)););return n}function _t(n){var t=[];return nr(n,function(n,e){jt(n)&&t.push(e)}),t.sort()}function wt(n){for(var t=-1,e=We(n),r=e.length,u={};++t<r;){var o=e[t];u[n[o]]=o}return u}function jt(n){return typeof n=="function"}function xt(n){return!(!n||!X[typeof n])
}function Ct(n){return typeof n=="number"||n&&typeof n=="object"&&he.call(n)==W||false}function kt(n){return typeof n=="string"||n&&typeof n=="object"&&he.call(n)==M||false}function Et(n){for(var t=-1,e=We(n),r=e.length,u=Zt(r);++t<r;)u[t]=n[e[t]];return u}function Ot(n,t,e){var r=-1,u=ht(),o=n?n.length:0,a=false;return e=(0>e?Be(0,o+e):e)||0,qe(n)?a=-1<u(n,t,e):typeof o=="number"?a=-1<(kt(n)?n.indexOf(t,e):u(n,t,e)):Xe(n,function(n){return++r<e?void 0:!(a=n===t)}),a}function St(n,t,e){var r=true;if(t=v.createCallback(t,e,3),qe(n)){e=-1;
for(var u=n.length;++e<u&&(r=!!t(n[e],e,n)););}else Xe(n,function(n,e,u){return r=!!t(n,e,u)});return r}function At(n,t,e){var r=[];if(t=v.createCallback(t,e,3),qe(n)){e=-1;for(var u=n.length;++e<u;){var o=n[e];t(o,e,n)&&r.push(o)}}else Xe(n,function(n,e,u){t(n,e,u)&&r.push(n)});return r}function It(n,t,e){if(t=v.createCallback(t,e,3),!qe(n)){var r;return Xe(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0}),r}e=-1;for(var u=n.length;++e<u;){var o=n[e];if(t(o,e,n))return o}}function Dt(n,t,e){if(t&&typeof e=="undefined"&&qe(n)){e=-1;
for(var r=n.length;++e<r&&false!==t(n[e],e,n););}else Xe(n,t,e);return n}function Nt(n,t,e){var r=n,u=n?n.length:0;if(t=t&&typeof e=="undefined"?t:tt(t,e,3),qe(n))for(;u--&&false!==t(n[u],u,n););else{if(typeof u!="number")var o=We(n),u=o.length;else Le.unindexedChars&&kt(n)&&(r=n.split(""));Xe(n,function(n,e,a){return e=o?o[--u]:--u,t(r[e],e,a)})}return n}function Bt(n,t,e){var r=-1,u=n?n.length:0,o=Zt(typeof u=="number"?u:0);if(t=v.createCallback(t,e,3),qe(n))for(;++r<u;)o[r]=t(n[r],r,n);else Xe(n,function(n,e,u){o[++r]=t(n,e,u)
});return o}function Pt(n,t,e){var u=-1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&qe(n)){e=-1;for(var a=n.length;++e<a;){var i=n[e];i>o&&(o=i)}}else t=null==t&&kt(n)?r:v.createCallback(t,e,3),Xe(n,function(n,e,r){e=t(n,e,r),e>u&&(u=e,o=n)});return o}function Rt(n,t,e,r){var u=3>arguments.length;if(t=v.createCallback(t,r,4),qe(n)){var o=-1,a=n.length;for(u&&(e=n[++o]);++o<a;)e=t(e,n[o],o,n)}else Xe(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)});return e}function Ft(n,t,e,r){var u=3>arguments.length;
return t=v.createCallback(t,r,4),Nt(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)}),e}function Tt(n){var t=-1,e=n?n.length:0,r=Zt(typeof e=="number"?e:0);return Dt(n,function(n){var e=lt(0,++t);r[t]=r[e],r[e]=n}),r}function $t(n,t,e){var r;if(t=v.createCallback(t,e,3),qe(n)){e=-1;for(var u=n.length;++e<u&&!(r=t(n[e],e,n)););}else Xe(n,function(n,e,u){return!(r=t(n,e,u))});return!!r}function Lt(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=-1;for(t=v.createCallback(t,e,3);++o<u&&t(n[o],o,n);)r++
}else if(r=t,null==r||e)return n?n[0]:h;return s(n,0,Pe(Be(0,r),u))}function zt(t,e,r){if(typeof r=="number"){var u=t?t.length:0;r=0>r?Be(0,u+r):r||0}else if(r)return r=Kt(t,e),t[r]===e?r:-1;return n(t,e,r)}function qt(n,t,e){if(typeof t!="number"&&null!=t){var r=0,u=-1,o=n?n.length:0;for(t=v.createCallback(t,e,3);++u<o&&t(n[u],u,n);)r++}else r=null==t||e?1:Be(0,t);return s(n,r)}function Kt(n,t,e,r){var u=0,o=n?n.length:u;for(e=e?v.createCallback(e,r,1):Ht,t=e(t);u<o;)r=u+o>>>1,e(n[r])<t?u=r+1:o=r;
return u}function Wt(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(e=v.createCallback(e,r,3)),ft(n,t,e)}function Gt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,e=n?Pt(ar(n,"length")):0,r=Zt(0>e?0:e);++t<e;)r[t]=ar(n,t);return r}function Jt(n,t){var e=-1,r=n?n.length:0,u={};for(t||!r||qe(n[0])||(t=[]);++e<r;){var o=n[e];t?u[o]=t[e]:o&&(u[o[0]]=o[1])}return u}function Mt(n,t){return 2<arguments.length?pt(n,17,s(arguments,2),null,t):pt(n,1,null,null,t)
}function Vt(n,t,e){var r,u,o,a,i,l,f,c=0,p=false,s=true;if(!jt(n))throw new le;if(t=Be(0,t)||0,true===e)var g=true,s=false;else xt(e)&&(g=e.leading,p="maxWait"in e&&(Be(t,e.maxWait)||0),s="trailing"in e?e.trailing:s);var v=function(){var e=t-(ir()-a);0<e?l=Ce(v,e):(u&&me(u),e=f,u=l=f=h,e&&(c=ir(),o=n.apply(i,r),l||u||(r=i=null)))},y=function(){l&&me(l),u=l=f=h,(s||p!==t)&&(c=ir(),o=n.apply(i,r),l||u||(r=i=null))};return function(){if(r=arguments,a=ir(),i=this,f=s&&(l||!g),false===p)var e=g&&!l;else{u||g||(c=a);
var h=p-(a-c),m=0>=h;m?(u&&(u=me(u)),c=a,o=n.apply(i,r)):u||(u=Ce(y,h))}return m&&l?l=me(l):l||t===p||(l=Ce(v,t)),e&&(m=true,o=n.apply(i,r)),!m||l||u||(r=i=null),o}}function Ht(n){return n}function Ut(n,t,e){var r=true,u=t&&_t(t);t&&(e||u.length)||(null==e&&(e=t),o=y,t=n,n=v,u=_t(t)),false===e?r=false:xt(e)&&"chain"in e&&(r=e.chain);var o=n,a=jt(o);Dt(u,function(e){var u=n[e]=t[e];a&&(o.prototype[e]=function(){var t=this.__chain__,e=this.__wrapped__,a=[e];if(je.apply(a,arguments),a=u.apply(n,a),r||t){if(e===a&&xt(a))return this;
a=new o(a),a.__chain__=t}return a})})}function Qt(){}function Xt(n){return function(t){return t[n]}}function Yt(){return this.__wrapped__}e=e?ut.defaults(Z.Object(),e,ut.pick(Z,R)):Z;var Zt=e.Array,ne=e.Boolean,te=e.Date,ee=e.Function,re=e.Math,ue=e.Number,oe=e.Object,ae=e.RegExp,ie=e.String,le=e.TypeError,fe=[],ce=e.Error.prototype,pe=oe.prototype,se=ie.prototype,ge=e._,he=pe.toString,ve=ae("^"+ie(he).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),ye=re.ceil,me=e.clearTimeout,de=re.floor,be=ee.prototype.toString,_e=vt(_e=oe.getPrototypeOf)&&_e,we=pe.hasOwnProperty,je=fe.push,xe=pe.propertyIsEnumerable,Ce=e.setTimeout,ke=fe.splice,Ee=fe.unshift,Oe=function(){try{var n={},t=vt(t=oe.defineProperty)&&t,e=t(n,n,n)&&t
}catch(r){}return e}(),Se=vt(Se=oe.create)&&Se,Ae=vt(Ae=Zt.isArray)&&Ae,Ie=e.isFinite,De=e.isNaN,Ne=vt(Ne=oe.keys)&&Ne,Be=re.max,Pe=re.min,Re=e.parseInt,Fe=re.random,Te={};Te[$]=Zt,Te[L]=ne,Te[z]=te,Te[K]=ee,Te[G]=oe,Te[W]=ue,Te[J]=ae,Te[M]=ie;var $e={};$e[$]=$e[z]=$e[W]={constructor:true,toLocaleString:true,toString:true,valueOf:true},$e[L]=$e[M]={constructor:true,toString:true,valueOf:true},$e[q]=$e[K]=$e[J]={constructor:true,toString:true},$e[G]={constructor:true},function(){for(var n=F.length;n--;){var t,e=F[n];
for(t in $e)we.call($e,t)&&!we.call($e[t],e)&&($e[t][e]=false)}}(),y.prototype=v.prototype;var Le=v.support={};!function(){var n=function(){this.x=1},t={0:1,length:1},r=[];n.prototype={valueOf:1,y:1};for(var u in new n)r.push(u);for(u in arguments);Le.argsClass=he.call(arguments)==T,Le.argsObject=arguments.constructor==oe&&!(arguments instanceof Zt),Le.enumErrorProps=xe.call(ce,"message")||xe.call(ce,"name"),Le.enumPrototypes=xe.call(n,"prototype"),Le.funcDecomp=!vt(e.WinRTError)&&B.test(g),Le.funcNames=typeof ee.name=="string",Le.nonEnumArgs=0!=u,Le.nonEnumShadows=!/valueOf/.test(r),Le.ownLast="x"!=r[0],Le.spliceObjects=(fe.splice.call(t,0,1),!t[0]),Le.unindexedChars="xx"!="x"[0]+oe("x")[0];
try{Le.nodeClass=!(he.call(document)==G&&!({toString:0}+""))}catch(o){Le.nodeClass=true}}(1),v.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:I,variable:"",imports:{_:v}},Se||(nt=function(){function n(){}return function(t){if(xt(t)){n.prototype=t;var r=new n;n.prototype=null}return r||e.Object()}}());var ze=Oe?function(n,t){U.value=t,Oe(n,"__bindData__",U)}:Qt;Le.argsClass||(dt=function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&we.call(n,"callee")&&!xe.call(n,"callee")||false
});var qe=Ae||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&he.call(n)==$||false},Ke=st({a:"z",e:"[]",i:"if(!(B[typeof z]))return E",g:"E.push(n)"}),We=Ne?function(n){return xt(n)?Le.enumPrototypes&&typeof n=="function"||Le.nonEnumArgs&&n.length&&dt(n)?Ke(n):Ne(n):[]}:Ke,Ge={a:"g,e,K",i:"e=e&&typeof K=='undefined'?e:d(e,K,3)",b:"typeof u=='number'",v:We,g:"if(e(t[n],n,g)===false)return E"},Je={a:"z,H,l",i:"var a=arguments,b=0,c=typeof l=='number'?2:a.length;while(++b<c){t=a[b];if(t&&B[typeof t]){",v:We,g:"if(typeof E[n]=='undefined')E[n]=t[n]",c:"}}"},Me={i:"if(!B[typeof t])return E;"+Ge.i,b:false},Ve={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},He=wt(Ve),Ue=ae("("+We(He).join("|")+")","g"),Qe=ae("["+We(Ve).join("")+"]","g"),Xe=st(Ge),Ye=st(Je,{i:Je.i.replace(";",";if(c>3&&typeof a[c-2]=='function'){var e=d(a[--c-1],a[c--],2)}else if(c>2&&typeof a[c-1]=='function'){e=a[--c]}"),g:"E[n]=e?e(E[n],t[n]):t[n]"}),Ze=st(Je),nr=st(Ge,Me,{j:false}),tr=st(Ge,Me);
jt(/x/)&&(jt=function(n){return typeof n=="function"&&he.call(n)==K});var er=_e?function(n){if(!n||he.call(n)!=G||!Le.argsClass&&dt(n))return false;var t=n.valueOf,e=vt(t)&&(e=_e(t))&&_e(e);return e?n==e||_e(n)==e:yt(n)}:yt,rr=ct(function(n,t,e){we.call(n,e)?n[e]++:n[e]=1}),ur=ct(function(n,t,e){(we.call(n,e)?n[e]:n[e]=[]).push(t)}),or=ct(function(n,t,e){n[e]=t}),ar=Bt,ir=vt(ir=te.now)&&ir||function(){return(new te).getTime()},lr=8==Re(j+"08")?Re:function(n,t){return Re(kt(n)?n.replace(D,""):n,t||0)};
return v.after=function(n,t){if(!jt(t))throw new le;return function(){return 1>--n?t.apply(this,arguments):void 0}},v.assign=Ye,v.at=function(n){var t=arguments,e=-1,r=ot(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:r.length,u=Zt(t);for(Le.unindexedChars&&kt(n)&&(n=n.split(""));++e<t;)u[e]=n[r[e]];return u},v.bind=Mt,v.bindAll=function(n){for(var t=1<arguments.length?ot(arguments,true,false,1):_t(n),e=-1,r=t.length;++e<r;){var u=t[e];n[u]=pt(n[u],1,null,null,n)}return n},v.bindKey=function(n,t){return 2<arguments.length?pt(t,19,s(arguments,2),null,n):pt(t,3,null,null,n)
},v.chain=function(n){return n=new y(n),n.__chain__=true,n},v.compact=function(n){for(var t=-1,e=n?n.length:0,r=[];++t<e;){var u=n[t];u&&r.push(u)}return r},v.compose=function(){for(var n=arguments,t=n.length;t--;)if(!jt(n[t]))throw new le;return function(){for(var t=arguments,e=n.length;e--;)t=[n[e].apply(this,t)];return t[0]}},v.constant=function(n){return function(){return n}},v.countBy=rr,v.create=function(n,t){var e=nt(n);return t?Ye(e,t):e},v.createCallback=function(n,t,e){var r=typeof n;if(null==n||"function"==r)return tt(n,t,e);
if("object"!=r)return Xt(n);var u=We(n),o=u[0],a=n[o];return 1!=u.length||a!==a||xt(a)?function(t){for(var e=u.length,r=false;e--&&(r=at(t[u[e]],n[u[e]],null,true)););return r}:function(n){return n=n[o],a===n&&(0!==a||1/a==1/n)}},v.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,pt(n,4,null,null,null,t)},v.debounce=Vt,v.defaults=Ze,v.defer=function(n){if(!jt(n))throw new le;var t=s(arguments,1);return Ce(function(){n.apply(h,t)},1)},v.delay=function(n,t){if(!jt(n))throw new le;var e=s(arguments,2);
return Ce(function(){n.apply(h,e)},t)},v.difference=function(n){return rt(n,ot(arguments,true,true,1))},v.filter=At,v.flatten=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(n=Bt(n,e,r)),ot(n,t)},v.forEach=Dt,v.forEachRight=Nt,v.forIn=nr,v.forInRight=function(n,t,e){var r=[];nr(n,function(n,t){r.push(t,n)});var u=r.length;for(t=tt(t,e,3);u--&&false!==t(r[u--],r[u],n););return n},v.forOwn=tr,v.forOwnRight=bt,v.functions=_t,v.groupBy=ur,v.indexBy=or,v.initial=function(n,t,e){var r=0,u=n?n.length:0;
if(typeof t!="number"&&null!=t){var o=u;for(t=v.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else r=null==t||e?1:t||r;return s(n,0,Pe(Be(0,u-r),u))},v.intersection=function(){for(var e=[],r=-1,u=arguments.length,a=i(),l=ht(),f=l===n,s=i();++r<u;){var g=arguments[r];(qe(g)||dt(g))&&(e.push(g),a.push(f&&g.length>=_&&o(r?e[r]:s)))}var f=e[0],h=-1,v=f?f.length:0,y=[];n:for(;++h<v;){var m=a[0],g=f[h];if(0>(m?t(m,g):l(s,g))){for(r=u,(m||s).push(g);--r;)if(m=a[r],0>(m?t(m,g):l(e[r],g)))continue n;y.push(g)
}}for(;u--;)(m=a[u])&&p(m);return c(a),c(s),y},v.invert=wt,v.invoke=function(n,t){var e=s(arguments,2),r=-1,u=typeof t=="function",o=n?n.length:0,a=Zt(typeof o=="number"?o:0);return Dt(n,function(n){a[++r]=(u?t:n[t]).apply(n,e)}),a},v.keys=We,v.map=Bt,v.mapValues=function(n,t,e){var r={};return t=v.createCallback(t,e,3),tr(n,function(n,e,u){r[e]=t(n,e,u)}),r},v.max=Pt,v.memoize=function(n,t){if(!jt(n))throw new le;var e=function(){var r=e.cache,u=t?t.apply(this,arguments):b+arguments[0];return we.call(r,u)?r[u]:r[u]=n.apply(this,arguments)
};return e.cache={},e},v.merge=function(n){var t=arguments,e=2;if(!xt(n))return n;if("number"!=typeof t[2]&&(e=t.length),3<e&&"function"==typeof t[e-2])var r=tt(t[--e-1],t[e--],2);else 2<e&&"function"==typeof t[e-1]&&(r=t[--e]);for(var t=s(arguments,1,e),u=-1,o=i(),a=i();++u<e;)it(n,t[u],r,o,a);return c(o),c(a),n},v.min=function(n,t,e){var u=1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&qe(n)){e=-1;for(var a=n.length;++e<a;){var i=n[e];i<o&&(o=i)}}else t=null==t&&kt(n)?r:v.createCallback(t,e,3),Xe(n,function(n,e,r){e=t(n,e,r),e<u&&(u=e,o=n)
});return o},v.omit=function(n,t,e){var r={};if(typeof t!="function"){var u=[];nr(n,function(n,t){u.push(t)});for(var u=rt(u,ot(arguments,true,false,1)),o=-1,a=u.length;++o<a;){var i=u[o];r[i]=n[i]}}else t=v.createCallback(t,e,3),nr(n,function(n,e,u){t(n,e,u)||(r[e]=n)});return r},v.once=function(n){var t,e;if(!jt(n))throw new le;return function(){return t?e:(t=true,e=n.apply(this,arguments),n=null,e)}},v.pairs=function(n){for(var t=-1,e=We(n),r=e.length,u=Zt(r);++t<r;){var o=e[t];u[t]=[o,n[o]]}return u
},v.partial=function(n){return pt(n,16,s(arguments,1))},v.partialRight=function(n){return pt(n,32,null,s(arguments,1))},v.pick=function(n,t,e){var r={};if(typeof t!="function")for(var u=-1,o=ot(arguments,true,false,1),a=xt(n)?o.length:0;++u<a;){var i=o[u];i in n&&(r[i]=n[i])}else t=v.createCallback(t,e,3),nr(n,function(n,e,u){t(n,e,u)&&(r[e]=n)});return r},v.pluck=ar,v.property=Xt,v.pull=function(n){for(var t=arguments,e=0,r=t.length,u=n?n.length:0;++e<r;)for(var o=-1,a=t[e];++o<u;)n[o]===a&&(ke.call(n,o--,1),u--);
return n},v.range=function(n,t,e){n=+n||0,e=typeof e=="number"?e:+e||1,null==t&&(t=n,n=0);var r=-1;t=Be(0,ye((t-n)/(e||1)));for(var u=Zt(t);++r<t;)u[r]=n,n+=e;return u},v.reject=function(n,t,e){return t=v.createCallback(t,e,3),At(n,function(n,e,r){return!t(n,e,r)})},v.remove=function(n,t,e){var r=-1,u=n?n.length:0,o=[];for(t=v.createCallback(t,e,3);++r<u;)e=n[r],t(e,r,n)&&(o.push(e),ke.call(n,r--,1),u--);return o},v.rest=qt,v.shuffle=Tt,v.sortBy=function(n,t,e){var r=-1,o=qe(t),a=n?n.length:0,f=Zt(typeof a=="number"?a:0);
for(o||(t=v.createCallback(t,e,3)),Dt(n,function(n,e,u){var a=f[++r]=l();o?a.m=Bt(t,function(t){return n[t]}):(a.m=i())[0]=t(n,e,u),a.n=r,a.o=n}),a=f.length,f.sort(u);a--;)n=f[a],f[a]=n.o,o||c(n.m),p(n);return f},v.tap=function(n,t){return t(n),n},v.throttle=function(n,t,e){var r=true,u=true;if(!jt(n))throw new le;return false===e?r=false:xt(e)&&(r="leading"in e?e.leading:r,u="trailing"in e?e.trailing:u),H.leading=r,H.maxWait=t,H.trailing=u,Vt(n,t,H)},v.times=function(n,t,e){n=-1<(n=+n)?n:0;var r=-1,u=Zt(n);
for(t=tt(t,e,1);++r<n;)u[r]=t(r);return u},v.toArray=function(n){return n&&typeof n.length=="number"?Le.unindexedChars&&kt(n)?n.split(""):s(n):Et(n)},v.transform=function(n,t,e,r){var u=qe(n);if(null==e)if(u)e=[];else{var o=n&&n.constructor;e=nt(o&&o.prototype)}return t&&(t=v.createCallback(t,r,4),(u?Xe:tr)(n,function(n,r,u){return t(e,n,r,u)})),e},v.union=function(){return ft(ot(arguments,true,true))},v.uniq=Wt,v.values=Et,v.where=At,v.without=function(n){return rt(n,s(arguments,1))},v.wrap=function(n,t){return pt(t,16,[n])
},v.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var e=arguments[n];if(qe(e)||dt(e))var r=r?ft(rt(r,e).concat(rt(e,r))):e}return r||[]},v.zip=Gt,v.zipObject=Jt,v.collect=Bt,v.drop=qt,v.each=Dt,v.eachRight=Nt,v.extend=Ye,v.methods=_t,v.object=Jt,v.select=At,v.tail=qt,v.unique=Wt,v.unzip=Gt,Ut(v),v.clone=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=t,t=false),Y(n,t,typeof e=="function"&&tt(e,r,1))},v.cloneDeep=function(n,t,e){return Y(n,true,typeof t=="function"&&tt(t,e,1))},v.contains=Ot,v.escape=function(n){return null==n?"":ie(n).replace(Qe,gt)
},v.every=St,v.find=It,v.findIndex=function(n,t,e){var r=-1,u=n?n.length:0;for(t=v.createCallback(t,e,3);++r<u;)if(t(n[r],r,n))return r;return-1},v.findKey=function(n,t,e){var r;return t=v.createCallback(t,e,3),tr(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},v.findLast=function(n,t,e){var r;return t=v.createCallback(t,e,3),Nt(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0}),r},v.findLastIndex=function(n,t,e){var r=n?n.length:0;for(t=v.createCallback(t,e,3);r--;)if(t(n[r],r,n))return r;
return-1},v.findLastKey=function(n,t,e){var r;return t=v.createCallback(t,e,3),bt(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},v.has=function(n,t){return n?we.call(n,t):false},v.identity=Ht,v.indexOf=zt,v.isArguments=dt,v.isArray=qe,v.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&he.call(n)==L||false},v.isDate=function(n){return n&&typeof n=="object"&&he.call(n)==z||false},v.isElement=function(n){return n&&1===n.nodeType||false},v.isEmpty=function(n){var t=true;if(!n)return t;var e=he.call(n),r=n.length;
return e==$||e==M||(Le.argsClass?e==T:dt(n))||e==G&&typeof r=="number"&&jt(n.splice)?!r:(tr(n,function(){return t=false}),t)},v.isEqual=function(n,t,e,r){return at(n,t,typeof e=="function"&&tt(e,r,2))},v.isFinite=function(n){return Ie(n)&&!De(parseFloat(n))},v.isFunction=jt,v.isNaN=function(n){return Ct(n)&&n!=+n},v.isNull=function(n){return null===n},v.isNumber=Ct,v.isObject=xt,v.isPlainObject=er,v.isRegExp=function(n){return n&&X[typeof n]&&he.call(n)==J||false},v.isString=kt,v.isUndefined=function(n){return typeof n=="undefined"
},v.lastIndexOf=function(n,t,e){var r=n?n.length:0;for(typeof e=="number"&&(r=(0>e?Be(0,r+e):Pe(e,r-1))+1);r--;)if(n[r]===t)return r;return-1},v.mixin=Ut,v.noConflict=function(){return e._=ge,this},v.noop=Qt,v.now=ir,v.parseInt=lr,v.random=function(n,t,e){var r=null==n,u=null==t;return null==e&&(typeof n=="boolean"&&u?(e=n,n=1):u||typeof t!="boolean"||(e=t,u=true)),r&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,e||n%1||t%1?(e=Fe(),Pe(n+e*(t-n+parseFloat("1e-"+((e+"").length-1))),t)):lt(n,t)},v.reduce=Rt,v.reduceRight=Ft,v.result=function(n,t){if(n){var e=n[t];
return jt(e)?n[t]():e}},v.runInContext=g,v.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:We(n).length},v.some=$t,v.sortedIndex=Kt,v.template=function(n,t,e){var r=v.templateSettings;n=ie(n||""),e=Ze({},e,r);var u,o=Ze({},e.imports,r.imports),r=We(o),o=Et(o),i=0,l=e.interpolate||N,f="__p+='",l=ae((e.escape||N).source+"|"+l.source+"|"+(l===I?O:N).source+"|"+(e.evaluate||N).source+"|$","g");n.replace(l,function(t,e,r,o,l,c){return r||(r=o),f+=n.slice(i,c).replace(P,a),e&&(f+="'+__e("+e+")+'"),l&&(u=true,f+="';"+l+";\n__p+='"),r&&(f+="'+((__t=("+r+"))==null?'':__t)+'"),i=c+t.length,t
}),f+="';",l=e=e.variable,l||(e="obj",f="with("+e+"){"+f+"}"),f=(u?f.replace(x,""):f).replace(C,"$1").replace(E,"$1;"),f="function("+e+"){"+(l?"":e+"||("+e+"={});")+"var __t,__p='',__e=_.escape"+(u?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+f+"return __p}";try{var c=ee(r,"return "+f).apply(h,o)}catch(p){throw p.source=f,p}return t?c(t):(c.source=f,c)},v.unescape=function(n){return null==n?"":ie(n).replace(Ue,mt)},v.uniqueId=function(n){var t=++m;return ie(null==n?"":n)+t
},v.all=St,v.any=$t,v.detect=It,v.findWhere=It,v.foldl=Rt,v.foldr=Ft,v.include=Ot,v.inject=Rt,Ut(function(){var n={};return tr(v,function(t,e){v.prototype[e]||(n[e]=t)}),n}(),false),v.first=Lt,v.last=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=v.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[u-1]:h;return s(n,Be(0,u-r))},v.sample=function(n,t,e){return n&&typeof n.length!="number"?n=Et(n):Le.unindexedChars&&kt(n)&&(n=n.split("")),null==t||e?n?n[lt(0,n.length-1)]:h:(n=Tt(n),n.length=Pe(Be(0,t),n.length),n)
},v.take=Lt,v.head=Lt,tr(v,function(n,t){var e="sample"!==t;v.prototype[t]||(v.prototype[t]=function(t,r){var u=this.__chain__,o=n(this.__wrapped__,t,r);return u||null!=t&&(!r||e&&typeof t=="function")?new y(o,u):o})}),v.VERSION="2.4.1",v.prototype.chain=function(){return this.__chain__=true,this},v.prototype.toString=function(){return ie(this.__wrapped__)},v.prototype.value=Yt,v.prototype.valueOf=Yt,Xe(["join","pop","shift"],function(n){var t=fe[n];v.prototype[n]=function(){var n=this.__chain__,e=t.apply(this.__wrapped__,arguments);
return n?new y(e,n):e}}),Xe(["push","reverse","sort","unshift"],function(n){var t=fe[n];v.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),Xe(["concat","slice","splice"],function(n){var t=fe[n];v.prototype[n]=function(){return new y(t.apply(this.__wrapped__,arguments),this.__chain__)}}),Le.spliceObjects||Xe(["pop","shift","splice"],function(n){var t=fe[n],e="splice"==n;v.prototype[n]=function(){var n=this.__chain__,r=this.__wrapped__,u=t.apply(r,arguments);return 0===r.length&&delete r[0],n||e?new y(u,n):u
}}),v}var h,v=[],y=[],m=0,d={},b=+new Date+"",_=75,w=40,j=" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000",x=/\b__p\+='';/g,C=/\b(__p\+=)''\+/g,E=/(__e\(.*?\)|\b__t\))\+'';/g,O=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,S=/\w*$/,A=/^\s*function[ \n\r\t]+\w/,I=/<%=([\s\S]+?)%>/g,D=RegExp("^["+j+"]*0+(?=.$)"),N=/($^)/,B=/\bthis\b/,P=/['\n\r\t\u2028\u2029\\]/g,R="Array Boolean Date Error Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "),F="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),T="[object Arguments]",$="[object Array]",L="[object Boolean]",z="[object Date]",q="[object Error]",K="[object Function]",W="[object Number]",G="[object Object]",J="[object RegExp]",M="[object String]",V={};
V[K]=false,V[T]=V[$]=V[L]=V[z]=V[W]=V[G]=V[J]=V[M]=true;var H={leading:false,maxWait:0,trailing:false},U={configurable:false,enumerable:false,value:null,writable:false},Q={a:"",b:null,c:"",d:"",e:"",v:null,g:"",h:null,support:null,i:"",j:false},X={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},Y={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},Z=X[typeof window]&&window||this,nt=X[typeof exports]&&exports&&!exports.nodeType&&exports,tt=X[typeof module]&&module&&!module.nodeType&&module,et=tt&&tt.exports===nt&&nt,rt=X[typeof global]&&global;
!rt||rt.global!==rt&&rt.window!==rt||(Z=rt);var ut=g();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Z._=ut, define(function(){return ut})):nt&&tt?et?(tt.exports=ut)._=ut:nt._=ut:Z._=ut}).call(this);
/*!
 * jQuery JavaScript Library v1.11.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:42Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "1.11.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1, IE<9
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( support.ownLast ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1, IE<9
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowclip^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !(--remaining) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
jQuery(function() {
	// Minified: var a,b,c,d
	var val, div, body, container;

	body = document.getElementsByTagName( "body" )[ 0 ];
	if ( !body || !body.style ) {
		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	div = document.createElement( "div" );
	container = document.createElement( "div" );
	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== strundefined ) {
		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
		if ( val ) {
			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );
});




(function() {
	var div = document.createElement( "div" );

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
	var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,
		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[0],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	// Minified: var a,b,c
	var input = document.createElement( "input" ),
		div = document.createElement( "div" ),
		fragment = document.createDocumentFragment();

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	support.noCloneEvent = true;
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}
})();


(function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	for ( i in { submit: true, change: true, focusin: true }) {
		eventName = "on" + i;

		if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: IE < 9, Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!support.noCloneEvent || !support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


(function() {
	var shrinkWrapBlocksVal;

	support.shrinkWrapBlocks = function() {
		if ( shrinkWrapBlocksVal != null ) {
			return shrinkWrapBlocksVal;
		}

		// Will be changed later if needed.
		shrinkWrapBlocksVal = false;

		// Minified: var b,c,d
		var div, body, container;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		// Support: IE6
		// Check if elements with layout shrink-wrap their children
		if ( typeof div.style.zoom !== strundefined ) {
			// Reset CSS: box-sizing; display; margin; border
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;" +
				"padding:1px;width:1px;zoom:1";
			div.appendChild( document.createElement( "div" ) ).style.width = "5px";
			shrinkWrapBlocksVal = div.offsetWidth !== 3;
		}

		body.removeChild( container );

		return shrinkWrapBlocksVal;
	};

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			var condition = conditionFn();

			if ( condition == null ) {
				// The test was not ready at this point; screw the hook this time
				// but check again when needed next time.
				return;
			}

			if ( condition ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	// Minified: var b,c,d,e,f,g, h,i
	var div, style, a, pixelPositionVal, boxSizingReliableVal,
		reliableHiddenOffsetsVal, reliableMarginRightVal;

	// Setup
	div = document.createElement( "div" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];
	style = a && a.style;

	// Finish early in limited (non-browser) environments
	if ( !style ) {
		return;
	}

	style.cssText = "float:left;opacity:.5";

	// Support: IE<9
	// Make sure that element opacity exists (as opposed to filter)
	support.opacity = style.opacity === "0.5";

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
		style.WebkitBoxSizing === "";

	jQuery.extend(support, {
		reliableHiddenOffsets: function() {
			if ( reliableHiddenOffsetsVal == null ) {
				computeStyleTests();
			}
			return reliableHiddenOffsetsVal;
		},

		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		// Support: Android 2.3
		reliableMarginRight: function() {
			if ( reliableMarginRightVal == null ) {
				computeStyleTests();
			}
			return reliableMarginRightVal;
		}
	});

	function computeStyleTests() {
		// Minified: var b,c,d,j
		var div, body, container, contents;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";

		// Support: IE<9
		// Assume reasonable values in the absence of getComputedStyle
		pixelPositionVal = boxSizingReliableVal = false;
		reliableMarginRightVal = true;

		// Check for getComputedStyle so that this code is not run in IE<9.
		if ( window.getComputedStyle ) {
			pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			boxSizingReliableVal =
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Support: Android 2.3
			// Div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			contents = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			contents.style.cssText = div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
			contents.style.marginRight = contents.style.width = "0";
			div.style.width = "1px";

			reliableMarginRightVal =
				!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );
		}

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		contents = div.getElementsByTagName( "td" );
		contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
		reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		if ( reliableHiddenOffsetsVal ) {
			contents[ 0 ].style.display = "";
			contents[ 1 ].style.display = "none";
			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		}

		body.removeChild( container );
	}

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,

	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display && display !== "none" || !hidden ) {
				jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	// Minified: var a,b,c,d,e
	var input, div, select, a, opt;

	// Setup
	div = document.createElement( "div" );
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName("a")[ 0 ];

	// First batch of tests.
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";
})();


var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		} :
		function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	}) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
		(!support.reliableHiddenOffsets() &&
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	// Support: IE6+
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		return !this.isLocal &&

			// Support: IE7-8
			// oldIE XHR does not support non-RFC2616 methods (#13240)
			// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
			// Although this check for six methods instead of eight
			// since IE also does not support "trace" and "connect"
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&

			createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	});
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( options ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch( e ) {
									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;
								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					if ( !options.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off, url.length ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

/* CogJS - v1.0.0 */
var Cog = (function (document, $) {
	'use strict';

	var api = {};

	//backward compatibility
	api.component = {};


	/**
	 * /defaults.js
	 */
	var defaults = {
		noOperation: $.noop,
		emptyArray: [],
		initializedClass: 'initialized',
		initializedSelector: '.initialized',
		globalScopeSelector: 'body',
		modulesGroupSize: 50
	};

	/**
	 * /Type.js
	 */
	var Type = (function () {
		var objectConstructor = Object.prototype.constructor;

		/**
		 * Extends a class
		 * @param BaseType a base class
		 * @param overrides properties and methods of a new class
		 * @returns {Function} a new class
		 */
		function extend(BaseType, overrides) {
			var properties = overrides || {};

			//all classes inherit from Object
			BaseType = BaseType || Object;

			//define a new type by selecting constructor: from properties or base type
			var Type = properties.constructor != objectConstructor ?
				properties.constructor : function () {
				BaseType.apply(this, arguments);
			};

			var baseTypePrototype = BaseType.prototype;
			//create a middle type to keep the inheritance chain
			var T = function () {
			};
			T.prototype = baseTypePrototype;

			var typePrototype = $.extend(new T(), properties);
			typePrototype.constructor = Type;

			//set prototype and superclass of new type
			Type.prototype = typePrototype;
			Type.superclass = baseTypePrototype;

			return Type;
		}

		/**
		 * Defines a class
		 * @param properties properties and methods of a new class
		 */
		function define(properties) {
			return extend(null, properties);
		}

		/**
		 * Singleton
		 */
		function singleton(Type, instance) {
			var api = {};

			api.instance = function () {
				return instance;
			};

			api.superclass = Type.superclass;

			return api;
		}

		function singletonWrapper(Type) {
			var Wrapper = extend(Type, {
				constructor: function (parameters) {
					Wrapper.superclass.constructor.apply(this, parameters);
				}
			});

			return Wrapper;
		}


		function asSingleton(Type) {
			var api = {};

			api.create = function () {
				var Wrapper = singletonWrapper(Type);

				return singleton(Type, new Wrapper(arguments));
			};

			return api;
		}

		return {
			define: define,
			extend: extend,
			asSingleton: asSingleton
		};
	}());

	/**
	 * /core/ICore.js
	 */

	var ICore = Type.define({

		eventManager: null,

		addModule: function (module) {
		},

		queueInitTask: function ($scope, moduleIds) {
		},

		queueFinalizeTask: function ($scope) {
		},

		isValidModuleConfig: function (config) {
		},

		isReady: function () {
		},

		whenReady: function (delegate) {
		}
	});

	/**
	 * /core/IEventManager.js
	 */
	var IEventManager = Type.define({

		/**
		 * @return {EventDispatcher} event dispatcher
		 */
		dispatcherFor: function (moduleName, eventName) {
		}

	});

	/**
	 * /core/IModuleManager.js
	 */
	var IModuleManager = Type.define({

		dependencyGraph: null,

		modules: null,

		staticModuleRegistry: null,

		dynamicModuleRegistry: null,

		add: function (module) {
		}

	});
	/**
	 * /core/ITaskQueues.js
	 */

	var ITaskQueues = Type.define({

		initStaticModule: null,

		initDynamicModules: null,

		finalizeDynamicModules: null

	});

	/**
	 * /util/logger/LogLevel.js
	 */
	var LogLevel = {
		off: 1,
		error: 2,
		info: 3,
		debug: 4,
		trace: 5
	};
	/**
	 * /util/logger/Logger.js
	 */
	var Logger = Type.define({

		level: LogLevel.off,

		source: null,

		constructor: function (source, logLevel) {
			this.source = source;
			this.level = logLevel || LogLevel.off;
		},

		error: function (tag/*, message0, message1, ..., messageN*/) {
		},

		info: function (tag/*, message0, message1, ..., messageN*/) {
		},

		debug: function (tag/*, message0, message1, ..., messageN*/) {
		},

		trace: function (tag/*, message0, message1, ..., messageN*/) {
		},

		//protected
		isEnabled: function (logLevel) {
			return logLevel <= this.level;
		}

	});

	/**
	 * /util/logger/loggerFactoryConfig/off.js
	 */
	var LoggerFactoryConfig = {
		level: LogLevel.off
	};

	/**
	 * /util/logger/ILoggerFactory.js
	 */

	var ILoggerFactory = Type.define({

		constructor: function (config) {
		},

		create: function (source, maxDepth) {
		}

	});

	/**
	 * /util/logger/default/LoggerFactory.js
	 */

	var LoggerFactory = Type.asSingleton(Type.extend(ILoggerFactory, {

		logger: new Logger(),

		create: function (source, maxDepth) {
			return this.logger;
		}

	})).create().instance();

	/**
	 * /util/Collection
	 */
	var Collection = Type.define({

		items: null,

		ids: null,

		map: null,

		constructor: function () {
			this.items = [];
			this.ids = [];
			this.map = {};
		},

		add: function (id, item) {
			if (!this.map[id]) {
				this.map[id] = item;
				this.ids.push(id);
				this.items.push(item);
			}
		},

		count: function () {
			return this.items.length;
		},

		get: function (id) {
			return this.map[id] || null;
		},

		has: function (id) {
			return this.map.hasOwnProperty(id);
		},

		select: function (searchedIds) {
			var result = new Collection(),
				map = this.map,
				ids = this.filterIds(searchedIds),
				id,
				i;

			for (i = 0; i < ids.length; i++) {
				id = ids[i];
				result.add(id, map[id]);
			}

			return result;
		},

		selectValues: function (searchedIds) {
			var result = {},
				map = this.map,
				ids = this.filterIds(searchedIds),
				id,
				i;

			for (i = 0; i < ids.length; i++) {
				id = ids[i];
				result[id] = map[id];
			}

			return result;
		},

		filterIds: function (searchedIds) {
			var result = [],
				ids = this.uniqueIds(searchedIds),
				map = this.map,
				i;

			for (i = 0; i < ids.length; i++) {
				if (map.hasOwnProperty(ids[i])) {
					result.push(ids[i]);
				}
			}

			return result;
		},

		//private
		uniqueIds: function (ids) {
			var result = [],
				resultMap = {},
				id,
				i;

			for (i = 0; i < ids.length; i++) {
				id = ids[i];
				if (!resultMap[id]) {
					resultMap[id] = true;
					result.push(id);
				}
			}

			return this.sortedIds(result);
		},

		sortedIds: function (ids) {
			var sortDelegate = $.proxy(this.uniqueIdsSorter, this, this.ids);

			ids.sort(sortDelegate);

			return ids;
		},

		//private
		uniqueIdsSorter: function (ids, firstId, secondId) {
			return $.inArray(firstId, ids) - $.inArray(secondId, ids);
		}

	});

	/**
	 * /util/Counter
	 */
	var Counter = Type.define({

		current: 0,

		next: function (id, item) {
			this.current++;

			return this.current;
		}

	});

	/**
	 * /util/ElementsUtil
	 */
	var ElementsUtil = Type.asSingleton(Type.define({

		indexOfElement: function (elements, $element) {
			var index = -1,
				i;

			for (i = 0; index < 0 && i < elements.length; i++) {
				if ($element.is(elements[i])) {
					index = i;
				}
			}

			return index;
		},

		find: function ($scope, selector) {
			var $result = $scope.find(selector),
				$filtered = $scope.filter(selector);

			return $filtered.length > 0 ? $result.add($filtered) : $result;
		},

		isInScope: function ($scope, $element) {
			return $scope != null && $element != null && $element.parents().is($scope);
		}

	})).create().instance();

	/**
	 * /util/ObjectSplitter.js
	 */
	var ObjectSplitter = Type.asSingleton(Type.define({

		defaults: {
			itemsPerGroup: 1
		},

		initializeGroupSize: function (itemsPerGroup) {
			return itemsPerGroup > 0 ? itemsPerGroup : this.defaults.itemsPerGroup;
		},

		groupItems: function (items, itemsPerGroup) {
			var key,
				groupSize = this.initializeGroupSize(itemsPerGroup),
				context = this.createContext(groupSize),
				group = context.group;

			for (key in items) {
				if (items.hasOwnProperty(key)) {
					group[key] = items[key];
					group = this.update(context);
				}
			}

			this.flush(context);

			return context.groups;
		},

		createContext: function (groupSize) {
			return {
				group: {},
				groups: [],
				counter: groupSize,
				groupSize: groupSize
			};
		},

		update: function (context) {
			context.counter--;
			if (context.counter < 1) {
				context.counter = context.groupSize;
				context.groups.push(context.group);
				context.group = {};
			}

			return context.group;
		},

		flush: function (context) {
			if (context.counter !== context.groupSize) {
				context.groups.push(context.group);
			}
		}

	})).create().instance();

	/**
	 * /util/WrapperFactory.js
	 */
	var WrapperFactory = Type.asSingleton(Type.define({

		create: function (subject, exposedApi) {
			var api = {},
				name,
				i;

			for (i = 0; i < exposedApi.length; i++) {
				name = exposedApi[i];
				if ($.isFunction(subject[name])) {
					api[name] = $.proxy(subject[name], subject);
				}
			}

			return api;
		}

	})).create().instance();

	/**
	 * /dependencies/DependencyGraphNode.js
	 */
	var DependencyGraphNode = Type.define({

		id: null,

		isProcessed: false,

		resolved: false,

		dependencies: null,

		requiredBy: null,

		constructor: function (id) {
			this.id = id;
			this.dependencies = [];
			this.requiredBy = [];
		},

		isResolved: function () {
			return this.resolved;
		},

		resolveIfRequired: function () {
			if (!this.resolved) {
				this.resolve();
			}
		},

		resolve: function () {
			var dependencies = this.dependencies,
				isResolved = true,
				i;

			for (i = 0; isResolved && i < dependencies.length; i++) {
				isResolved = dependencies[i].resolved;
			}

			this.resolved = isResolved;
		},

		resolveAllPredecessors: function () {
			var result = [],
				candidates = this.unresolvedPredecessor();

			if (candidates.length) {
				this.resolvePredecessors(candidates, result);
			}

			return result;
		},

		unresolvedPredecessor: function () {
			var result = [],
				requiredBy = this.requiredBy,
				item,
				i;

			for (i = 0; i < requiredBy.length; i++) {
				item = requiredBy[i];
				if (!item.resolved) {
					result.push(item);
				}
			}

			return result;
		},

		resolvePredecessors: function (nodes, result) {
			var node;

			while (nodes.length > 0) {
				node = nodes.shift();
				node.resolve();
				if (node.resolved) {
					nodes.push.apply(nodes, node.unresolvedPredecessor());
					result.push(node.id);
				}
			}
		}

	});

	/**
	 * /dependencies/DependencyGraphItemAdapter.js
	 */
	var DependencyGraphItemAdapter = Type.define({

		id: function (item) {
		},

		dependencies: function (item) {
		},

		dependencyId: function (dependency) {
		}

	});

	/**
	 * /dependencies/DependencyGraph.js
	 */
	var DependencyGraph = Type.define({

		adapter: null,

		nodes: null,

		constructor: function (adapter) {
			this.adapter = adapter;
			this.nodes = {};
		},

		resolve: function (item) {
			var result = null,
				node = this.getNode(this.adapter.id(item));

			if (!node.isProcessed) {
				this.processDependencies(node, this.adapter.dependencies(item));
			}

			node.resolveIfRequired();
			if (node.isResolved()) {
				result = node.resolveAllPredecessors();
				result.unshift(node.id);
			}

			return result;
		},

		hasNode: function (item) {
			var node = this.nodes[this.adapter.id(item)];

			return node && node.isProcessed;
		},

		getNode: function (id) {
			if (this.nodes[id] == null) {
				this.nodes[id] = new DependencyGraphNode(id);
			}

			return this.nodes[id];
		},

		processDependencies: function (node, dependencies) {
			var item,
				i;

			for (i = 0; i < dependencies.length; i++) {
				item = this.getNode(this.adapter.dependencyId(dependencies[i]));
				node.dependencies.push(item);
				item.requiredBy.push(node);
			}

			node.isProcessed = true;
		}

	});

	/**
	 * /events/EventHandler.js
	 */
	var EventHandler = Type.define({

		id: null,

		delegate: null,

		scope: null,

		params: null,

		disposable: false,

		constructor: function (metadata, delegate, options) {
			this.id = metadata.id;
			this.delegate = delegate || defaults.noOperation;
			this.params = {
				data: {},
				eventData: {}
			};

			if (options) {
				this.processOptions(options);
			}
		},

		isDisposable: function () {
			return this.disposable;
		},

		processOptions: function (options) {
			if (options.scope) {
				this.scope = options.scope;
			}

			if (options.data) {
				this.params.data = options.data;
			}

			this.disposable = options.disposable === true;
		}

	});

	/**
	 * /events/EventHandlerMetadataFactory.js
	 */
	var EventHandlerMetadataFactory = Type.asSingleton(Type.define({

		create: function (module, event, id) {
			return {
				module: module,
				event: event,
				id: id
			};
		}

	})).create();

	/**
	 * /events/EventDispatcher.js
	 */
	var EventDispatcher = Type.define({

		asyncDelegatesCount: defaults.modulesGroupSize,

		moduleName: null,

		eventName: null,

		handlers: null,

		ids: null,

		metadataFactory: null,

		constructor: function (moduleName, eventName) {
			this.moduleName = moduleName;
			this.eventName = eventName;
			this.metadataFactory = EventHandlerMetadataFactory.instance();

			this.handlers = [];
			this.ids = {};
		},

		addHandler: function (delegate, options) {
			var metadata = null,
				handler,
				id;

			if ($.isFunction(delegate)) {
				id = this.generateUniqueId();
				this.ids[id] = true;

				metadata = this.metadataFactory.create(this.moduleName, this.eventName, id);
				handler = new EventHandler(metadata, delegate, options);
				if (handler.isDisposable()) {
					handler.delegate = this.disposableHandler(handler);
				}

				this.handlers.push(handler);
			}

			return metadata;
		},

		removeHandler: function (id) {
			var index = this.indexOfHandler(id),
				found = index > -1;

			if (index > -1) {
				delete this.ids[id];
				this.handlers.splice(index, 1);
			}

			return found;
		},

		dispatch: function (eventData) {
			var handlers = this.handlers.slice(0),
				handler,
				params,
				i;

			for (i = 0; i < handlers.length; i++) {
				handler = handlers[i];
				params = $.extend({}, handler.params);
				if (eventData) {
					params.eventData = eventData;
				}
				handler.delegate.call(handler.scope, params);
			}
		},

		dispatchAsync: function (eventData) {
			var delegates = this.createDelegates(eventData),
				groupsCount = Math.ceil(delegates.length / this.asyncDelegatesCount),
				i;

			for (i = 0; i < groupsCount; i++) {
				setTimeout($.proxy(this.executeAsync, this, delegates, i));
			}
		},

		createDelegates: function (eventData) {
			var handlers = this.handlers.slice(0),
				handler,
				params,
				delegates = [],
				i;

			for (i = 0; i < handlers.length; i++) {
				handler = handlers[i];
				params = $.extend({}, handler.params);
				if (eventData) {
					params.eventData = eventData;
				}
				delegates.push({
					handler: handler,
					params: params
				});
			}

			return delegates;
		},

		executeAsync: function (delegates, group) {
			var start = group * this.asyncDelegatesCount,
				end = Math.min(start + this.asyncDelegatesCount, delegates.length),
				handler,
				item,
				i;

			for (i = start; i < end; i++) {
				item = delegates[i];
				handler = item.handler;
				handler.delegate.call(handler.scope, item.params);
			}
		},

		disposableHandler: function (handler) {
			var delegate = handler.delegate,
				context = this;

			return function (params) {
				delegate.call(handler.scope, params);
				context.removeHandler(handler.id);
			};
		},

		indexOfHandler: function (id) {
			var handlers = this.handlers,
				index = -1,
				i;

			for (i = 0; index < 0 && i < handlers.length; i++) {
				if (handlers[i].id === id) {
					index = i;
				}
			}

			return index;
		},

		generateUniqueId: function () {
			var ids = this.ids,
				id;

			do {
				id = Math.round(new Date().getTime() * Math.random());
			}
			while (ids[id] != null);

			return id;
		}

	});


	/**
	 * /modules/operation/ITaskQueue.js
	 */
	var ITaskQueue = Type.define({

		hasNext: function () {
		},

		next: function () {
		},

		nextId: function () {
		},

		last: function () {
		},

		lastId: function () {
		},

		add: function (task) {
		}
	});

	/**
	 * /modules/operation/CompositeTaskQueue.js
	 */
	var CompositeTaskQueue = Type.extend(ITaskQueue, {

		queues: null,

		constructor: function () {
			this.queues = [];
		},

		hasNext: function () {
			var queues = this.queues,
				hasNext = false,
				i;

			for (i = 0; !hasNext && i < queues.length; i++) {
				hasNext = queues[i].hasNext();
			}

			return hasNext;
		},

		next: function () {
			var queue = this.nextQueue();

			return queue != null ? queue.next() : null;
		},

		nextId: function () {
			var queue = this.nextQueue();

			return queue != null ? queue.nextId() : null;
		},

		last: function () {
			var queue = this.lastQueue();

			return queue != null ? queue.last() : null;
		},

		lastId: function () {
			var queue = this.lastQueue();

			return queue != null ? queue.lastId() : null;
		},

		addQueue: function (queue) {
			this.queues.push(queue);
		},

		nextQueue: function () {
			var queues = this.queues,
				queue = null,
				lowestId = Number.MAX_VALUE,
				id,
				i;

			for (i = 0; i < queues.length; i++) {
				id = queues[i].nextId();
				if (id !== null && id < lowestId) {
					lowestId = id;
					queue = queues[i];
				}
			}

			return queue;
		},

		lastQueue: function () {
			var queues = this.queues,
				queue = null,
				highestId = Number.MIN_VALUE,
				id,
				i;

			for (i = 0; i < queues.length; i++) {
				id = queues[i].nextId();
				if (id !== null && id > highestId) {
					highestId = id;
					queue = queues[i];
				}
			}

			return queue;
		}

	});

	/**
	 * /modules/operation/Task.js
	 */
	var Task = Type.define({

		logger: LoggerFactory.create('Task'),

		counter: new Counter(),

		id: null,

		deferred: null,

		promise: null,

		constructor: function () {
			this.id = this.counter.next();
			this.deferred = $.Deferred();

			this.promise = this.deferred.promise();

			if (this.logger.isEnabled(LogLevel.info)) {
				this.promise.done($.proxy(this.onExecuted, this)).fail($.proxy(this.onAborted, this));
				this.logger.debug('created', this.id);
			}
		},

		execute: function () {
		},

		onExecuted: function () {
			this.logger.debug('executed', this.id);
		},

		onAborted: function () {
			this.logger.debug('aborted', this.id);
		}

	});

	/**
	 * /modules/operation/TaskQueue.js
	 */
	var TaskQueue = Type.extend(ITaskQueue, {

		logger: LoggerFactory.create('TaskQueue'),

		tasks: null,

		constructor: function () {
			this.tasks = [];
		},

		hasNext: function () {
			return this.tasks.length > 0;
		},

		next: function () {
			return this.hasNext() ? this.tasks.shift() : null;
		},

		nextId: function () {
			return this.hasNext() ? this.tasks[0].id : null;
		},

		last: function () {
			return this.hasNext() ? this.tasks.pop() : null;
		},

		lastId: function () {
			var id = null;

			if (this.hasNext()) {
				var tasks = this.tasks;
				id = tasks[tasks.length - 1];
			}

			return id;
		},

		add: function (task) {
			var logger = this.logger;

			logger.debug('adding task', task.id);
			if (this.accepts(task)) {
				logger.debug('task accepted', task.id);
				this.process(task);
			}
			else {
				logger.debug('task rejected', task.id);
				task.deferred.reject();
			}
		},

		accepts: function (task) {
			return true;
		},

		process: function (task) {
			this.tasks.push(task);
		}

	});

	/**
	 * /tasks/TaskRunner.js
	 */
	var TaskRunner = Type.define({

		logger: LoggerFactory.create('TaskRunner'),

		delay: 0,

		queues: null,

		locked: false,

		constructor: function (delay) {
			this.queues = [];
			if (delay > 0) {
				this.delay = delay;
			}
		},

		executeNext: function () {
			var logger = this.logger,
				task = !this.locked ? this.findNext() : null;

			if (task != null) {
				this.locked = true;
				logger.trace('locked');

				task.promise.always($.proxy(this.unlock, this));
				logger.debug('execute', task.id);
				this.executeAsync(task);
			}
		},

		findNext: function () {
			var queues = this.queues,
				queue,
				task = null,
				i;

			for (i = 0; task == null && i < queues.length; i++) {
				queue = queues[i];
				task = queue.next();
			}

			return task;
		},

		addQueue: function (queue) {
			this.queues.push(queue);
		},

		unlock: function () {
			this.locked = false;
			this.logger.trace('unlocked');
			this.executeNext();
		},

		executeAsync: function (task) {
			setTimeout($.proxy(task.execute, task), this.delay);
		}

	});

	/**
	 * /iterator/ObjectIterator.js
	 */
	var ObjectIterator = Type.define({

		logger: LoggerFactory.create('ObjectIterator'),

		items: null,

		constructor: function (items) {
			this.items = items || {};
		},

		eachItem: function (itemProcessor, scope) {
			var deferred = $.Deferred();

			this.executeOnEach(itemProcessor, scope);
			//try {
			//}
			//catch (e) {
			//	this.logger.error('error has occured', e);
			//	deferred.rejectWith(scope, [e]);
			//}
			//finally {
			//	this.logger.trace('processing finished');
				deferred.resolveWith(scope);
			//}

			return deferred.promise();
		},

		executeOnEach: function (itemProcessor, scope) {
			var logger = this.logger,
				items = this.items,
				key;

			for (key in items) {
				if (items.hasOwnProperty(key)) {//filtering object properties
					logger.trace('processing', key);
					if (itemProcessor.call(scope, items[key]) === false) { //aborting iteration by itemProcessor
						logger.trace('processing aborted by itemProcessor');
						break;
					}
				}
			}
		}

	});

	/**
	 * /iterator/AsyncObjectIteratorContext.js
	 */
	var AsyncObjectIteratorContext = Type.define({

		itemProcessor: null,

		scope: null,

		aborted: false,

		deferred: null,

		constructor: function (itemProcessor, scope) {
			this.itemProcessor = itemProcessor;
			this.scope = scope;

			this.aborted = false;
			this.deferred = $.Deferred();

			if (!$.isFunction(itemProcessor)) {
				this.abort();
			}
		},

		isAborted: function () {
			return this.aborted;
		},

		abort: function () {
			this.aborted = true;
		},

		resolve: function () {
			return this.deferred.resolveWith(this.scope);
		},

		reject: function (e) {
			this.abort();

			return this.deferred.rejectWith(this.scope, [e]);
		},

		promise: function () {
			return this.deferred.promise();
		},

		processItem: function (item) {
			var result = this.itemProcessor.call(this.scope, item);

			if (result === false) {
				this.abort();
			}

			return result;
		}
	});


	/**
	 * /iterator/AsyncObjectIterator.js
	 */

	var AsyncObjectIterator = Type.extend(ObjectIterator, {

		logger: LoggerFactory.create('AsyncObjectIterator'),

		defaults: {
			timeout: 0,
			itemsPerExecution: 1
		},

		itemsPerExecution: null,

		timeout: null,

		allItems: null,

		constructor: function (items, itemsPerExecution, timeout) {
			AsyncObjectIterator.superclass.constructor.call(this, null);

			var defaults = this.defaults;

			this.allItems = items;
			this.itemsPerExecution = this.isNonNegative(itemsPerExecution) ?
				itemsPerExecution : defaults.itemsPerExecution;
			this.timeout = this.isNonNegative(timeout) ? timeout : defaults.timeout;
		},

		eachItem: function (itemProcessor, scope) {
			var context = new AsyncObjectIteratorContext(itemProcessor, scope),
				groups = ObjectSplitter.groupItems(this.allItems, this.itemsPerExecution);

			if (this.logger.isEnabled(LogLevel.trace)) {
				this.logger.trace('iterating', {
					groupsCount: groups.length,
					maxGroupSize: this.itemsPerExecution,
					timeout: this.timeout
				});
			}

			this.eachItemsGroup(context, groups);

			return context.promise();
		},

		isNonNegative: function (value) {
			return isFinite(value) && value >= 0;
		},

		eachItemsGroup: function (context, groups) {
			if (!context.isAborted() && groups.length > 0) {
				this.logger.trace('iterating over group');

				var group = groups.shift();
				var scope = this;
				setTimeout(function () {
					scope.items = group;
					AsyncObjectIterator.superclass.eachItem.call(scope, context.processItem, context)
						.fail($.proxy(context.reject, context));

					scope.eachItemsGroup(context, groups);

				}, this.timeout);
			}
			else {
				context.resolve();
			}
		}

	});


	/**
	 * /modules/tasks/initModulesTask/SelectElementsStrategy.js
	 */
	var SelectElementsStrategy = Type.define({

		initializedSelector: defaults.initializedSelector,

		notInitializedSelector: ':not(' + defaults.initializedSelector + ')',

		execute: function ($scope, targetModules) {
			return null;
		}

	});

	/**
	 * /modules/tasks/initModulesTask/SelectElementsDefaultStrategy.js
	 */
	var SelectElementsDefaultStrategy = Type.extend(SelectElementsStrategy, {

		logger: LoggerFactory.create('SelectElementsDefaultStrategy'),

		execute: function ($scope, targetModules) {
			this.logger.trace('executing');

			var selector = this.createSelector(targetModules),
				$elements = selector ? ElementsUtil.find($scope, selector) : null;

			this.logger.trace('executed');

			return ($elements && $elements.length > 0) ? $elements : null;
		},

		createSelector: function (targetModules) {
			var selectors = [],
				modules = targetModules.items,
				module,
				i;

			for (i = 0; i < modules.length; i++) {
				module = modules[i];
				if (module.selector) {
					this.processSelector(module.selector, selectors);
				}
			}

			return selectors.join(',');
		},

		processSelector: function (selector, selectors) {
			var notInitializedSelector = this.notInitializedSelector,
				items = selector.split(','),
				i;

			for (i = 0; i < items.length; i++) {
				selectors.push(items[i] + notInitializedSelector);
			}
		}

	});

	/**
	 * /modules/tasks/initModulesTask/SelectElementsPrefetchStrategy.js
	 */
	var SelectElementsPrefetchStrategy = Type.extend(SelectElementsStrategy, {

		logger: LoggerFactory.create('SelectElementsPrefetchStrategy'),

		tagNamePattern: /^\w+/i,

		execute: function ($scope, targetModules) {
			this.logger.trace('executing');

			var selectors = this.createSelectors(targetModules);
			var $elements = null;

			if (selectors.prefetch) {
				$elements = ElementsUtil.find($scope, selectors.prefetch).not(this.initializedSelector);
			}

			this.logger.trace('executed');

			return ($elements && $elements.length > 0) ? $elements : null;
		},

		createSelectors: function (targetModules) {
			var result = this.initializeSelectors(),
				modules = targetModules.items,
				module,
				i;

			for (i = 0; i < modules.length; i++) {
				module = modules[i];
				if (module.selector) {
					this.processSelector(module.selector, result);
				}
			}

			result.all = result.all.join(',');
			result.prefetch = result.prefetch.join(',');

			return result;
		},

		initializeSelectors: function () {
			return {
				all: [],
				prefetch: [],
				prefetchMap: {}
			};
		},

		processSelector: function (selector, result) {
			var pattern = this.tagNamePattern,
				items = selector.split(','),
				item,
				tagName,
				i;

			result.all.push(selector);

			for (i = 0; i < items.length; i++) {
				item = $.trim(items[i]);
				tagName = pattern.exec(item);
				tagName = (tagName && tagName.length) ? tagName[0] : null;
				if (tagName != null) {
					item = tagName;
				}
				this.addToPrefetched(result, item);
			}
		},

		addToPrefetched: function (selectors, key) {
			if (!selectors.prefetchMap[key]) {
				selectors.prefetch.push(key);
				selectors.prefetchMap[key] = true;
			}
		}

	});

	/**
	 * /modules/tasks/DynamicModuleTaskQueue.js
	 */
	var DynamicModuleTaskQueue = Type.extend(TaskQueue, {

		relatedQueue: null,

		constructor: function (relatedQueue) {
			DynamicModuleTaskQueue.superclass.constructor.call(this);

			this.relatedQueue = relatedQueue || new TaskQueue();
		},

		process: function (task) {
			var index = this.joinIndex(task);
			if (index !== null) {
				this.join(task, index);
			}
			else {
				DynamicModuleTaskQueue.superclass.process.call(this, task);
			}
		},

		//abstract
		//protected
		join: function (task, index) {
		},

		//protected
		joinIndex: function (task) {
			var index = null;

			if (this.tasks.length > 0) {
				var id = this.relatedQueue.lastId();
				index = (id !== null) ? this.nextJoinIndex(id) : 0;
			}

			return index;
		},

		//private
		nextJoinIndex: function (minimalId) {
			var index = null,
				tasks = this.tasks,
				i;

			for (i = 0; index !== null && i < tasks.length; i++) {
				if (tasks[i].id > minimalId) {
					index = i;
				}
			}

			return index;
		}

	});

	/**
	 * /modules/tasks/FinalizeModulesTask.js
	 */
	var FinalizeModulesTask = Type.extend(Task, {

		logger: LoggerFactory.create('FinalizeModulesTask'),

		maxGroupSize: defaults.modulesGroupSize,

		$scope: null,

		$elements: null,

		modules: null,

		constructor: function ($scope, modules) {
			FinalizeModulesTask.superclass.constructor.call(this);

			this.modules = modules;
			this.$scope = $scope;
		},

		execute: function () {
			var logger = this.logger,
				$elements = ElementsUtil.find(this.$scope, defaults.initializedSelector);

			var deferred = this.deferred;
			if ($elements.length > 0) {
				logger.info('executing', this.id);

				this.$elements = $elements;

				var iterator = new AsyncObjectIterator(this.modules.map, this.maxGroupSize);
				iterator.eachItem(this.itemProcessor, this).always($.proxy(deferred.resolve, deferred));
			}
			else {
				logger.info('nothing to do', this.id);

				deferred.resolve();
			}
		},

		itemProcessor: function (module) {
			var $intersection = this.$elements.filter(module.$elements);

			if ($intersection.length > 0) {
				this.logger.trace('elements found', module.name, $intersection.length);

				this.$elements = this.$elements.not($intersection);
				module.$elements = module.$elements.not($intersection);

				this.finalizeElements(module, $intersection);
			}

			return this.$elements.length > 0;
		},

		finalizeElements: function (module, $elements) {
			var i;

			for (i = 0; i < $elements.length; i++) {
				module.finalize($elements.eq(i));
			}
		}

	});

	/**
	 * /modules/tasks/FinalizeModulesTaskQueue.js
	 */
	var FinalizeModulesTaskQueue = Type.extend(DynamicModuleTaskQueue, {

		logger: LoggerFactory.create('FinalizeModulesTaskQueue'),

		accepts: function (task) {
			return task.$scope && task.$scope.length;
		},

		join: function (task, index) {
			var targetTask = this.tasks[index];
			targetTask.$scope = targetTask.$scope.add(task.$scope);

			this.logger.trace('join task', {
				source: task.id,
				target: targetTask.id,
				targetIndex: index
			});

			var deferred = task.deferred;
			targetTask.promise.always($.proxy(deferred.resolve, deferred));

		}

	});

	/**
	 * /modules/tasks/InitModulesTask.js
	 */
	var InitModulesTask = Type.extend(Task, {

		notInitializedSelector: ':not(' + defaults.initializedSelector + ')',

		logger: LoggerFactory.create('InitModulesTask'),

		maxGroupSize: defaults.modulesGroupSize,

		elementsStrategy: null,

		modules: null,

		moduleIds: null,

		targetModules: null,

		$scope: null,

		$elements: null,

		rejectDelegate: null,

		isPrefetchRequired: false,

		constructor: function ($scope, moduleIds, modules) {
			InitModulesTask.superclass.constructor.call(this);

			this.isPrefetchRequired = !$.isFunction(document.getElementsByClassName);
			if (this.isPrefetchRequired) {
				this.maxGroupSize = 1;
			}
			this.elementsStrategy = this.selectElementsStrategy();

			this.$scope = $scope;
			this.moduleIds = moduleIds ? modules.filterIds(moduleIds) : null;
			this.modules = modules;
		},

		selectElementsStrategy: function () {
			return this.isPrefetchRequired ? new SelectElementsPrefetchStrategy() : new SelectElementsDefaultStrategy();
		},

		processAllModules: function () {
			return this.moduleIds == null;
		},

		execute: function () {
			var logger = this.logger;

			this.targetModules = this.processAllModules() ? this.modules : this.modules.select(this.moduleIds);

			if (this.targetModules.count() > 0) {
				logger.info('executing', this.id, {modulesCount: this.targetModules.count()});

				this.$elements = this.elementsStrategy.execute(this.$scope, this.targetModules);
				this.rejectDelegate = $.proxy(this.deferred.reject, this.deferred);
				this.executeBeforeInit();
			}
			else {
				logger.info('nothing to do', this.id);

				this.deferred.resolve();
			}
		},

		executeBeforeInit: function () {
			this.logger.trace('executing beforeInit()', this.id);

			var iterator = new AsyncObjectIterator(this.targetModules.map, this.maxGroupSize);
			iterator.eachItem(this.beforeInitProcessor, this)
				.done($.proxy(this.executeInit, this))
				.fail(this.rejectDelegate);
		},

		executeInit: function () {
			this.logger.trace('executing init()', this.id);

			var deferred = this.deferred;
			var iterator = new AsyncObjectIterator(this.targetModules.map, this.maxGroupSize);
			iterator.eachItem(this.initProcessor, this)
				.done($.proxy(deferred.resolve, deferred))
				.fail(this.rejectDelegate);
		},

		beforeInitProcessor: function (module) {
			module.beforeInit();
		},

		initProcessor: function (module) {
			var $elements = null;

			if (this.$elements && module.selector) {
				$elements = this.$elements.filter(module.selector).addClass(defaults.initializedClass);
			}

			module.init($elements || $());
		}

	});

	/**
	 * /modules/tasks/InitModulesTaskQueue.js
	 */
	var InitModulesTaskQueue = Type.extend(DynamicModuleTaskQueue, {

		logger: LoggerFactory.create('InitModulesTaskQueue'),

		accepts: function (task) {
			var isValidScope = task.$scope && task.$scope.length;

			return isValidScope && (task.moduleIds ? task.moduleIds.length > 0 : true);
		},

		join: function (task, index) {
			var targetTask = this.tasks[index];

			this.logger.trace('join task', {
				source: task.id,
				target: targetTask.id,
				targetIndex: index
			});

			this.joinTasks(targetTask, task);
		},

		joinTasks: function (targetTask, task) {
			this.joinScopes(targetTask, task);
			this.joinModules(targetTask, task);

			var deferred = task.deferred;
			targetTask.promise.always($.proxy(deferred.resolve, deferred));
		},

		joinScopes: function (targetTask, task) {
			if (ElementsUtil.isInScope(task.$scope, targetTask.$scope)) {
				//if targetTask's scope is in task's scope
				targetTask.$scope = task.$scope;
			}
			else if (!targetTask.$scope.is(task.$scope) && !ElementsUtil.isInScope(targetTask.$scope, task.$scope)) {
				//if scopes are different and task's scope is not in targetTask's scope
				targetTask.$scope = targetTask.$scope.add(task.$scope);
			}
		},

		joinModules: function (targetTask, task) {
			if (!targetTask.processAllModules() && task.processAllModules()) {
				targetTask.moduleIds = null;
			}
			else if (!targetTask.processAllModules() && !task.processAllModules()) {
				targetTask.moduleIds = this.joinModuleIds(targetTask.moduleIds, task.moduleIds);
			}
		},

		joinModuleIds: function (firstSet, secondSet) {
			var delta = firstSet.length - secondSet.length,
				target = delta >= 0 ? firstSet : secondSet,
				source = delta <= 0 ? secondSet : firstSet;

			this.addModuleIds(source, target);

			return target;
		},

		addModuleIds: function (source, target) {
			var i;

			for (i = 0; i < source.length; i++) {
				if ($.inArray(source[i], target) < 0) {
					target.push(source[i]);
				}
			}
		},

		//protected
		//override
		joinIndex: function (task) {
			var index = InitModulesTaskQueue.superclass.joinIndex.call(this, task);

			return index !== null ? this.findJoinIndex(task, index) : null;
		},

		findJoinIndex: function (task, startIndex) {
			var index = null,
				tasks = this.tasks,
				i;

			for (i = startIndex; index === null && i < tasks.length; i++) {
				if (this.isTaskJoinable(tasks[i], task)) {
					index = i;
				}
			}

			return index;
		},

		anyProcessesAllModules: function (targetTask, task) {
			return task.processAllModules() || targetTask.processAllModules();
		},

		isTaskJoinable: function (targetTask, task) {
			//check if scopes are equal
			var result = task.$scope.is(targetTask.$scope);

			//if not check if both tasks process all modules
			if (!result) {
				result = task.processAllModules() && targetTask.processAllModules();
			}

			//if not check if both tasks process equal sets of modules
			if (!(result || this.anyProcessesAllModules(targetTask, task))) {
				result = this.equalModuleIds(task.moduleIds, targetTask.moduleIds);
			}

			return result;
		},

		equalModuleIds: function (firstSet, secondSet) {
			var result = firstSet.length == secondSet.length,
				i;

			for (i = 0; result && i < firstSet.length; i++) {
				result = $.inArray(firstSet[i], secondSet) >= 0;
			}

			return result;
		}

	});

	/**
	 * /components/ComponentManager.js
	 */
	var ComponentManager = Type.define({

		defaults: {
			propertyName: '$scope',
			onUnregister: defaults.noOperation,
			onRegister: function ($element) {
				return {$scope: $element};
			},
			scope: null
		},

		components: null,

		config: null,

		constructor: function (settings) {
			settings = settings || {};

			this.components = [];
			this.config = $.extend(true, {}, this.defaults, settings);

			//make sure that onRegister is a function 
			if (!$.isFunction(this.config.onRegister)) {
				this.config.onRegister = this.defaults.onRegister;
			}
		},

		register: function ($elements) {
			var component,
				onRegister = this.config.onRegister,
				scope = this.config.scope,
				i;

			for (i = 0; i < $elements.length; i++) {
				component = onRegister.call(scope, $elements.eq(i));
				this.components.push(component);
			}
		},

		unregister: function ($element) {
			var index = this.indexOfComponent($element),
				component;

			if (index >= 0) {
				component = this.components[index];
				this.components.splice(index, 1);
				this.config.onUnregister.call(this.config.scope, component);
			}
		},

		indexOfComponent: function ($element) {
			var items = this.components,
				propertyName = this.config.propertyName;

			if (items != null && propertyName != null) {
				items = this.selectProperty(propertyName);
			}

			return ElementsUtil.indexOfElement(items, $element);
		},

		selectProperty: function (propertyName) {
			var items = this.components,
				result = [],
				empty = {},
				item,
				i;

			for (i = 0; i < items.length; i++) {
				item = items[i] || empty;
				item = item[propertyName];
				if (item) {
					result.push(item);
				}
			}

			return result;
		}

	});

	/**
	 * /modules/StaticModule.js
	 */
	var StaticModule = Type.define({

		name: null,

		api: null,

		sharedApi: null,

		externalApi: null,

		requires: null,

		constructor: function (config) {
			this.name = config.name;
			this.api = config.api;
			this.sharedApi = config.sharedApi || null;
			this.externalApi = config.externalApi || {};
			this.requires = config.requires || defaults.emptyArray;

			this.processApi();

			this.updateRequiredModules();
		},

		init: function () {
			this.api.init();
		},

		//backward compatibility
		updateRequiredModules: function () {
			var requires = this.requires,
				item,
				i;

			for (i = 0; i < requires.length; i++) {
				item = requires[i];
				if ($.type(item) === 'string') {
					requires[i] = {
						name: item
					};
				}
			}
		},

		processApi: function () {
			this.api.init = this.processDelegate(this.api.init);
			this.api.external = this.externalApi;
		},

		processDelegate: function (delegate) {
			return this.isValidDelegate(delegate) ? delegate : defaults.noOperation;
		},

		isValidDelegate: function (delegate) {
			return $.isFunction(delegate);
		}

	});

	/**
	 * /modules/DynamicModule.js
	 */
	var DynamicModule = Type.extend(StaticModule, {

		$elements: null,

		selector: null,

		//private
		hasFinalize: false,

		constructor: function (config) {
			DynamicModule.superclass.constructor.call(this, config);

			this.beforeInit = config.api.beforeInit || defaults.noOperation;
			this.selector = config.selector || null;

			if (this.isFinalizable()) {
				this.$elements = $();
			}
		},

		init: function ($elements) {
			if (this.isFinalizable()) {
				this.$elements = this.$elements.add($elements);
			}
			this.api.init($elements);
		},

		beforeInit: function () {
			this.api.beforeInit();
		},

		finalize: function ($element) {
			if (this.hasFinalize) {
				this.api.finalize($element);
			}
		},

		isFinalizable: function () {
			return this.hasFinalize;
		},

		processApi: function () {
			DynamicModule.superclass.processApi.call(this);

			var api = this.api;
			api.beforeInit = this.processDelegate(api.beforeInit);
			this.hasFinalize = this.isValidDelegate(api.finalize);
		}

	});

	/**
	 * /modules/ComponentModule.js
	 */
	var ComponentModule = Type.extend(DynamicModule, {

		componentManager: null,

		constructor: function (config) {
			ComponentModule.superclass.constructor.call(this, config);

			this.componentManager = new ComponentManager({
				onRegister: this.onRegister,
				onUnregister: this.api.onUnregister,
				scope: this
			});
		},

		init: function ($elements) {
			if ($elements.length > 0) {
				this.componentManager.register($elements);
			}

			ComponentModule.superclass.init.call(this, $elements);
		},

		onRegister: function ($element) {
			var component = {
				$scope: $element
			};

			this.api.onRegister(component);

			return component;
		},

		finalize: function ($element) {
			ComponentModule.superclass.finalize.call(this, $element);

			this.componentManager.unregister($element);
		},

		isFinalizable: function () {
			return true;
		},

		processApi: function () {
			ComponentModule.superclass.processApi.call(this);

			this.api.onRegister = this.processDelegate(this.api.onRegister);
			this.api.onUnregister = this.processDelegate(this.api.onUnregister);
		}


	});

	/**
	 * /modules/DependencyGraphModuleAdapter.js
	 */
	var DependencyGraphModuleAdapter = Type.extend(DependencyGraphItemAdapter, {

		id: function (item) {
			return item.name;
		},

		dependencies: function (item) {
			return item.requires;
		},

		dependencyId: function (dependency) {
			return dependency.name;
		}

	});

	/**
	 * /registry/tasks/InitStaticModuleTask
	 */
	var InitStaticModuleTask = Type.extend(Task, {

		logger: LoggerFactory.create('InitStaticModuleTask'),

		maxGroupSize: defaults.modulesGroupSize,

		moduleIds: null,

		modules: null,

		constructor: function (id, modules) {
			InitStaticModuleTask.superclass.constructor.call(this);

			this.modules = modules;
			this.moduleIds = [];
			if (id) {
				this.moduleIds.push(id);
			}
		},

		execute: function () {
			var modules = this.modules.selectValues(this.moduleIds);
			var iterator = new AsyncObjectIterator(modules, this.maxGroupSize);

			this.logger.trace('executing', this.id, this.moduleIds);

			var deferred = this.deferred;
			iterator.eachItem(this.itemProcessor, this).always($.proxy(deferred.resolve, deferred));
		},

		itemProcessor: function (module) {
			module.init();
		}

	});

	/**
	 * /registry/tasks/InitStaticModuleTaskQueue.js
	 */
	var InitStaticModuleTaskQueue = Type.extend(TaskQueue, {

		logger: LoggerFactory.create('InitStaticModuleTaskQueue'),

		accepts: function (task) {
			return task.moduleIds.length;
		},

		process: function (task) {
			if (this.tasks.length > 0) {
				this.join(task);
			}
			else {
				InitStaticModuleTaskQueue.superclass.process.call(this, task);
			}
		},

		join: function (task) {
			var firstTask = this.tasks[0];

			this.logger.trace('join task', {
				source: task.id,
				target: firstTask.id
			});

			var moduleIds = firstTask.moduleIds;
			moduleIds.push.apply(moduleIds, task.moduleIds);

			var deferred = task.deferred;
			firstTask.promise.always($.proxy(deferred.resolve, deferred));
		}

	});

	/**
	 * /modules/ModuleRegistry.js
	 */
	var ModuleRegistry = Type.define({

		modules: null,

		constructor: function () {
			this.modules = new Collection();
		},

		add: function (module) {
			this.modules.add(module.name, module);
		}

	});

	/**
	 * /modules/StaticModuleRegistry.js
	 */
	var StaticModuleRegistry = Type.extend(ModuleRegistry, {

		taskRunner: null,

		taskQueue: null,

		constructor: function (taskRunner, taskQueue) {
			StaticModuleRegistry.superclass.constructor.call(this);

			this.taskRunner = taskRunner;
			this.taskQueue = taskQueue;
		},

		add: function (module) {
			StaticModuleRegistry.superclass.add.call(this, module);

			this.taskQueue.add(new InitStaticModuleTask(module.name, this.modules));
			this.taskRunner.executeNext();
		}

	});

	/**
	 * /modules/DynamicModuleRegistry.js
	 */
	var DynamicModuleRegistry = Type.extend(ModuleRegistry, {

		finalizableModules: null,

		constructor: function () {
			DynamicModuleRegistry.superclass.constructor.call(this);

			this.finalizableModules = new Collection();
		},

		add: function (module) {
			DynamicModuleRegistry.superclass.add.call(this, module);

			if (module.isFinalizable()) {
				this.finalizableModules.add(module.name, module);
			}
		}

	});

	/**
	 * /core/default/EventManager.js
	 */
	var EventManager = Type.extend(IEventManager, {

		events: null,

		constructor: function () {
			this.events = {};
		},

		dispatcherFor: function (moduleName, eventName) {
			var dispatcher = null,
				events = this.events;

			if (moduleName && eventName) {
				var namespace = events[moduleName];
				if (!(namespace && namespace[eventName])) {
					this.addEvent(moduleName, eventName);
				}
				dispatcher = events[moduleName][eventName];
			}

			return dispatcher;
		},

		//private
		addEvent: function (moduleName, eventName) {
			var events = this.events;

			if (!events[moduleName]) {
				events[moduleName] = {};
			}

			var namespace = events[moduleName];
			if (!namespace[eventName]) {
				namespace[eventName] = new EventDispatcher(moduleName, eventName);
			}
		}

	});

	/**
	 * /core/default/ModuleManager.js
	 */
	var ModuleManager = Type.extend(IModuleManager, {

		logger: LoggerFactory.create('ModuleManager'),

		dependencyGraph: null,

		modules: null,

		staticModuleRegistry: null,

		dynamicModuleRegistry: null,

		constructor: function (staticModuleManager, dynamicModuleManager) {
			this.dependencyGraph = new DependencyGraph(new DependencyGraphModuleAdapter());
			this.staticModuleRegistry = staticModuleManager;
			this.dynamicModuleRegistry = dynamicModuleManager;
			this.modules = {};
		},

		add: function (module) {
			var logger = this.logger;

			logger.trace('trying add module', module.name);
			if (!this.dependencyGraph.hasNode(module)) {
				this.modules[module.name] = module;
				logger.trace('module added', module.name);

				var ids = this.dependencyGraph.resolve(module);
				logger.debug('resolved module id\'s', ids);
				if (ids != null) {
					this.initializeModules(ids);
				}
			}
		},

		initializeModules: function (ids) {
			var modules = this.modules,
				module,
				i;

			for (i = 0; i < ids.length; i++) {
				module = modules[ids[i]];
				if (module) {
					this.initializeModule(module);
				}
			}
		},

		initializeModule: function (module) {
			this.injectApi(module);

			var registry = (module instanceof DynamicModule) ? this.dynamicModuleRegistry : this.staticModuleRegistry;
			registry.add(module);
		},


		injectApi: function (module) {
			var modules = this.modules,
				requires = module.requires,
				requiredModule,
				entry,
				i;

			for (i = 0; i < requires.length; i++) {
				entry = requires[i];
				requiredModule = modules[entry.name];
				if (entry.apiId) {
					module.externalApi[entry.apiId] = requiredModule.sharedApi || null;
				}
			}
		}

	});

	/**
	 * /core/default/TaskQueues.js
	 */

	var TaskQueues = Type.extend(ITaskQueues, {

		constructor: function () {
			this.initStaticModule = new InitStaticModuleTaskQueue();
			this.initializeDynamicModuleQueues();
		},

		initializeDynamicModuleQueues: function () {
			var initRelatedQueue = new CompositeTaskQueue();
			this.initDynamicModules = new InitModulesTaskQueue(initRelatedQueue);

			var finalizeRelatedQueue = new CompositeTaskQueue();
			this.finalizeDynamicModules = new FinalizeModulesTaskQueue(finalizeRelatedQueue);

			initRelatedQueue.addQueue(this.finalizeDynamicModules);
			finalizeRelatedQueue.addQueue(this.initDynamicModules);
		}

	});

	/**
	 * /core/default/Core.js
	 */

	var Core = Type.asSingleton(Type.extend(ICore, {

		eventManager: null,

		taskQueues: null,

		taskRunner: null,

		moduleManager: null,

		dynamicModuleRegistry: null,

		ready: false,

		constructor: function () {
			this.eventManager = new EventManager();
			this.taskQueues = new TaskQueues();
			this.taskRunner = this.initializeTaskRunner();
			this.moduleManager = this.initializeModuleManager();
			this.dynamicModuleRegistry = this.moduleManager.dynamicModuleRegistry;
			this.whenReady($.proxy(this.onReady, this));
		},

		isValidModuleConfig: function (config) {
			return config && config.name && config.api;
		},

		addModule: function (module) {
			this.moduleManager.add(module);
		},

		queueInitTask: function ($scope, moduleIds) {
			var task = new InitModulesTask($scope, moduleIds, this.dynamicModuleRegistry.modules);

			this.taskQueues.initDynamicModules.add(task);
			this.taskRunner.executeNext();

			return task.promise;
		},

		queueFinalizeTask: function ($scope) {
			var task = new FinalizeModulesTask($scope, this.dynamicModuleRegistry.finalizableModules);

			this.taskQueues.finalizeDynamicModules.add(task);
			this.taskRunner.executeNext();

			return task.promise;
		},

		whenReady: function (delegate) {
		    var noJsUserAgentsPattern = /240x320|blackberry|opera mini|palm|symbian|series40/;
		    var currentUserAgent = navigator.userAgent.toLowerCase();
		    if (noJsUserAgentsPattern.test(currentUserAgent)) {
		        // no js support
                document.documentElement.className += ' no-js';
            	return false;
		    } else {
   			    $(document).ready(delegate);
		    }
		},

		isReady: function () {
			return this.ready;
		},

		onReady: function () {
			this.ready = true;
		},

		initializeTaskRunner: function () {
			var taskRunner = new TaskRunner(),
				queues = this.taskQueues;

			taskRunner.addQueue(queues.initStaticModule);

			var dynamicModulesQueue = new CompositeTaskQueue();
			dynamicModulesQueue.addQueue(queues.initDynamicModules);
			dynamicModulesQueue.addQueue(queues.finalizeDynamicModules);

			taskRunner.addQueue(dynamicModulesQueue);

			return taskRunner;
		},

		initializeModuleManager: function () {
			var staticModuleRegistry = new StaticModuleRegistry(this.taskRunner, this.taskQueues.initStaticModule),
				dynamicModuleRegistry = new DynamicModuleRegistry();

			return new ModuleManager(staticModuleRegistry, dynamicModuleRegistry);
		}

	})).create().instance();


	/**
	 * diagnostic/default/Diagnostic.js
	 */

	/**
	 * /api/logger.js
	 */

	var logger = LoggerFactory.create('CogJS', 3);

	/**
	 * /api/Type.js
	 */

	api.Type = {
		/**
		 * Defines a class
		 * @param properties properties and methods of a new class
		 */
		define: Type.define,
		/**
		 * Extends a class
		 * @param Type a base class
		 * @param overrides properties and methods of a new class
		 * @returns {Function} a new class
		 */
		extend: Type.extend,
		asSingleton: Type.asSingleton
	};


	/**
	 * /api/Modules.js
	 */

	/**
	 * Register new static module - a module initialized instantly exactly once when all dependencies are resolved.
	 * This type of modules should require API of static modules only.In other case dependencies won't be resolved
	 * correctly. Other types of modules can require API of static modules.
	 * @param options - an object with required and optional properties of a module:
	 *  name - name of the module (required)
	 *  api - API object of the module (required); requires init method. Other will be ignored.
	 *  api.init - init function for module (optional, executed once)
	 *  sharedApi - object with intenal API (API shared with other modules)
	 *  extetnalApi - object where all required API (shared by other modules) will be inject; it also will be injected
	 *                into api object as external property.
	 *  requires - an array with names of required components or objects with two properties: name (name of the required
	 *             module) and apiId (property name under which API shared by the required module will be injected).
	 *  Note: If component A requires component B, component B cannot require component A.
	 */
	api.registerStatic = function (options) {
		if (Core.isValidModuleConfig(options)) {
			Core.addModule(new StaticModule(options));
		}
		else {
			logger.error('Invalid StaticModule config', options);
		}
	};

	/**
	 * Register new module
	 * @param options - an object with required and optional properties of a module:
	 *  name - name of the module (required)
	 *  api - API object of the module (required)
	 *  api.init - init function for module
	 *  api.beforeInit - beforeInit function for module
	 *  sharedApi - object with intenal API (API shared with other modules)
	 *  extetnalApi - object where all required API (shared by other modules) will be inject; it also will be injected
	 *                into api object as external property.
	 *  requires - an array with names of required components or objects with two properties: name (name of the required
	 *             module) and apiId (property name under which API shared by the required module will be injected).
	 *  selector - a jQuery selector
	 *  Note: If component A requires component B, component B cannot require component A.
	 */
	api.register = function (options) {
		if (Core.isValidModuleConfig(options)) {
			Core.addModule(new DynamicModule(options));
		}
		else {
			logger.error('Invalid DynamicModule config', options);
		}
	};

	/**
	 * Register new component module - a module with {@link ComponentManager} attached to init and finalize methods
	 * @param options - an object with required and optional properties of a module:
	 *  name - name of the module (required)
	 *  api - API object of the module (required); requires onRegister method,
	 *        finalize and onUnregister are optional.
	 *  api.init - init function for module (optional, executed after api.onRegister)
	 *  api.beforeInit - beforeInit function for module
	 *  api.onRegister - executed when component is created (required)
	 *  api.onUnregister - executed when component is destroyed (optional)
	 *  sharedApi - object with intenal API (API shared with other modules)
	 *  extetnalApi - object where all required API (shared by other modules) will be inject; it also will be injected
	 *                into api object as external property.
	 *  requires - an array with names of required components or objects with two properties: name (name of the required
	 *             module) and apiId (property name under which API shared by the required module will be injected).
	 *  selector - a jQuery selector
	 *  Note: If component A requires component B, component B cannot require component A.
	 */
	api.registerComponent = function (options) {
		if (Core.isValidModuleConfig(options) && $.isFunction(options.api.onRegister)) {
			Core.addModule(new ComponentModule(options));
		}
		else {
			logger.error('Invalid ComponentModule config', options);
		}
	};

	/**
	 * /api/Lifecycle.js
	 */

	/**
	 * Finalizes all dynamic modules bound with elements and all component modules in $scope if passed,
	 * globally otherwise
	 */
	api.finalize = function ($scope) {
		return Core.isReady() ? Core.queueFinalizeTask($scope || $(defaults.globalScopeSelector)) : null;
	};

	/**
	 *
	 * @param {object} option - Optional config object. It can contain '$element' property with jQuery object
	 * of a container element and/or 'modules' property - array with modules to init
	 */
	api.init = (function (options) {

		function scopeFrom(options) {
			return options.$element || $(defaults.globalScopeSelector);
		}

		function moduleIdsFrom(options) {
			return $.isArray(options.modules) ? options.modules : null;
		}

		function queueInitTask() {
			var promise = null;

			if (Core.isReady()) {
				options = options || {};
				promise = Core.queueInitTask(scopeFrom(options), moduleIdsFrom(options));
			}

			return promise;
		}

		return queueInitTask;
	}());

	/**
	 * /api/Events.js
	 */

	/**
	 * Attaches event listener to any event
	 * @param {string} moduleName Name of the module that registered the event
	 * @param {string} eventName Name of the event to attach the listener to
	 * @param {function} fn reference to the listener
	 * @param {object} options Optional object with special options of attaching listener.
	 *   This might contain scope property which enables to control the 'scope' of the
	 *   listener and/or 'data' property - an object with parameters passed to the listener
	 *   and/or 'disposable' property - listener will be removed after first event
	 * @returns {object} metadata object, which can be used to remove the listener or null
	 */

	api.addListener = function (moduleName, eventName, fn, options) { /* jshint ignore:line */ //backward compatibility
		var dispatcher = $.isFunction(fn) ? Core.eventManager.dispatcherFor(moduleName, eventName) : null,
			metadata = null;

		if (dispatcher != null) {
			metadata = dispatcher.addHandler(fn, options);
		}
		else {
			logger.error('Invalid EventHandler config', arguments);
		}

		return metadata;
	};

	/**
	 * Removes event listener
	 * @param {object} metadata listener metadata returned by addListener method.
	 * @returns {boolean} true if listener has been found, false otherwise
	 */
	api.removeListener = function (metadata) {
		var dispatcher = null,
			removed = false;

		if (metadata) {
			dispatcher = Core.eventManager.dispatcherFor(metadata.module, metadata.event);
			removed = dispatcher.removeHandler(metadata.id);
		}

		return removed;
	};

	/**
	 *    Fires any defined event
	 *    @param {string} moduleName Name of the module that registered the event
	 *    @param {string} eventName Name of the event to attach the listener to
	 *    @param {object} eventData Optional object containing special parameters passed to listeners
	 */
	api.fireEvent = function (moduleName, eventName, eventData) {
		var dispatcher = Core.eventManager.dispatcherFor(moduleName, eventName);

		if (dispatcher != null) {
			dispatcher.dispatch(eventData);
		}
	};

	/**
	 *    Fires any defined event asynchronously
	 *    @param {string} moduleName Name of the module that registered the event
	 *    @param {string} eventName Name of the event to attach the listener to
	 *    @param {object} eventData Optional object containig special parameters passed to listeners
	 */
	api.fireEventAsync = function (moduleName, eventName, eventData) {
		var dispatcher = Core.eventManager.dispatcherFor(moduleName, eventName);

		if (dispatcher != null) {
			dispatcher.dispatchAsync(eventData);
		}
	};

	/**
	 * /api/Utils.js
	 */

	/**
	 * Wrapper around $(document).ready - fires given function when (or if) document is ready.
	 */
	api.ready = function (fn) {
		Core.whenReady(fn);
	};

	/**
	 * Checks if $scope is a parent of $element.
	 * @param {object} $scope jQuery object representing a scope.
	 * @param {object} $element jQuery object.
	 * @return true if $scope is a parent of $container , false otherwise
	 */
	api.isInScope = function ($scope, $element) {
		return ElementsUtil.isInScope($scope, $element);
	};

	/**
	 * Finds all children objects matching selector and adds $scope if it matches selector
	 * @param {object} $scope jQuery object representing a scope.
	 * @param {object} selector jQuery selector.
	 * @return a set of matching elements
	 */
	api.find = function ($scope, selector) {
		return ElementsUtil.find($scope, selector);
	};

	/**
	 * Returns jQuery used by the framework
	 */
	api.jQuery = function () {
		return $;
	};

	/**
	 * Wrapper around $(document).ready - fires given function when (or if) document is ready.
	 */
	api.logger = function (source, maxDepth) {
		var logger = null;

		if (source) {
			logger = WrapperFactory.create(LoggerFactory.create(source, maxDepth), ['error', 'debug', 'info']);
		}

		return logger;
	};

	/**
	 * /api/Cookie.js
	 */
// inspired by http://www.quirksmode.org/js/cookies.html
	api.Cookie = {

		create: function (name, value, days) {
			var expires = '',
				date;

			if (days) {
				date = new Date();
				date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
				expires = '; expires=' + date.toGMTString();
			}

			document.cookie = name + '=' + value + expires + '; path=/';
		},

		read: function (name) {
			var nameEQ = name + '=',
				ca = document.cookie.split(';'),
				c = null,
				i;

			for (i = 0; i < ca.length; i++) {
				c = ca[i];
				while (c.charAt(0) == ' ') {
					c = c.substring(1, c.length);
				}
				if (c.indexOf(nameEQ) === 0) {
					return c.substring(nameEQ.length, c.length);
				}
			}
			return null;
		},

		erase: function (name) {
			api.Cookie.create(name, '', -1);
		}

	};

	/**
	 * /api/default/Diagnostic.js
	 */

	/**
	 * /init.js
	 */
	Core.whenReady(api.init);


	return api;
}(document, jQuery.noConflict(true)));

/*!
 *
 * MediaElement.js
 * HTML5 <video> and <audio> shim and player
 * http://mediaelementjs.com/
 *
 * Creates a JavaScript object that mimics HTML5 MediaElement API
 * for browsers that don't understand HTML5 or can't play the provided codec
 * Can play MP4 (H.264), Ogg, WebM, FLV, WMV, WMA, ACC, and MP3
 *
 * Copyright 2010-2014, John Dyer (http://j.hn)
 * License: MIT
 *
 */
// Namespace
var mejs = mejs || {};

// version number
mejs.version = '2.20.1';


// player number (for missing, same id attr)
mejs.meIndex = 0;

// media types accepted by plugins
mejs.plugins = {
	silverlight: [
		{version: [3,0], types: ['video/mp4','video/m4v','video/mov','video/wmv','audio/wma','audio/m4a','audio/mp3','audio/wav','audio/mpeg']}
	],
	flash: [
		{version: [9,0,124], types: ['video/mp4','video/m4v','video/mov','video/flv','video/rtmp','video/x-flv','audio/flv','audio/x-flv','audio/mp3','audio/m4a','audio/mpeg', 'video/dailymotion', 'video/x-dailymotion', 'application/x-mpegURL']}
		// 'video/youtube', 'video/x-youtube',
		// ,{version: [12,0], types: ['video/webm']} // for future reference (hopefully!)
	],
	youtube: [
		{version: null, types: ['video/youtube', 'video/x-youtube', 'audio/youtube', 'audio/x-youtube']}
	],
	vimeo: [
		{version: null, types: ['video/vimeo', 'video/x-vimeo']}
	]
};

/*
 Utility methods
 */
mejs.Utility = {
	encodeUrl: function(url) {
		return encodeURIComponent(url); //.replace(/\?/gi,'%3F').replace(/=/gi,'%3D').replace(/&/gi,'%26');
	},
	escapeHTML: function(s) {
		return s.toString().split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
	},
	absolutizeUrl: function(url) {
		var el = document.createElement('div');
		el.innerHTML = '<a href="' + this.escapeHTML(url) + '">x</a>';
		return el.firstChild.href;
	},
	getScriptPath: function(scriptNames) {
		var
			i = 0,
			j,
			codePath = '',
			testname = '',
			slashPos,
			filenamePos,
			scriptUrl,
			scriptPath,
			scriptFilename,
			scripts = document.getElementsByTagName('script'),
			il = scripts.length,
			jl = scriptNames.length;

		// go through all <script> tags
		for (; i < il; i++) {
			scriptUrl = scripts[i].src;
			slashPos = scriptUrl.lastIndexOf('/');
			if (slashPos > -1) {
				scriptFilename = scriptUrl.substring(slashPos + 1);
				scriptPath = scriptUrl.substring(0, slashPos + 1);
			} else {
				scriptFilename = scriptUrl;
				scriptPath = '';
			}

			// see if any <script> tags have a file name that matches the
			for (j = 0; j < jl; j++) {
				testname = scriptNames[j];
				filenamePos = scriptFilename.indexOf(testname);
				if (filenamePos > -1) {
					codePath = scriptPath;
					break;
				}
			}

			// if we found a path, then break and return it
			if (codePath !== '') {
				break;
			}
		}

		// send the best path back
		return codePath;
	},
	/*
	 * Calculate the time format to use. We have a default format set in the
	 * options but it can be imcomplete. We ajust it according to the media
	 * duration.
	 *
	 * We support format like 'hh:mm:ss:ff'.
	 */
	calculateTimeFormat: function(time, options, fps) {
		if (time < 0) {
			time = 0;
		}

		if(typeof fps == 'undefined') {
			fps = 25;
		}

		var format = options.timeFormat,
			firstChar = format[0],
			firstTwoPlaces = (format[1] == format[0]),
			separatorIndex = firstTwoPlaces? 2: 1,
			separator = ':',
			hours = Math.floor(time / 3600) % 24,
			minutes = Math.floor(time / 60) % 60,
			seconds = Math.floor(time % 60),
			frames = Math.floor(((time % 1)*fps).toFixed(3)),
			lis = [
				[frames, 'f'],
				[seconds, 's'],
				[minutes, 'm'],
				[hours, 'h']
			];

		// Try to get the separator from the format
		if (format.length < separatorIndex) {
			separator = format[separatorIndex];
		}

		var required = false;

		for (var i=0, len=lis.length; i < len; i++) {
			if (format.indexOf(lis[i][1]) !== -1) {
				required=true;
			}
			else if (required) {
				var hasNextValue = false;
				for (var j=i; j < len; j++) {
					if (lis[j][0] > 0) {
						hasNextValue = true;
						break;
					}
				}

				if (! hasNextValue) {
					break;
				}

				if (!firstTwoPlaces) {
					format = firstChar + format;
				}
				format = lis[i][1] + separator + format;
				if (firstTwoPlaces) {
					format = lis[i][1] + format;
				}
				firstChar = lis[i][1];
			}
		}
		options.currentTimeFormat = format;
	},
	/*
	 * Prefix the given number by zero if it is lower than 10.
	 */
	twoDigitsString: function(n) {
		if (n < 10) {
			return '0' + n;
		}
		return String(n);
	},
	secondsToTimeCode: function(time, options) {
		if (time < 0) {
			time = 0;
		}

		// Maintain backward compatibility with method signature before v2.18.
		if (typeof options !== 'object') {
			var format = 'm:ss';
			format = arguments[1] ? 'hh:mm:ss' : format; // forceHours
			format = arguments[2] ? format + ':ff' : format; // showFrameCount

			options = {
				currentTimeFormat: format,
				framesPerSecond: arguments[3] || 25
			};
		}

		var fps = options.framesPerSecond;
		if(typeof fps === 'undefined') {
			fps = 25;
		}

		var format = options.currentTimeFormat,
			hours = Math.floor(time / 3600) % 24,
			minutes = Math.floor(time / 60) % 60,
			seconds = Math.floor(time % 60),
			frames = Math.floor(((time % 1)*fps).toFixed(3));
		lis = [
			[frames, 'f'],
			[seconds, 's'],
			[minutes, 'm'],
			[hours, 'h']
		];

		var res = format;
		for (i=0,len=lis.length; i < len; i++) {
			res = res.replace(lis[i][1]+lis[i][1], this.twoDigitsString(lis[i][0]));
			res = res.replace(lis[i][1], lis[i][0]);
		}
		return res;
	},

	timeCodeToSeconds: function(hh_mm_ss_ff, forceHours, showFrameCount, fps){
		if (typeof showFrameCount == 'undefined') {
			showFrameCount=false;
		} else if(typeof fps == 'undefined') {
			fps = 25;
		}

		var tc_array = hh_mm_ss_ff.split(":"),
			tc_hh = parseInt(tc_array[0], 10),
			tc_mm = parseInt(tc_array[1], 10),
			tc_ss = parseInt(tc_array[2], 10),
			tc_ff = 0,
			tc_in_seconds = 0;

		if (showFrameCount) {
			tc_ff = parseInt(tc_array[3])/fps;
		}

		tc_in_seconds = ( tc_hh * 3600 ) + ( tc_mm * 60 ) + tc_ss + tc_ff;

		return tc_in_seconds;
	},


	convertSMPTEtoSeconds: function (SMPTE) {
		if (typeof SMPTE != 'string')
			return false;

		SMPTE = SMPTE.replace(',', '.');

		var secs = 0,
			decimalLen = (SMPTE.indexOf('.') != -1) ? SMPTE.split('.')[1].length : 0,
			multiplier = 1;

		SMPTE = SMPTE.split(':').reverse();

		for (var i = 0; i < SMPTE.length; i++) {
			multiplier = 1;
			if (i > 0) {
				multiplier = Math.pow(60, i);
			}
			secs += Number(SMPTE[i]) * multiplier;
		}
		return Number(secs.toFixed(decimalLen));
	},

	/* borrowed from SWFObject: http://code.google.com/p/swfobject/source/browse/trunk/swfobject/src/swfobject.js#474 */
	removeSwf: function(id) {
		var obj = document.getElementById(id);
		if (obj && /object|embed/i.test(obj.nodeName)) {
			if (mejs.MediaFeatures.isIE) {
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						mejs.Utility.removeObjectInIE(id);
					} else {
						setTimeout(arguments.callee, 10);
					}
				})();
			} else {
				obj.parentNode.removeChild(obj);
			}
		}
	},
	removeObjectInIE: function(id) {
		var obj = document.getElementById(id);
		if (obj) {
			for (var i in obj) {
				if (typeof obj[i] == "function") {
					obj[i] = null;
				}
			}
			obj.parentNode.removeChild(obj);
		}
	}
};


// Core detector, plugins are added below
mejs.PluginDetector = {

	// main public function to test a plug version number PluginDetector.hasPluginVersion('flash',[9,0,125]);
	hasPluginVersion: function(plugin, v) {
		var pv = this.plugins[plugin];
		v[1] = v[1] || 0;
		v[2] = v[2] || 0;
		return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
	},

	// cached values
	nav: window.navigator,
	ua: window.navigator.userAgent.toLowerCase(),

	// stored version numbers
	plugins: [],

	// runs detectPlugin() and stores the version number
	addPlugin: function(p, pluginName, mimeType, activeX, axDetect) {
		this.plugins[p] = this.detectPlugin(pluginName, mimeType, activeX, axDetect);
	},

	// get the version number from the mimetype (all but IE) or ActiveX (IE)
	detectPlugin: function(pluginName, mimeType, activeX, axDetect) {

		var version = [0,0,0],
			description,
			i,
			ax;

		// Firefox, Webkit, Opera
		if (typeof(this.nav.plugins) != 'undefined' && typeof this.nav.plugins[pluginName] == 'object') {
			description = this.nav.plugins[pluginName].description;
			if (description && !(typeof this.nav.mimeTypes != 'undefined' && this.nav.mimeTypes[mimeType] && !this.nav.mimeTypes[mimeType].enabledPlugin)) {
				version = description.replace(pluginName, '').replace(/^\s+/,'').replace(/\sr/gi,'.').split('.');
				for (i=0; i<version.length; i++) {
					version[i] = parseInt(version[i].match(/\d+/), 10);
				}
			}
			// Internet Explorer / ActiveX
		} else if (typeof(window.ActiveXObject) != 'undefined') {
			try {
				ax = new ActiveXObject(activeX);
				if (ax) {
					version = axDetect(ax);
				}
			}
			catch (e) { }
		}
		return version;
	}
};

// Add Flash detection
mejs.PluginDetector.addPlugin('flash','Shockwave Flash','application/x-shockwave-flash','ShockwaveFlash.ShockwaveFlash', function(ax) {
	// adapted from SWFObject
	var version = [],
		d = ax.GetVariable("$version");
	if (d) {
		d = d.split(" ")[1].split(",");
		version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
	}
	return version;
});

// Add Silverlight detection
mejs.PluginDetector.addPlugin('silverlight','Silverlight Plug-In','application/x-silverlight-2','AgControl.AgControl', function (ax) {
	// Silverlight cannot report its version number to IE
	// but it does have a isVersionSupported function, so we have to loop through it to get a version number.
	// adapted from http://www.silverlightversion.com/
	var v = [0,0,0,0],
		loopMatch = function(ax, v, i, n) {
			while(ax.isVersionSupported(v[0]+ "."+ v[1] + "." + v[2] + "." + v[3])){
				v[i]+=n;
			}
			v[i] -= n;
		};
	loopMatch(ax, v, 0, 1);
	loopMatch(ax, v, 1, 1);
	loopMatch(ax, v, 2, 10000); // the third place in the version number is usually 5 digits (4.0.xxxxx)
	loopMatch(ax, v, 2, 1000);
	loopMatch(ax, v, 2, 100);
	loopMatch(ax, v, 2, 10);
	loopMatch(ax, v, 2, 1);
	loopMatch(ax, v, 3, 1);

	return v;
});
// add adobe acrobat
/*
 PluginDetector.addPlugin('acrobat','Adobe Acrobat','application/pdf','AcroPDF.PDF', function (ax) {
 var version = [],
 d = ax.GetVersions().split(',')[0].split('=')[1].split('.');

 if (d) {
 version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
 }
 return version;
 });
 */
// necessary detection (fixes for <IE9)
mejs.MediaFeatures = {
	init: function() {
		var
			t = this,
			d = document,
			nav = mejs.PluginDetector.nav,
			ua = mejs.PluginDetector.ua.toLowerCase(),
			i,
			v,
			html5Elements = ['source','track','audio','video'];

		// detect browsers (only the ones that have some kind of quirk we need to work around)
		t.isiPad = (ua.match(/ipad/i) !== null);
		t.isiPhone = (ua.match(/iphone/i) !== null);
		t.isiOS = t.isiPhone || t.isiPad;
		t.isAndroid = (ua.match(/android/i) !== null);
		t.isBustedAndroid = (ua.match(/android 2\.[12]/) !== null);
		t.isBustedNativeHTTPS = (location.protocol === 'https:' && (ua.match(/android [12]\./) !== null || ua.match(/macintosh.* version.* safari/) !== null));
		t.isIE = (nav.appName.toLowerCase().indexOf("microsoft") != -1 || nav.appName.toLowerCase().match(/trident/gi) !== null);
		t.isChrome = (ua.match(/chrome/gi) !== null);
		t.isChromium = (ua.match(/chromium/gi) !== null);
		t.isFirefox = (ua.match(/firefox/gi) !== null);
		t.isWebkit = (ua.match(/webkit/gi) !== null);
		t.isGecko = (ua.match(/gecko/gi) !== null) && !t.isWebkit && !t.isIE;
		t.isOpera = (ua.match(/opera/gi) !== null);
		t.hasTouch = ('ontouchstart' in window); //  && window.ontouchstart != null); // this breaks iOS 7

		// Borrowed from `Modernizr.svgasimg`, sources:
		// - https://github.com/Modernizr/Modernizr/issues/687
		// - https://github.com/Modernizr/Modernizr/pull/1209/files
		t.svgAsImg = !!document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1');

		// create HTML5 media elements for IE before 9, get a <video> element for fullscreen detection
		for (i=0; i<html5Elements.length; i++) {
			v = document.createElement(html5Elements[i]);
		}

		t.supportsMediaTag = (typeof v.canPlayType !== 'undefined' || t.isBustedAndroid);

		// Fix for IE9 on Windows 7N / Windows 7KN (Media Player not installer)
		try{
			v.canPlayType("video/mp4");
		}catch(e){
			t.supportsMediaTag = false;
		}

		t.supportsPointerEvents = (function() {
			// TAKEN FROM MODERNIZR
			var element = document.createElement('x'),
				documentElement = document.documentElement,
				getComputedStyle = window.getComputedStyle,
				supports;
			if(!('pointerEvents' in element.style)){
				return false;
			}
			element.style.pointerEvents = 'auto';
			element.style.pointerEvents = 'x';
			documentElement.appendChild(element);
			supports = getComputedStyle &&
				getComputedStyle(element, '').pointerEvents === 'auto';
			documentElement.removeChild(element);
			return !!supports;
		})();


		// Older versions of Firefox can't move plugins around without it resetting,
		t.hasFirefoxPluginMovingProblem = false;

		// detect native JavaScript fullscreen (Safari/Firefox only, Chrome still fails)

		// iOS
		t.hasiOSFullScreen = (typeof v.webkitEnterFullscreen !== 'undefined');

		// W3C
		t.hasNativeFullscreen = (typeof v.requestFullscreen !== 'undefined');

		// webkit/firefox/IE11+
		t.hasWebkitNativeFullScreen = (typeof v.webkitRequestFullScreen !== 'undefined');
		t.hasMozNativeFullScreen = (typeof v.mozRequestFullScreen !== 'undefined');
		t.hasMsNativeFullScreen = (typeof v.msRequestFullscreen !== 'undefined');

		t.hasTrueNativeFullScreen = (t.hasWebkitNativeFullScreen || t.hasMozNativeFullScreen || t.hasMsNativeFullScreen);
		t.nativeFullScreenEnabled = t.hasTrueNativeFullScreen;

		// Enabled?
		if (t.hasMozNativeFullScreen) {
			t.nativeFullScreenEnabled = document.mozFullScreenEnabled;
		} else if (t.hasMsNativeFullScreen) {
			t.nativeFullScreenEnabled = document.msFullscreenEnabled;
		}

		if (t.isChrome) {
			t.hasiOSFullScreen = false;
		}

		if (t.hasTrueNativeFullScreen) {

			t.fullScreenEventName = '';
			if (t.hasWebkitNativeFullScreen) {
				t.fullScreenEventName = 'webkitfullscreenchange';

			} else if (t.hasMozNativeFullScreen) {
				t.fullScreenEventName = 'mozfullscreenchange';

			} else if (t.hasMsNativeFullScreen) {
				t.fullScreenEventName = 'MSFullscreenChange';
			}

			t.isFullScreen = function() {
				if (t.hasMozNativeFullScreen) {
					return d.mozFullScreen;

				} else if (t.hasWebkitNativeFullScreen) {
					return d.webkitIsFullScreen;

				} else if (t.hasMsNativeFullScreen) {
					return d.msFullscreenElement !== null;
				}
			}

			t.requestFullScreen = function(el) {

				if (t.hasWebkitNativeFullScreen) {
					el.webkitRequestFullScreen();

				} else if (t.hasMozNativeFullScreen) {
					el.mozRequestFullScreen();

				} else if (t.hasMsNativeFullScreen) {
					el.msRequestFullscreen();

				}
			}

			t.cancelFullScreen = function() {
				if (t.hasWebkitNativeFullScreen) {
					document.webkitCancelFullScreen();

				} else if (t.hasMozNativeFullScreen) {
					document.mozCancelFullScreen();

				} else if (t.hasMsNativeFullScreen) {
					document.msExitFullscreen();

				}
			}

		}


		// OS X 10.5 can't do this even if it says it can :(
		if (t.hasiOSFullScreen && ua.match(/mac os x 10_5/i)) {
			t.hasNativeFullScreen = false;
			t.hasiOSFullScreen = false;
		}

	}
};
mejs.MediaFeatures.init();

/*
 extension methods to <video> or <audio> object to bring it into parity with PluginMediaElement (see below)
 */
mejs.HtmlMediaElement = {
	pluginType: 'native',
	isFullScreen: false,

	setCurrentTime: function (time) {
		this.currentTime = time;
	},

	setMuted: function (muted) {
		this.muted = muted;
	},

	setVolume: function (volume) {
		this.volume = volume;
	},

	// for parity with the plugin versions
	stop: function () {
		this.pause();
	},

	// This can be a url string
	// or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
	setSrc: function (url) {

		// Fix for IE9 which can't set .src when there are <source> elements. Awesome, right?
		var
			existingSources = this.getElementsByTagName('source');
		while (existingSources.length > 0){
			this.removeChild(existingSources[0]);
		}

		if (typeof url == 'string') {
			this.src = url;
		} else {
			var i, media;

			for (i=0; i<url.length; i++) {
				media = url[i];
				if (this.canPlayType(media.type)) {
					this.src = media.src;
					break;
				}
			}
		}
	},

	setVideoSize: function (width, height) {
		this.width = width;
		this.height = height;
	}
};

/*
 Mimics the <video/audio> element by calling Flash's External Interface or Silverlights [ScriptableMember]
 */
mejs.PluginMediaElement = function (pluginid, pluginType, mediaUrl) {
	this.id = pluginid;
	this.pluginType = pluginType;
	this.src = mediaUrl;
	this.events = {};
	this.attributes = {};
};

// JavaScript values and ExternalInterface methods that match HTML5 video properties methods
// http://www.adobe.com/livedocs/flash/9.0/ActionScriptLangRefV3/fl/video/FLVPlayback.html
// http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html
mejs.PluginMediaElement.prototype = {

	// special
	pluginElement: null,
	pluginType: '',
	isFullScreen: false,

	// not implemented :(
	playbackRate: -1,
	defaultPlaybackRate: -1,
	seekable: [],
	played: [],

	// HTML5 read-only properties
	paused: true,
	ended: false,
	seeking: false,
	duration: 0,
	error: null,
	tagName: '',

	// HTML5 get/set properties, but only set (updated by event handlers)
	muted: false,
	volume: 1,
	currentTime: 0,

	// HTML5 methods
	play: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.playVideo();
			} else {
				this.pluginApi.playMedia();
			}
			this.paused = false;
		}
	},
	load: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
			} else {
				this.pluginApi.loadMedia();
			}

			this.paused = false;
		}
	},
	pause: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.pauseVideo();
			} else {
				this.pluginApi.pauseMedia();
			}


			this.paused = true;
		}
	},
	stop: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.stopVideo();
			} else {
				this.pluginApi.stopMedia();
			}
			this.paused = true;
		}
	},
	canPlayType: function(type) {
		var i,
			j,
			pluginInfo,
			pluginVersions = mejs.plugins[this.pluginType];

		for (i=0; i<pluginVersions.length; i++) {
			pluginInfo = pluginVersions[i];

			// test if user has the correct plugin version
			if (mejs.PluginDetector.hasPluginVersion(this.pluginType, pluginInfo.version)) {

				// test for plugin playback types
				for (j=0; j<pluginInfo.types.length; j++) {
					// find plugin that can play the type
					if (type == pluginInfo.types[j]) {
						return 'probably';
					}
				}
			}
		}

		return '';
	},

	positionFullscreenButton: function(x,y,visibleAndAbove) {
		if (this.pluginApi != null && this.pluginApi.positionFullscreenButton) {
			this.pluginApi.positionFullscreenButton(Math.floor(x),Math.floor(y),visibleAndAbove);
		}
	},

	hideFullscreenButton: function() {
		if (this.pluginApi != null && this.pluginApi.hideFullscreenButton) {
			this.pluginApi.hideFullscreenButton();
		}
	},


	// custom methods since not all JavaScript implementations support get/set

	// This can be a url string
	// or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
	setSrc: function (url) {
		if (typeof url == 'string') {
			this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(url));
			this.src = mejs.Utility.absolutizeUrl(url);
		} else {
			var i, media;

			for (i=0; i<url.length; i++) {
				media = url[i];
				if (this.canPlayType(media.type)) {
					this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(media.src));
					this.src = mejs.Utility.absolutizeUrl(media.src);
					break;
				}
			}
		}

	},
	setCurrentTime: function (time) {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.seekTo(time);
			} else {
				this.pluginApi.setCurrentTime(time);
			}



			this.currentTime = time;
		}
	},
	setVolume: function (volume) {
		if (this.pluginApi != null) {
			// same on YouTube and MEjs
			if (this.pluginType == 'youtube') {
				this.pluginApi.setVolume(volume * 100);
			} else {
				this.pluginApi.setVolume(volume);
			}
			this.volume = volume;
		}
	},
	setMuted: function (muted) {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube') {
				if (muted) {
					this.pluginApi.mute();
				} else {
					this.pluginApi.unMute();
				}
				this.muted = muted;
				this.dispatchEvent({type:'volumechange'});
			} else {
				this.pluginApi.setMuted(muted);
			}
			this.muted = muted;
		}
	},

	// additional non-HTML5 methods
	setVideoSize: function (width, height) {

		//if (this.pluginType == 'flash' || this.pluginType == 'silverlight') {
		if (this.pluginElement && this.pluginElement.style) {
			this.pluginElement.style.width = width + 'px';
			this.pluginElement.style.height = height + 'px';
		}
		if (this.pluginApi != null && this.pluginApi.setVideoSize) {
			this.pluginApi.setVideoSize(width, height);
		}
		//}
	},

	setFullscreen: function (fullscreen) {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.pluginApi.setFullscreen(fullscreen);
		}
	},

	enterFullScreen: function() {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.setFullscreen(true);
		}

	},

	exitFullScreen: function() {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.setFullscreen(false);
		}
	},

	// start: fake events
	addEventListener: function (eventName, callback, bubble) {
		this.events[eventName] = this.events[eventName] || [];
		this.events[eventName].push(callback);
	},
	removeEventListener: function (eventName, callback) {
		if (!eventName) { this.events = {}; return true; }
		var callbacks = this.events[eventName];
		if (!callbacks) return true;
		if (!callback) { this.events[eventName] = []; return true; }
		for (var i = 0; i < callbacks.length; i++) {
			if (callbacks[i] === callback) {
				this.events[eventName].splice(i, 1);
				return true;
			}
		}
		return false;
	},
	dispatchEvent: function (event) {
		var i,
			args,
			callbacks = this.events[event.type];

		if (callbacks) {
			for (i = 0; i < callbacks.length; i++) {
				callbacks[i].apply(this, [event]);
			}
		}
	},
	// end: fake events

	// fake DOM attribute methods
	hasAttribute: function(name){
		return (name in this.attributes);
	},
	removeAttribute: function(name){
		delete this.attributes[name];
	},
	getAttribute: function(name){
		if (this.hasAttribute(name)) {
			return this.attributes[name];
		}
		return '';
	},
	setAttribute: function(name, value){
		this.attributes[name] = value;
	},

	remove: function() {
		mejs.Utility.removeSwf(this.pluginElement.id);
		mejs.MediaPluginBridge.unregisterPluginElement(this.pluginElement.id);
	}
};

// Handles calls from Flash/Silverlight and reports them as native <video/audio> events and properties
mejs.MediaPluginBridge = {

	pluginMediaElements:{},
	htmlMediaElements:{},

	registerPluginElement: function (id, pluginMediaElement, htmlMediaElement) {
		this.pluginMediaElements[id] = pluginMediaElement;
		this.htmlMediaElements[id] = htmlMediaElement;
	},

	unregisterPluginElement: function (id) {
		delete this.pluginMediaElements[id];
		delete this.htmlMediaElements[id];
	},

	// when Flash/Silverlight is ready, it calls out to this method
	initPlugin: function (id) {

		var pluginMediaElement = this.pluginMediaElements[id],
			htmlMediaElement = this.htmlMediaElements[id];

		if (pluginMediaElement) {
			// find the javascript bridge
			switch (pluginMediaElement.pluginType) {
				case "flash":
					pluginMediaElement.pluginElement = pluginMediaElement.pluginApi = document.getElementById(id);
					break;
				case "silverlight":
					pluginMediaElement.pluginElement = document.getElementById(pluginMediaElement.id);
					pluginMediaElement.pluginApi = pluginMediaElement.pluginElement.Content.MediaElementJS;
					break;
			}

			if (pluginMediaElement.pluginApi != null && pluginMediaElement.success) {
				pluginMediaElement.success(pluginMediaElement, htmlMediaElement);
			}
		}
	},

	// receives events from Flash/Silverlight and sends them out as HTML5 media events
	// http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html
	fireEvent: function (id, eventName, values) {

		var
			e,
			i,
			bufferedTime,
			pluginMediaElement = this.pluginMediaElements[id];

		if(!pluginMediaElement){
			return;
		}

		// fake event object to mimic real HTML media event.
		e = {
			type: eventName,
			target: pluginMediaElement
		};

		// attach all values to element and event object
		for (i in values) {
			pluginMediaElement[i] = values[i];
			e[i] = values[i];
		}

		// fake the newer W3C buffered TimeRange (loaded and total have been removed)
		bufferedTime = values.bufferedTime || 0;

		e.target.buffered = e.buffered = {
			start: function(index) {
				return 0;
			},
			end: function (index) {
				return bufferedTime;
			},
			length: 1
		};

		pluginMediaElement.dispatchEvent(e);
	}
};

/*
 Default options
 */
mejs.MediaElementDefaults = {
	// allows testing on HTML5, flash, silverlight
	// auto: attempts to detect what the browser can do
	// auto_plugin: prefer plugins and then attempt native HTML5
	// native: forces HTML5 playback
	// shim: disallows HTML5, will attempt either Flash or Silverlight
	// none: forces fallback view
	mode: 'auto',
	// remove or reorder to change plugin priority and availability
	plugins: ['flash','silverlight','youtube','vimeo'],
	// shows debug errors on screen
	enablePluginDebug: false,
	// use plugin for browsers that have trouble with Basic Authentication on HTTPS sites
	httpsBasicAuthSite: false,
	// overrides the type specified, useful for dynamic instantiation
	type: '',
	// path to Flash and Silverlight plugins
	pluginPath: mejs.Utility.getScriptPath(['mediaelement.js','mediaelement.min.js','mediaelement-and-player.js','mediaelement-and-player.min.js']),
	// name of flash file
	flashName: 'flashmediaelement.swf',
	// streamer for RTMP streaming
	flashStreamer: '',
	// set to 'always' for CDN version
	flashScriptAccess: 'sameDomain',
	// turns on the smoothing filter in Flash
	enablePluginSmoothing: false,
	// enabled pseudo-streaming (seek) on .mp4 files
	enablePseudoStreaming: false,
	// start query parameter sent to server for pseudo-streaming
	pseudoStreamingStartQueryParam: 'start',
	// name of silverlight file
	silverlightName: 'silverlightmediaelement.xap',
	// default if the <video width> is not specified
	defaultVideoWidth: 480,
	// default if the <video height> is not specified
	defaultVideoHeight: 270,
	// overrides <video width>
	pluginWidth: -1,
	// overrides <video height>
	pluginHeight: -1,
	// additional plugin variables in 'key=value' form
	pluginVars: [],
	// rate in milliseconds for Flash and Silverlight to fire the timeupdate event
	// larger number is less accurate, but less strain on plugin->JavaScript bridge
	timerRate: 250,
	// initial volume for player
	startVolume: 0.8,
	success: function () { },
	error: function () { }
};

/*
 Determines if a browser supports the <video> or <audio> element
 and returns either the native element or a Flash/Silverlight version that
 mimics HTML5 MediaElement
 */
mejs.MediaElement = function (el, o) {
	return mejs.HtmlMediaElementShim.create(el,o);
};

mejs.HtmlMediaElementShim = {

	create: function(el, o) {
		var
			options = {},
			htmlMediaElement = (typeof(el) == 'string') ? document.getElementById(el) : el,
			tagName = htmlMediaElement.tagName.toLowerCase(),
			isMediaTag = (tagName === 'audio' || tagName === 'video'),
			src = (isMediaTag) ? htmlMediaElement.getAttribute('src') : htmlMediaElement.getAttribute('href'),
			poster = htmlMediaElement.getAttribute('poster'),
			autoplay =  htmlMediaElement.getAttribute('autoplay'),
			preload =  htmlMediaElement.getAttribute('preload'),
			controls =  htmlMediaElement.getAttribute('controls'),
			playback,
			prop;

		// extend options
		for (prop in mejs.MediaElementDefaults) {
			options[prop] = mejs.MediaElementDefaults[prop];
		}
		for (prop in o) {
			options[prop] = o[prop];
		}


		// clean up attributes
		src = 		(typeof src == 'undefined' 	|| src === null || src == '') ? null : src;
		poster =	(typeof poster == 'undefined' 	|| poster === null) ? '' : poster;
		preload = 	(typeof preload == 'undefined' 	|| preload === null || preload === 'false') ? 'none' : preload;
		autoplay = 	!(typeof autoplay == 'undefined' || autoplay === null || autoplay === 'false');
		controls = 	!(typeof controls == 'undefined' || controls === null || controls === 'false');

		// test for HTML5 and plugin capabilities
		playback = this.determinePlayback(htmlMediaElement, options, mejs.MediaFeatures.supportsMediaTag, isMediaTag, src);
		playback.url = (playback.url !== null) ? mejs.Utility.absolutizeUrl(playback.url) : '';

		if (playback.method == 'native') {
			// second fix for android
			if (mejs.MediaFeatures.isBustedAndroid) {
				htmlMediaElement.src = playback.url;
				htmlMediaElement.addEventListener('click', function() {
					htmlMediaElement.play();
				}, false);
			}

			// add methods to native HTMLMediaElement
			return this.updateNative(playback, options, autoplay, preload);
		} else if (playback.method !== '') {
			// create plugin to mimic HTMLMediaElement

			return this.createPlugin( playback,  options, poster, autoplay, preload, controls);
		} else {
			// boo, no HTML5, no Flash, no Silverlight.
			this.createErrorMessage( playback, options, poster );

			return this;
		}
	},

	determinePlayback: function(htmlMediaElement, options, supportsMediaTag, isMediaTag, src) {
		var
			mediaFiles = [],
			i,
			j,
			k,
			l,
			n,
			type,
			result = { method: '', url: '', htmlMediaElement: htmlMediaElement, isVideo: (htmlMediaElement.tagName.toLowerCase() != 'audio')},
			pluginName,
			pluginVersions,
			pluginInfo,
			dummy,
			media;

		// STEP 1: Get URL and type from <video src> or <source src>

		// supplied type overrides <video type> and <source type>
		if (typeof options.type != 'undefined' && options.type !== '') {

			// accept either string or array of types
			if (typeof options.type == 'string') {
				mediaFiles.push({type:options.type, url:src});
			} else {

				for (i=0; i<options.type.length; i++) {
					mediaFiles.push({type:options.type[i], url:src});
				}
			}

			// test for src attribute first
		} else if (src !== null) {
			type = this.formatType(src, htmlMediaElement.getAttribute('type'));
			mediaFiles.push({type:type, url:src});

			// then test for <source> elements
		} else {
			// test <source> types to see if they are usable
			for (i = 0; i < htmlMediaElement.childNodes.length; i++) {
				n = htmlMediaElement.childNodes[i];
				if (n.nodeType == 1 && n.tagName.toLowerCase() == 'source') {
					src = n.getAttribute('src');
					type = this.formatType(src, n.getAttribute('type'));
					media = n.getAttribute('media');

					if (!media || !window.matchMedia || (window.matchMedia && window.matchMedia(media).matches)) {
						mediaFiles.push({type:type, url:src});
					}
				}
			}
		}

		// in the case of dynamicly created players
		// check for audio types
		if (!isMediaTag && mediaFiles.length > 0 && mediaFiles[0].url !== null && this.getTypeFromFile(mediaFiles[0].url).indexOf('audio') > -1) {
			result.isVideo = false;
		}


		// STEP 2: Test for playback method

		// special case for Android which sadly doesn't implement the canPlayType function (always returns '')
		if (mejs.MediaFeatures.isBustedAndroid) {
			htmlMediaElement.canPlayType = function(type) {
				return (type.match(/video\/(mp4|m4v)/gi) !== null) ? 'maybe' : '';
			};
		}

		// special case for Chromium to specify natively supported video codecs (i.e. WebM and Theora)
		if (mejs.MediaFeatures.isChromium) {
			htmlMediaElement.canPlayType = function(type) {
				return (type.match(/video\/(webm|ogv|ogg)/gi) !== null) ? 'maybe' : '';
			};
		}

		// test for native playback first
		if (supportsMediaTag && (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'native')  && !(mejs.MediaFeatures.isBustedNativeHTTPS && options.httpsBasicAuthSite === true)) {

			if (!isMediaTag) {

				// create a real HTML5 Media Element
				dummy = document.createElement( result.isVideo ? 'video' : 'audio');
				htmlMediaElement.parentNode.insertBefore(dummy, htmlMediaElement);
				htmlMediaElement.style.display = 'none';

				// use this one from now on
				result.htmlMediaElement = htmlMediaElement = dummy;
			}

			for (i=0; i<mediaFiles.length; i++) {
				// normal check
				if (mediaFiles[i].type == "video/m3u8" || htmlMediaElement.canPlayType(mediaFiles[i].type).replace(/no/, '') !== ''
						// special case for Mac/Safari 5.0.3 which answers '' to canPlayType('audio/mp3') but 'maybe' to canPlayType('audio/mpeg')
					|| htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/mp3/,'mpeg')).replace(/no/, '') !== ''
						// special case for m4a supported by detecting mp4 support
					|| htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/m4a/,'mp4')).replace(/no/, '') !== '') {
					result.method = 'native';
					result.url = mediaFiles[i].url;
					break;
				}
			}

			if (result.method === 'native') {
				if (result.url !== null) {
					htmlMediaElement.src = result.url;
				}

				// if `auto_plugin` mode, then cache the native result but try plugins.
				if (options.mode !== 'auto_plugin') {
					return result;
				}
			}
		}

		// if native playback didn't work, then test plugins
		if (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'shim') {
			for (i=0; i<mediaFiles.length; i++) {
				type = mediaFiles[i].type;

				// test all plugins in order of preference [silverlight, flash]
				for (j=0; j<options.plugins.length; j++) {

					pluginName = options.plugins[j];

					// test version of plugin (for future features)
					pluginVersions = mejs.plugins[pluginName];

					for (k=0; k<pluginVersions.length; k++) {
						pluginInfo = pluginVersions[k];

						// test if user has the correct plugin version

						// for youtube/vimeo
						if (pluginInfo.version == null ||

							mejs.PluginDetector.hasPluginVersion(pluginName, pluginInfo.version)) {

							// test for plugin playback types
							for (l=0; l<pluginInfo.types.length; l++) {
								// find plugin that can play the type
								if (type.toLowerCase() == pluginInfo.types[l].toLowerCase()) {
									result.method = pluginName;
									result.url = mediaFiles[i].url;
									return result;
								}
							}
						}
					}
				}
			}
		}

		// at this point, being in 'auto_plugin' mode implies that we tried plugins but failed.
		// if we have native support then return that.
		if (options.mode === 'auto_plugin' && result.method === 'native') {
			return result;
		}

		// what if there's nothing to play? just grab the first available
		if (result.method === '' && mediaFiles.length > 0) {
			result.url = mediaFiles[0].url;
		}

		return result;
	},

	formatType: function(url, type) {
		// if no type is supplied, fake it with the extension
		if (url && !type) {
			return this.getTypeFromFile(url);
		} else {
			// only return the mime part of the type in case the attribute contains the codec
			// see http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#the-source-element
			// `video/mp4; codecs="avc1.42E01E, mp4a.40.2"` becomes `video/mp4`

			if (type && ~type.indexOf(';')) {
				return type.substr(0, type.indexOf(';'));
			} else {
				return type;
			}
		}
	},

	getTypeFromFile: function(url) {
		url = url.split('?')[0];
		var
			ext = url.substring(url.lastIndexOf('.') + 1).toLowerCase(),
			av = /(mp4|m4v|ogg|ogv|m3u8|webm|webmv|flv|wmv|mpeg|mov)/gi.test(ext) ? 'video/' : 'audio/';
		return this.getTypeFromExtension(ext, av);
	},

	getTypeFromExtension: function(ext, av) {
		av = av || '';

		switch (ext) {
			case 'mp4':
			case 'm4v':
			case 'm4a':
			case 'f4v':
			case 'f4a':
				return av + 'mp4';
			case 'flv':
				return av + 'x-flv';
			case 'webm':
			case 'webma':
			case 'webmv':
				return av + 'webm';
			case 'ogg':
			case 'oga':
			case 'ogv':
				return av + 'ogg';
			case 'm3u8':
				return 'application/x-mpegurl';
			case 'ts':
				return av + 'mp2t';
			default:
				return av + ext;
		}
	},

	createErrorMessage: function(playback, options, poster) {
		var
			htmlMediaElement = playback.htmlMediaElement,
			errorContainer = document.createElement('div'),
			errorContent = options.customError;

		errorContainer.className = 'me-cannotplay';

		try {
			errorContainer.style.width = htmlMediaElement.width + 'px';
			errorContainer.style.height = htmlMediaElement.height + 'px';
		} catch (e) {}

		if (!errorContent) {
			errorContent = '<a href="' + playback.url + '">';

			if (poster !== '') {
				errorContent += '<img src="' + poster + '" width="100%" height="100%" alt="" />';
			}

			errorContent += '<span>' + mejs.i18n.t('Download File') + '</span></a>';
		}

		errorContainer.innerHTML = errorContent;

		htmlMediaElement.parentNode.insertBefore(errorContainer, htmlMediaElement);
		htmlMediaElement.style.display = 'none';

		options.error(htmlMediaElement);
	},

	createPlugin:function(playback, options, poster, autoplay, preload, controls) {
		var
			htmlMediaElement = playback.htmlMediaElement,
			width = 1,
			height = 1,
			pluginid = 'me_' + playback.method + '_' + (mejs.meIndex++),
			pluginMediaElement = new mejs.PluginMediaElement(pluginid, playback.method, playback.url),
			container = document.createElement('div'),
			specialIEContainer,
			node,
			initVars;

		// copy tagName from html media element
		pluginMediaElement.tagName = htmlMediaElement.tagName

		// copy attributes from html media element to plugin media element
		for (var i = 0; i < htmlMediaElement.attributes.length; i++) {
			var attribute = htmlMediaElement.attributes[i];
			if (attribute.specified) {
				pluginMediaElement.setAttribute(attribute.name, attribute.value);
			}
		}

		// check for placement inside a <p> tag (sometimes WYSIWYG editors do this)
		node = htmlMediaElement.parentNode;

		while (node !== null && node.tagName != null && node.tagName.toLowerCase() !== 'body' &&
		node.parentNode != null && node.parentNode.tagName != null && node.parentNode.constructor != null && node.parentNode.constructor.name === "ShadowRoot") {
			if (node.parentNode.tagName.toLowerCase() === 'p') {
				node.parentNode.parentNode.insertBefore(node, node.parentNode);
				break;
			}
			node = node.parentNode;
		}

		if (playback.isVideo) {
			width = (options.pluginWidth > 0) ? options.pluginWidth : (options.videoWidth > 0) ? options.videoWidth : (htmlMediaElement.getAttribute('width') !== null) ? htmlMediaElement.getAttribute('width') : options.defaultVideoWidth;
			height = (options.pluginHeight > 0) ? options.pluginHeight : (options.videoHeight > 0) ? options.videoHeight : (htmlMediaElement.getAttribute('height') !== null) ? htmlMediaElement.getAttribute('height') : options.defaultVideoHeight;

			// in case of '%' make sure it's encoded
			width = mejs.Utility.encodeUrl(width);
			height = mejs.Utility.encodeUrl(height);

		} else {
			if (options.enablePluginDebug) {
				width = 320;
				height = 240;
			}
		}

		// register plugin
		pluginMediaElement.success = options.success;
		mejs.MediaPluginBridge.registerPluginElement(pluginid, pluginMediaElement, htmlMediaElement);

		// add container (must be added to DOM before inserting HTML for IE)
		container.className = 'me-plugin';
		container.id = pluginid + '_container';

		if (playback.isVideo) {
			htmlMediaElement.parentNode.insertBefore(container, htmlMediaElement);
		} else {
			document.body.insertBefore(container, document.body.childNodes[0]);
		}

		// flash/silverlight vars
		initVars = [
			'id=' + pluginid,
			'jsinitfunction=' + "mejs.MediaPluginBridge.initPlugin",
			'jscallbackfunction=' + "mejs.MediaPluginBridge.fireEvent",
			'isvideo=' + ((playback.isVideo) ? "true" : "false"),
			'autoplay=' + ((autoplay) ? "true" : "false"),
			'preload=' + preload,
			'width=' + width,
			'startvolume=' + options.startVolume,
			'timerrate=' + options.timerRate,
			'flashstreamer=' + options.flashStreamer,
			'height=' + height,
			'pseudostreamstart=' + options.pseudoStreamingStartQueryParam];

		if (playback.url !== null) {
			if (playback.method == 'flash') {
				initVars.push('file=' + mejs.Utility.encodeUrl(playback.url));
			} else {
				initVars.push('file=' + playback.url);
			}
		}
		if (options.enablePluginDebug) {
			initVars.push('debug=true');
		}
		if (options.enablePluginSmoothing) {
			initVars.push('smoothing=true');
		}
		if (options.enablePseudoStreaming) {
			initVars.push('pseudostreaming=true');
		}
		if (controls) {
			initVars.push('controls=true'); // shows controls in the plugin if desired
		}
		if (options.pluginVars) {
			initVars = initVars.concat(options.pluginVars);
		}

		switch (playback.method) {
			case 'silverlight':
				container.innerHTML =
					'<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" id="' + pluginid + '" name="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
					'<param name="initParams" value="' + initVars.join(',') + '" />' +
					'<param name="windowless" value="true" />' +
					'<param name="background" value="black" />' +
					'<param name="minRuntimeVersion" value="3.0.0.0" />' +
					'<param name="autoUpgrade" value="true" />' +
					'<param name="source" value="' + options.pluginPath + options.silverlightName + '" />' +
					'</object>';
				break;

			case 'flash':

				if (mejs.MediaFeatures.isIE) {
					specialIEContainer = document.createElement('div');
					container.appendChild(specialIEContainer);
					specialIEContainer.outerHTML =
						'<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
						'id="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
						'<param name="movie" value="' + options.pluginPath + options.flashName + '?x=' + (new Date()) + '" />' +
						'<param name="flashvars" value="' + initVars.join('&amp;') + '" />' +
						'<param name="quality" value="high" />' +
						'<param name="bgcolor" value="#000000" />' +
						'<param name="wmode" value="transparent" />' +
						'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '" />' +
						'<param name="allowFullScreen" value="true" />' +
						'<param name="scale" value="default" />' +
						'</object>';

				} else {

					container.innerHTML =
						'<embed id="' + pluginid + '" name="' + pluginid + '" ' +
						'play="true" ' +
						'loop="false" ' +
						'quality="high" ' +
						'bgcolor="#000000" ' +
						'wmode="transparent" ' +
						'allowScriptAccess="' + options.flashScriptAccess + '" ' +
						'allowFullScreen="true" ' +
						'type="application/x-shockwave-flash" pluginspage="//www.macromedia.com/go/getflashplayer" ' +
						'src="' + options.pluginPath + options.flashName + '" ' +
						'flashvars="' + initVars.join('&') + '" ' +
						'width="' + width + '" ' +
						'height="' + height + '" ' +
						'scale="default"' +
						'class="mejs-shim"></embed>';
				}
				break;

			case 'youtube':


				var videoId;
				// youtu.be url from share button
				if (playback.url.lastIndexOf("youtu.be") != -1) {
					videoId = playback.url.substr(playback.url.lastIndexOf('/')+1);
					if (videoId.indexOf('?') != -1) {
						videoId = videoId.substr(0, videoId.indexOf('?'));
					}
				}
				else {
					videoId = playback.url.substr(playback.url.lastIndexOf('=')+1);
				}
				youtubeSettings = {
					container: container,
					containerId: container.id,
					pluginMediaElement: pluginMediaElement,
					pluginId: pluginid,
					videoId: videoId,
					height: height,
					width: width
				};

				// favor iframe version of YouTube
				if (window.postMessage) {
					mejs.YouTubeApi.enqueueIframe(youtubeSettings);
				} else if (mejs.PluginDetector.hasPluginVersion('flash', [10,0,0]) ) {
					mejs.YouTubeApi.createFlash(youtubeSettings, options);
				}

				break;

			// DEMO Code. Does NOT work.
			case 'vimeo':
				var player_id = pluginid + "_player";
				pluginMediaElement.vimeoid = playback.url.substr(playback.url.lastIndexOf('/')+1);

				container.innerHTML ='<iframe src="//player.vimeo.com/video/' + pluginMediaElement.vimeoid + '?api=1&portrait=0&byline=0&title=0&player_id=' + player_id + '" width="' + width +'" height="' + height +'" frameborder="0" class="mejs-shim" id="' + player_id + '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
				if (typeof($f) == 'function') { // froogaloop available
					var player = $f(container.childNodes[0]);

					player.addEvent('ready', function() {

						player.playVideo = function() {
							player.api( 'play' );
						}
						player.stopVideo = function() {
							player.api( 'unload' );
						}
						player.pauseVideo = function() {
							player.api( 'pause' );
						}
						player.seekTo = function( seconds ) {
							player.api( 'seekTo', seconds );
						}
						player.setVolume = function( volume ) {
							player.api( 'setVolume', volume );
						}
						player.setMuted = function( muted ) {
							if( muted ) {
								player.lastVolume = player.api( 'getVolume' );
								player.api( 'setVolume', 0 );
							} else {
								player.api( 'setVolume', player.lastVolume );
								delete player.lastVolume;
							}
						}

						function createEvent(player, pluginMediaElement, eventName, e) {
							var event = {
								type: eventName,
								target: pluginMediaElement
							};
							if (eventName == 'timeupdate') {
								pluginMediaElement.currentTime = event.currentTime = e.seconds;
								pluginMediaElement.duration = event.duration = e.duration;
							}
							pluginMediaElement.dispatchEvent(event);
						}

						player.addEvent('play', function() {
							createEvent(player, pluginMediaElement, 'play');
							createEvent(player, pluginMediaElement, 'playing');
						});

						player.addEvent('pause', function() {
							createEvent(player, pluginMediaElement, 'pause');
						});

						player.addEvent('finish', function() {
							createEvent(player, pluginMediaElement, 'ended');
						});

						player.addEvent('playProgress', function(e) {
							createEvent(player, pluginMediaElement, 'timeupdate', e);
						});

						pluginMediaElement.pluginElement = container;
						pluginMediaElement.pluginApi = player;

						// init mejs
						mejs.MediaPluginBridge.initPlugin(pluginid);
					});
				}
				else {
					console.warn("You need to include froogaloop for vimeo to work");
				}
				break;
		}
		// hide original element
		htmlMediaElement.style.display = 'none';
		// prevent browser from autoplaying when using a plugin
		htmlMediaElement.removeAttribute('autoplay');

		// FYI: options.success will be fired by the MediaPluginBridge

		return pluginMediaElement;
	},

	updateNative: function(playback, options, autoplay, preload) {

		var htmlMediaElement = playback.htmlMediaElement,
			m;


		// add methods to video object to bring it into parity with Flash Object
		for (m in mejs.HtmlMediaElement) {
			htmlMediaElement[m] = mejs.HtmlMediaElement[m];
		}

		/*
		 Chrome now supports preload="none"
		 if (mejs.MediaFeatures.isChrome) {

		 // special case to enforce preload attribute (Chrome doesn't respect this)
		 if (preload === 'none' && !autoplay) {

		 // forces the browser to stop loading (note: fails in IE9)
		 htmlMediaElement.src = '';
		 htmlMediaElement.load();
		 htmlMediaElement.canceledPreload = true;

		 htmlMediaElement.addEventListener('play',function() {
		 if (htmlMediaElement.canceledPreload) {
		 htmlMediaElement.src = playback.url;
		 htmlMediaElement.load();
		 htmlMediaElement.play();
		 htmlMediaElement.canceledPreload = false;
		 }
		 }, false);
		 // for some reason Chrome forgets how to autoplay sometimes.
		 } else if (autoplay) {
		 htmlMediaElement.load();
		 htmlMediaElement.play();
		 }
		 }
		 */

		// fire success code
		options.success(htmlMediaElement, htmlMediaElement);

		return htmlMediaElement;
	}
};

/*
 - test on IE (object vs. embed)
 - determine when to use iframe (Firefox, Safari, Mobile) vs. Flash (Chrome, IE)
 - fullscreen?
 */

// YouTube Flash and Iframe API
mejs.YouTubeApi = {
	isIframeStarted: false,
	isIframeLoaded: false,
	loadIframeApi: function() {
		if (!this.isIframeStarted) {
			var tag = document.createElement('script');
			tag.src = "//www.youtube.com/player_api";
			var firstScriptTag = document.getElementsByTagName('script')[0];
			firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
			this.isIframeStarted = true;
		}
	},
	iframeQueue: [],
	enqueueIframe: function(yt) {

		if (this.isLoaded) {
			this.createIframe(yt);
		} else {
			this.loadIframeApi();
			this.iframeQueue.push(yt);
		}
	},
	createIframe: function(settings) {

		var
			pluginMediaElement = settings.pluginMediaElement,
			player = new YT.Player(settings.containerId, {
				height: settings.height,
				width: settings.width,
				videoId: settings.videoId,
				playerVars: {controls:0,wmode:'transparent'},
				events: {
					'onReady': function() {

						// wrapper to match
						player.setVideoSize = function(width, height) {
							player.setSize(width, height);
						}

						// hook up iframe object to MEjs
						settings.pluginMediaElement.pluginApi = player;
						settings.pluginMediaElement.pluginElement = document.getElementById(settings.containerId);

						// init mejs
						mejs.MediaPluginBridge.initPlugin(settings.pluginId);

						// create timer
						setInterval(function() {
							mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
						}, 250);
					},
					'onStateChange': function(e) {

						mejs.YouTubeApi.handleStateChange(e.data, player, pluginMediaElement);

					}
				}
			});
	},

	createEvent: function (player, pluginMediaElement, eventName) {
		var event = {
			type: eventName,
			target: pluginMediaElement
		};

		if (player && player.getDuration) {

			// time
			pluginMediaElement.currentTime = event.currentTime = player.getCurrentTime();
			pluginMediaElement.duration = event.duration = player.getDuration();

			// state
			event.paused = pluginMediaElement.paused;
			event.ended = pluginMediaElement.ended;

			// sound
			event.muted = player.isMuted();
			event.volume = player.getVolume() / 100;

			// progress
			event.bytesTotal = player.getVideoBytesTotal();
			event.bufferedBytes = player.getVideoBytesLoaded();

			// fake the W3C buffered TimeRange
			var bufferedTime = event.bufferedBytes / event.bytesTotal * event.duration;

			event.target.buffered = event.buffered = {
				start: function(index) {
					return 0;
				},
				end: function (index) {
					return bufferedTime;
				},
				length: 1
			};

		}

		// send event up the chain
		pluginMediaElement.dispatchEvent(event);
	},

	iFrameReady: function() {

		this.isLoaded = true;
		this.isIframeLoaded = true;

		while (this.iframeQueue.length > 0) {
			var settings = this.iframeQueue.pop();
			this.createIframe(settings);
		}
	},

	// FLASH!
	flashPlayers: {},
	createFlash: function(settings) {

		this.flashPlayers[settings.pluginId] = settings;

		/*
		 settings.container.innerHTML =
		 '<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="//www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0" ' +
		 'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
		 '<param name="allowScriptAccess" value="sameDomain">' +
		 '<param name="wmode" value="transparent">' +
		 '</object>';
		 */

		var specialIEContainer,
			youtubeUrl = '//www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0';

		if (mejs.MediaFeatures.isIE) {

			specialIEContainer = document.createElement('div');
			settings.container.appendChild(specialIEContainer);
			specialIEContainer.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
				'id="' + settings.pluginId + '" width="' + settings.width + '" height="' + settings.height + '" class="mejs-shim">' +
				'<param name="movie" value="' + youtubeUrl + '" />' +
				'<param name="wmode" value="transparent" />' +
				'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '" />' +
				'<param name="allowFullScreen" value="true" />' +
				'</object>';
		} else {
			settings.container.innerHTML =
				'<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="' + youtubeUrl + '" ' +
				'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
				'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '">' +
				'<param name="wmode" value="transparent">' +
				'</object>';
		}

	},

	flashReady: function(id) {
		var
			settings = this.flashPlayers[id],
			player = document.getElementById(id),
			pluginMediaElement = settings.pluginMediaElement;

		// hook up and return to MediaELementPlayer.success
		pluginMediaElement.pluginApi =
			pluginMediaElement.pluginElement = player;
		mejs.MediaPluginBridge.initPlugin(id);

		// load the youtube video
		player.cueVideoById(settings.videoId);

		var callbackName = settings.containerId + '_callback';

		window[callbackName] = function(e) {
			mejs.YouTubeApi.handleStateChange(e, player, pluginMediaElement);
		}

		player.addEventListener('onStateChange', callbackName);

		setInterval(function() {
			mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
		}, 250);

		mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'canplay');
	},

	handleStateChange: function(youTubeState, player, pluginMediaElement) {
		switch (youTubeState) {
			case -1: // not started
				pluginMediaElement.paused = true;
				pluginMediaElement.ended = true;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'loadedmetadata');
				//createYouTubeEvent(player, pluginMediaElement, 'loadeddata');
				break;
			case 0:
				pluginMediaElement.paused = false;
				pluginMediaElement.ended = true;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'ended');
				break;
			case 1:
				pluginMediaElement.paused = false;
				pluginMediaElement.ended = false;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'play');
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'playing');
				break;
			case 2:
				pluginMediaElement.paused = true;
				pluginMediaElement.ended = false;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'pause');
				break;
			case 3: // buffering
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'progress');
				break;
			case 5:
				// cued?
				break;

		}

	}
}
// IFRAME
window.onYouTubePlayerAPIReady = function() {
	mejs.YouTubeApi.iFrameReady();
};
// FLASH
window.onYouTubePlayerReady = function(id) {
	mejs.YouTubeApi.flashReady(id);
};

window.mejs = mejs;
window.MediaElement = mejs.MediaElement;

/*
 * Adds Internationalization and localization to mediaelement.
 *
 * This file does not contain translations, you have to add them manually.
 * The schema is always the same: me-i18n-locale-[IETF-language-tag].js
 *
 * Examples are provided both for german and chinese translation.
 *
 *
 * What is the concept beyond i18n?
 *   http://en.wikipedia.org/wiki/Internationalization_and_localization
 *
 * What langcode should i use?
 *   http://en.wikipedia.org/wiki/IETF_language_tag
 *   https://tools.ietf.org/html/rfc5646
 *
 *
 * License?
 *
 *   The i18n file uses methods from the Drupal project (drupal.js):
 *     - i18n.methods.t() (modified)
 *     - i18n.methods.checkPlain() (full copy)
 *
 *   The Drupal project is (like mediaelementjs) licensed under GPLv2.
 *    - http://drupal.org/licensing/faq/#q1
 *    - https://github.com/johndyer/mediaelement
 *    - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 *
 * @author
 *   Tim Latz (latz.tim@gmail.com)
 *
 *
 * @params
 *  - context - document, iframe ..
 *  - exports - CommonJS, window ..
 *
 */
;(function(context, exports, undefined) {
	"use strict";

	var i18n = {
		"locale": {
			// Ensure previous values aren't overwritten.
			"language" : (exports.i18n && exports.i18n.locale.language) || '',
			"strings" : (exports.i18n && exports.i18n.locale.strings) || {}
		},
		"ietf_lang_regex" : /^(x\-)?[a-z]{2,}(\-\w{2,})?(\-\w{2,})?$/,
		"methods" : {}
	};
// start i18n


	/**
	 * Get language, fallback to browser's language if empty
	 *
	 * IETF: RFC 5646, https://tools.ietf.org/html/rfc5646
	 * Examples: en, zh-CN, cmn-Hans-CN, sr-Latn-RS, es-419, x-private
	 */
	i18n.getLanguage = function () {
		var language = i18n.locale.language || window.navigator.userLanguage || window.navigator.language;
		return i18n.ietf_lang_regex.exec(language) ? language : null;

		//(WAS: convert to iso 639-1 (2-letters, lower case))
		//return language.substr(0, 2).toLowerCase();
	};

	// i18n fixes for compatibility with WordPress
	if ( typeof mejsL10n != 'undefined' ) {
		i18n.locale.language = mejsL10n.language;
	}



	/**
	 * Encode special characters in a plain-text string for display as HTML.
	 */
	i18n.methods.checkPlain = function (str) {
		var character, regex,
			replace = {
				'&': '&amp;',
				'"': '&quot;',
				'<': '&lt;',
				'>': '&gt;'
			};
		str = String(str);
		for (character in replace) {
			if (replace.hasOwnProperty(character)) {
				regex = new RegExp(character, 'g');
				str = str.replace(regex, replace[character]);
			}
		}
		return str;
	};

	/**
	 * Translate strings to the page language or a given language.
	 *
	 *
	 * @param str
	 *   A string containing the English string to translate.
	 *
	 * @param options
	 *   - 'context' (defaults to the default context): The context the source string
	 *     belongs to.
	 *
	 * @return
	 *   The translated string, escaped via i18n.methods.checkPlain()
	 */
	i18n.methods.t = function (str, options) {

		// Fetch the localized version of the string.
		if (i18n.locale.strings && i18n.locale.strings[options.context] && i18n.locale.strings[options.context][str]) {
			str = i18n.locale.strings[options.context][str];
		}

		return i18n.methods.checkPlain(str);
	};


	/**
	 * Wrapper for i18n.methods.t()
	 *
	 * @see i18n.methods.t()
	 * @throws InvalidArgumentException
	 */
	i18n.t = function(str, options) {

		if (typeof str === 'string' && str.length > 0) {

			// check every time due language can change for
			// different reasons (translation, lang switcher ..)
			var language = i18n.getLanguage();

			options = options || {
					"context" : language
				};

			return i18n.methods.t(str, options);
		}
		else {
			throw {
				"name" : 'InvalidArgumentException',
				"message" : 'First argument is either not a string or empty.'
			};
		}
	};

// end i18n
	exports.i18n = i18n;
}(document, mejs));

// i18n fixes for compatibility with WordPress
;(function(exports, undefined) {

	"use strict";

	if ( typeof mejsL10n != 'undefined' ) {
		exports[mejsL10n.language] = mejsL10n.strings;
	}

}(mejs.i18n.locale.strings));

/*!
 *
 * MediaElementPlayer
 * http://mediaelementjs.com/
 *
 * Creates a controller bar for HTML5 <video> add <audio> tags
 * using jQuery and MediaElement.js (HTML5 Flash/Silverlight wrapper)
 *
 * Copyright 2010-2013, John Dyer (http://j.hn/)
 * License: MIT
 *
 */
if (typeof Cog !== 'undefined') {
	mejs.$ = Cog.jQuery();
} else if (typeof jQuery != 'undefined') {
	mejs.$ = jQuery;
} else if (typeof Zepto != 'undefined') {
	mejs.$ = Zepto;

	// define `outerWidth` method which has not been realized in Zepto
	Zepto.fn.outerWidth = function(includeMargin) {
		var width = $(this).width();
		if (includeMargin) {
			width += parseInt($(this).css('margin-right'), 10);
			width += parseInt($(this).css('margin-left'), 10);
		}
		return width
	}

} else if (typeof ender != 'undefined') {
	mejs.$ = ender;
}
(function ($) {

	// default player values
	mejs.MepDefaults = {
		// url to poster (to fix iOS 3.x)
		poster: '',
		// When the video is ended, we can show the poster.
		showPosterWhenEnded: false,
		// default if the <video width> is not specified
		defaultVideoWidth: 480,
		// default if the <video height> is not specified
		defaultVideoHeight: 270,
		// if set, overrides <video width>
		videoWidth: -1,
		// if set, overrides <video height>
		videoHeight: -1,
		// default if the user doesn't specify
		defaultAudioWidth: 400,
		// default if the user doesn't specify
		defaultAudioHeight: 30,

		// default amount to move back when back key is pressed
		defaultSeekBackwardInterval: function(media) {
			return (media.duration * 0.05);
		},
		// default amount to move forward when forward key is pressed
		defaultSeekForwardInterval: function(media) {
			return (media.duration * 0.05);
		},

		// set dimensions via JS instead of CSS
		setDimensions: true,

		// width of audio player
		audioWidth: -1,
		// height of audio player
		audioHeight: -1,
		// initial volume when the player starts (overrided by user cookie)
		startVolume: 0.8,
		// useful for <audio> player loops
		loop: false,
		// rewind to beginning when media ends
		autoRewind: true,
		// resize to media dimensions
		enableAutosize: true,

		/*
		 * Time format to use. Default: 'mm:ss'
		 * Supported units:
		 *   h: hour
		 *   m: minute
		 *   s: second
		 *   f: frame count
		 * When using 'hh', 'mm', 'ss' or 'ff' we always display 2 digits.
		 * If you use 'h', 'm', 's' or 'f' we display 1 digit if possible.
		 *
		 * Example to display 75 seconds:
		 * Format 'mm:ss': 01:15
		 * Format 'm:ss': 1:15
		 * Format 'm:s': 1:15
		 */
		timeFormat: '',
		// forces the hour marker (##:00:00)
		alwaysShowHours: false,
		// show framecount in timecode (##:00:00:00)
		showTimecodeFrameCount: false,
		// used when showTimecodeFrameCount is set to true
		framesPerSecond: 25,

		// automatically calculate the width of the progress bar based on the sizes of other elements
		autosizeProgress : true,
		// Hide controls when playing and mouse is not over the video
		alwaysShowControls: false,
		// Display the video control
		hideVideoControlsOnLoad: false,
		// Enable click video element to toggle play/pause
		clickToPlayPause: true,
		// force iPad's native controls
		iPadUseNativeControls: false,
		// force iPhone's native controls
		iPhoneUseNativeControls: false,
		// force Android's native controls
		AndroidUseNativeControls: false,
		// features to show
		features: ['playpause','current','progress','duration','tracks','volume','fullscreen'],
		// only for dynamic
		isVideo: true,

		// turns keyboard support on and off for this instance
		enableKeyboard: true,

		// whenthis player starts, it will pause other players
		pauseOtherPlayers: true,

		// array of keyboard actions such as play pause
		keyActions: [
			{
				keys: [
					32, // SPACE
					179 // GOOGLE play/pause button
				],
				action: function(player, media) {
					if (media.paused || media.ended) {
						media.play();
					} else {
						media.pause();
					}
				}
			},
			{
				keys: [38], // UP
				action: function(player, media) {
					player.container.find('.mejs-volume-slider').css('display','block');
					if (player.isVideo) {
						player.showControls();
						player.startControlsTimer();
					}

					var newVolume = Math.min(media.volume + 0.1, 1);
					media.setVolume(newVolume);
				}
			},
			{
				keys: [40], // DOWN
				action: function(player, media) {
					player.container.find('.mejs-volume-slider').css('display','block');
					if (player.isVideo) {
						player.showControls();
						player.startControlsTimer();
					}

					var newVolume = Math.max(media.volume - 0.1, 0);
					media.setVolume(newVolume);
				}
			},
			{
				keys: [
					37, // LEFT
					227 // Google TV rewind
				],
				action: function(player, media) {
					if (!isNaN(media.duration) && media.duration > 0) {
						if (player.isVideo) {
							player.showControls();
							player.startControlsTimer();
						}

						// 5%
						var newTime = Math.max(media.currentTime - player.options.defaultSeekBackwardInterval(media), 0);
						media.setCurrentTime(newTime);
					}
				}
			},
			{
				keys: [
					39, // RIGHT
					228 // Google TV forward
				],
				action: function(player, media) {
					if (!isNaN(media.duration) && media.duration > 0) {
						if (player.isVideo) {
							player.showControls();
							player.startControlsTimer();
						}

						// 5%
						var newTime = Math.min(media.currentTime + player.options.defaultSeekForwardInterval(media), media.duration);
						media.setCurrentTime(newTime);
					}
				}
			},
			{
				keys: [70], // F
				action: function(player, media) {
					if (typeof player.enterFullScreen != 'undefined') {
						if (player.isFullScreen) {
							player.exitFullScreen();
						} else {
							player.enterFullScreen();
						}
					}
				}
			},
			{
				keys: [77], // M
				action: function(player, media) {
					player.container.find('.mejs-volume-slider').css('display','block');
					if (player.isVideo) {
						player.showControls();
						player.startControlsTimer();
					}
					if (player.media.muted) {
						player.setMuted(false);
					} else {
						player.setMuted(true);
					}
				}
			}
		]
	};

	mejs.mepIndex = 0;

	mejs.players = {};

	// wraps a MediaElement object in player controls
	mejs.MediaElementPlayer = function(node, o) {
		// enforce object, even without "new" (via John Resig)
		if ( !(this instanceof mejs.MediaElementPlayer) ) {
			return new mejs.MediaElementPlayer(node, o);
		}

		var t = this;

		// these will be reset after the MediaElement.success fires
		t.$media = t.$node = $(node);
		t.node = t.media = t.$media[0];

		if(!t.node) {
			return
		}

		// check for existing player
		if (typeof t.node.player != 'undefined') {
			return t.node.player;
		}


		// try to get options from data-mejsoptions
		if (typeof o == 'undefined') {
			o = t.$node.data('mejsoptions');
		}

		// extend default options
		t.options = $.extend({},mejs.MepDefaults,o);

		if (!t.options.timeFormat) {
			// Generate the time format according to options
			t.options.timeFormat = 'mm:ss';
			if (t.options.alwaysShowHours) {
				t.options.timeFormat = 'hh:mm:ss';
			}
			if (t.options.showTimecodeFrameCount) {
				t.options.timeFormat += ':ff';
			}
		}

		mejs.Utility.calculateTimeFormat(0, t.options, t.options.framesPerSecond || 25);

		// unique ID
		t.id = 'mep_' + mejs.mepIndex++;

		// add to player array (for focus events)
		mejs.players[t.id] = t;

		// start up
		t.init();

		return t;
	};

	// actual player
	mejs.MediaElementPlayer.prototype = {

		hasFocus: false,

		controlsAreVisible: true,

		init: function() {

			var
				t = this,
				mf = mejs.MediaFeatures,
			// options for MediaElement (shim)
				meOptions = $.extend(true, {}, t.options, {
					success: function(media, domNode) { t.meReady(media, domNode); },
					error: function(e) { t.handleError(e);}
				}),
				tagName = t.media.tagName.toLowerCase();

			t.isDynamic = (tagName !== 'audio' && tagName !== 'video');

			if (t.isDynamic) {
				// get video from src or href?
				t.isVideo = t.options.isVideo;
			} else {
				t.isVideo = (tagName !== 'audio' && t.options.isVideo);
			}

			// use native controls in iPad, iPhone, and Android
			if ((mf.isiPad && t.options.iPadUseNativeControls) || (mf.isiPhone && t.options.iPhoneUseNativeControls)) {

				// add controls and stop
				t.$media.attr('controls', 'controls');

				// attempt to fix iOS 3 bug
				//t.$media.removeAttr('poster');
				// no Issue found on iOS3 -ttroxell

				// override Apple's autoplay override for iPads
				if (mf.isiPad && t.media.getAttribute('autoplay') !== null) {
					t.play();
				}

			} else if (mf.isAndroid && t.options.AndroidUseNativeControls) {

				// leave default player

			} else {

				// DESKTOP: use MediaElementPlayer controls

				// remove native controls
				t.$media.removeAttr('controls');
				var videoPlayerTitle = t.isVideo ?
					mejs.i18n.t('Video Player') : mejs.i18n.t('Audio Player');
				// insert description for screen readers
				$('<span class="mejs-offscreen">' + videoPlayerTitle + '</span>').insertBefore(t.$media);
				// build container
				t.container =
					$('<div id="' + t.id + '" class="mejs-container ' + (mejs.MediaFeatures.svgAsImg ? 'svg' : 'no-svg') +
						'" tabindex="0" role="application" aria-label="' + videoPlayerTitle + '">'+
						'<div class="mejs-inner">'+
						'<div class="mejs-mediaelement"></div>'+
						'<div class="mejs-layers"></div>'+
						'<div class="mejs-controls"></div>'+
						'<div class="mejs-clear"></div>'+
						'</div>' +
						'</div>')
						.addClass(t.$media[0].className)
						.insertBefore(t.$media)
						.focus(function ( e ) {
							if( !t.controlsAreVisible ) {
								t.showControls(true);
								var playButton = t.container.find('.mejs-playpause-button > button');
								playButton.focus();
							}
						});

				// add classes for user and content
				t.container.addClass(
					(mf.isAndroid ? 'mejs-android ' : '') +
					(mf.isiOS ? 'mejs-ios ' : '') +
					(mf.isiPad ? 'mejs-ipad ' : '') +
					(mf.isiPhone ? 'mejs-iphone ' : '') +
					(t.isVideo ? 'mejs-video ' : 'mejs-audio ')
				);


				// move the <video/video> tag into the right spot
				t.container.find('.mejs-mediaelement').append(t.$media);

				// needs to be assigned here, after iOS remap
				t.node.player = t;

				// find parts
				t.controls = t.container.find('.mejs-controls');
				t.layers = t.container.find('.mejs-layers');

				// determine the size

				/* size priority:
				 (1) videoWidth (forced),
				 (2) style="width;height;"
				 (3) width attribute,
				 (4) defaultVideoWidth (for unspecified cases)
				 */

				var tagType = (t.isVideo ? 'video' : 'audio'),
					capsTagName = tagType.substring(0,1).toUpperCase() + tagType.substring(1);



				if (t.options[tagType + 'Width'] > 0 || t.options[tagType + 'Width'].toString().indexOf('%') > -1) {
					t.width = t.options[tagType + 'Width'];
				} else if (t.media.style.width !== '' && t.media.style.width !== null) {
					t.width = t.media.style.width;
				} else if (t.media.getAttribute('width') !== null) {
					t.width = t.$media.attr('width');
				} else {
					t.width = t.options['default' + capsTagName + 'Width'];
				}

				if (t.options[tagType + 'Height'] > 0 || t.options[tagType + 'Height'].toString().indexOf('%') > -1) {
					t.height = t.options[tagType + 'Height'];
				} else if (t.media.style.height !== '' && t.media.style.height !== null) {
					t.height = t.media.style.height;
				} else if (t.$media[0].getAttribute('height') !== null) {
					t.height = t.$media.attr('height');
				} else {
					t.height = t.options['default' + capsTagName + 'Height'];
				}

				// set the size, while we wait for the plugins to load below
				t.setPlayerSize(t.width, t.height);

				// create MediaElementShim
				meOptions.pluginWidth = t.width;
				meOptions.pluginHeight = t.height;
			}

			// create MediaElement shim
			mejs.MediaElement(t.$media[0], meOptions);

			if (typeof(t.container) != 'undefined' && t.controlsAreVisible){
				// controls are shown when loaded
				t.container.trigger('controlsshown');
			}
		},

		showControls: function(doAnimation) {
			var t = this;

			doAnimation = typeof doAnimation == 'undefined' || doAnimation;

			if (t.controlsAreVisible)
				return;

			if (doAnimation) {
				t.controls
					.removeClass('mejs-offscreen')
					.stop(true, true).fadeIn(200, function() {
					t.controlsAreVisible = true;
					t.container.trigger('controlsshown');
				});

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control')
					.removeClass('mejs-offscreen')
					.stop(true, true).fadeIn(200, function() {t.controlsAreVisible = true;});

			} else {
				t.controls
					.removeClass('mejs-offscreen')
					.css('display','block');

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control')
					.removeClass('mejs-offscreen')
					.css('display','block');

				t.controlsAreVisible = true;
				t.container.trigger('controlsshown');
			}

			t.setControlsSize();

		},

		hideControls: function(doAnimation) {
			var t = this;

			doAnimation = typeof doAnimation == 'undefined' || doAnimation;

			if (!t.controlsAreVisible || t.options.alwaysShowControls || t.keyboardAction)
				return;

			if (doAnimation) {
				// fade out main controls
				t.controls.stop(true, true).fadeOut(200, function() {
					$(this)
						.addClass('mejs-offscreen')
						.css('display','block');

					t.controlsAreVisible = false;
					t.container.trigger('controlshidden');
				});

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control').stop(true, true).fadeOut(200, function() {
					$(this)
						.addClass('mejs-offscreen')
						.css('display','block');
				});
			} else {

				// hide main controls
				t.controls
					.addClass('mejs-offscreen')
					.css('display','block');

				// hide others
				t.container.find('.mejs-control')
					.addClass('mejs-offscreen')
					.css('display','block');

				t.controlsAreVisible = false;
				t.container.trigger('controlshidden');
			}
		},

		controlsTimer: null,

		startControlsTimer: function(timeout) {

			var t = this;

			timeout = typeof timeout != 'undefined' ? timeout : 1500;

			t.killControlsTimer('start');

			t.controlsTimer = setTimeout(function() {
				//
				t.hideControls();
				t.killControlsTimer('hide');
			}, timeout);
		},

		killControlsTimer: function(src) {

			var t = this;

			if (t.controlsTimer !== null) {
				clearTimeout(t.controlsTimer);
				delete t.controlsTimer;
				t.controlsTimer = null;
			}
		},

		controlsEnabled: true,

		disableControls: function() {
			var t= this;

			t.killControlsTimer();
			t.hideControls(false);
			this.controlsEnabled = false;
		},

		enableControls: function() {
			var t= this;

			t.showControls(false);

			t.controlsEnabled = true;
		},


		// Sets up all controls and events
		meReady: function(media, domNode) {


			var t = this,
				mf = mejs.MediaFeatures,
				autoplayAttr = domNode.getAttribute('autoplay'),
				autoplay = !(typeof autoplayAttr == 'undefined' || autoplayAttr === null || autoplayAttr === 'false'),
				featureIndex,
				feature;

			// make sure it can't create itself again if a plugin reloads
			if (t.created) {
				return;
			} else {
				t.created = true;
			}

			t.media = media;
			t.domNode = domNode;

			if (!(mf.isAndroid && t.options.AndroidUseNativeControls) && !(mf.isiPad && t.options.iPadUseNativeControls) && !(mf.isiPhone && t.options.iPhoneUseNativeControls)) {

				// two built in features
				t.buildposter(t, t.controls, t.layers, t.media);
				t.buildkeyboard(t, t.controls, t.layers, t.media);
				t.buildoverlays(t, t.controls, t.layers, t.media);

				// grab for use by features
				t.findTracks();

				// add user-defined features/controls
				for (featureIndex in t.options.features) {
					feature = t.options.features[featureIndex];
					if (t['build' + feature]) {
						try {
							t['build' + feature](t, t.controls, t.layers, t.media);
						} catch (e) {
							// TODO: report control error
							//throw e;


						}
					}
				}

				t.container.trigger('controlsready');

				// reset all layers and controls
				t.setPlayerSize(t.width, t.height);
				t.setControlsSize();


				// controls fade
				if (t.isVideo) {

					if (mejs.MediaFeatures.hasTouch) {

						// for touch devices (iOS, Android)
						// show/hide without animation on touch

						t.$media.bind('touchstart', function() {


							// toggle controls
							if (t.controlsAreVisible) {
								t.hideControls(false);
							} else {
								if (t.controlsEnabled) {
									t.showControls(false);
								}
							}
						});

					} else {

						// create callback here since it needs access to current
						// MediaElement object
						t.clickToPlayPauseCallback = function() {
							//

							if (t.options.clickToPlayPause) {
								if (t.media.paused) {
									t.play();
								} else {
									t.pause();
								}
							}
						};

						// click to play/pause
						t.media.addEventListener('click', t.clickToPlayPauseCallback, false);

						// show/hide controls
						t.container
							.bind('mouseenter', function () {
								if (t.controlsEnabled) {
									if (!t.options.alwaysShowControls ) {
										t.killControlsTimer('enter');
										t.showControls();
										t.startControlsTimer(2500);
									}
								}
							})
							.bind('mousemove', function() {
								if (t.controlsEnabled) {
									if (!t.controlsAreVisible) {
										t.showControls();
									}
									if (!t.options.alwaysShowControls) {
										t.startControlsTimer(2500);
									}
								}
							})
							.bind('mouseleave', function () {
								if (t.controlsEnabled) {
									if (!t.media.paused && !t.options.alwaysShowControls) {
										t.startControlsTimer(1000);
									}
								}
							});
					}

					if(t.options.hideVideoControlsOnLoad) {
						t.hideControls(false);
					}

					// check for autoplay
					if (autoplay && !t.options.alwaysShowControls) {
						t.hideControls();
					}

					// resizer
					if (t.options.enableAutosize) {
						t.media.addEventListener('loadedmetadata', function(e) {
							// if the <video height> was not set and the options.videoHeight was not set
							// then resize to the real dimensions
							if (t.options.videoHeight <= 0 && t.domNode.getAttribute('height') === null && !isNaN(e.target.videoHeight)) {
								t.setPlayerSize(e.target.videoWidth, e.target.videoHeight);
								t.setControlsSize();
								t.media.setVideoSize(e.target.videoWidth, e.target.videoHeight);
							}
						}, false);
					}
				}

				// EVENTS

				// FOCUS: when a video starts playing, it takes focus from other players (possibily pausing them)
				media.addEventListener('play', function() {
					var playerIndex;

					// go through all other players
					for (playerIndex in mejs.players) {
						var p = mejs.players[playerIndex];
						if (p.id != t.id && t.options.pauseOtherPlayers && !p.paused && !p.ended) {
							p.pause();
						}
						p.hasFocus = false;
					}

					t.hasFocus = true;
				},false);


				// ended for all
				t.media.addEventListener('ended', function (e) {
					if(t.options.autoRewind) {
						try{
							t.media.setCurrentTime(0);
							// Fixing an Android stock browser bug, where "seeked" isn't fired correctly after ending the video and jumping to the beginning
							window.setTimeout(function(){
								$(t.container).find('.mejs-overlay-loading').parent().hide();
							}, 20);
						} catch (exp) {

						}
					}
					t.media.pause();

					if (t.setProgressRail) {
						t.setProgressRail();
					}
					if (t.setCurrentRail) {
						t.setCurrentRail();
					}

					if (t.options.loop) {
						t.play();
					} else if (!t.options.alwaysShowControls && t.controlsEnabled) {
						t.showControls();
					}
				}, false);

				// resize on the first play
				t.media.addEventListener('loadedmetadata', function(e) {
					if (t.updateDuration) {
						t.updateDuration();
					}
					if (t.updateCurrent) {
						t.updateCurrent();
					}

					if (!t.isFullScreen) {
						t.setPlayerSize(t.width, t.height);
						t.setControlsSize();
					}
				}, false);

				// Only change the time format when necessary
				var duration = null;
				t.media.addEventListener('timeupdate',function() {
					if (duration !== this.duration) {
						duration = this.duration;
						mejs.Utility.calculateTimeFormat(duration, t.options, t.options.framesPerSecond || 25);
					}
				}, false);

				t.container.focusout(function (e) {
					if( e.relatedTarget ) { //FF is working on supporting focusout https://bugzilla.mozilla.org/show_bug.cgi?id=687787
						var $target = $(e.relatedTarget);
						if (t.keyboardAction && $target.parents('.mejs-container').length === 0) {
							t.keyboardAction = false;
							t.hideControls(true);
						}
					}
				});

				// webkit has trouble doing this without a delay
				setTimeout(function () {
					t.setPlayerSize(t.width, t.height);
					t.setControlsSize();
				}, 50);

				// adjust controls whenever window sizes (used to be in fullscreen only)
				t.globalBind('resize', function() {

					// don't resize for fullscreen mode
					if ( !(t.isFullScreen || (mejs.MediaFeatures.hasTrueNativeFullScreen && document.webkitIsFullScreen)) ) {
						t.setPlayerSize(t.width, t.height);
					}

					// always adjust controls
					t.setControlsSize();
				});

				// This is a work-around for a bug in the YouTube iFrame player, which means
				//  we can't use the play() API for the initial playback on iOS or Android;
				//  user has to start playback directly by tapping on the iFrame.
				if (t.media.pluginType == 'youtube' && ( mf.isiOS || mf.isAndroid ) ) {
					t.container.find('.mejs-overlay-play').hide();
				}
			}

			// force autoplay for HTML5
			if (autoplay && media.pluginType == 'native') {
				t.play();
			}


			if (t.options.success) {

				if (typeof t.options.success == 'string') {
					window[t.options.success](t.media, t.domNode, t);
				} else {
					t.options.success(t.media, t.domNode, t);
				}
			}
		},

		handleError: function(e) {
			var t = this;

			if (t.controls) {
				t.controls.hide();
			}

			// Tell user that the file cannot be played
			if (t.options.error) {
				t.options.error(e);
			}
		},

		setPlayerSize: function(width,height) {
			var t = this;

			if( !t.options.setDimensions ) {
				return false;
			}

			if (typeof width != 'undefined') {
				t.width = width;
			}

			if (typeof height != 'undefined') {
				t.height = height;
			}

			// detect 100% mode - use currentStyle for IE since css() doesn't return percentages
			if (t.height.toString().indexOf('%') > 0 || (t.$node.css('max-width') !== 'none' && t.$node.css('max-width') !== 't.width') || (t.$node[0].currentStyle && t.$node[0].currentStyle.maxWidth === '100%')) {

				// do we have the native dimensions yet?
				var nativeWidth = (function() {
					if (t.isVideo) {
						if (t.media.videoWidth && t.media.videoWidth > 0) {
							return t.media.videoWidth;
						} else if (t.media.getAttribute('width') !== null) {
							return t.media.getAttribute('width');
						} else {
							return t.options.defaultVideoWidth;
						}
					} else {
						return t.options.defaultAudioWidth;
					}
				})();

				var nativeHeight = (function() {
					if (t.isVideo) {
						if (t.media.videoHeight && t.media.videoHeight > 0) {
							return t.media.videoHeight;
						} else if (t.media.getAttribute('height') !== null) {
							return t.media.getAttribute('height');
						} else {
							return t.options.defaultVideoHeight;
						}
					} else {
						return t.options.defaultAudioHeight;
					}
				})();

				var
					parentWidth = t.container.parent().closest(':visible').width(),
					parentHeight = t.container.parent().closest(':visible').height(),
					newHeight = t.isVideo || !t.options.autosizeProgress ? parseInt(parentWidth * nativeHeight/nativeWidth, 10) : nativeHeight;

				// When we use percent, the newHeight can't be calculated so we get the container height
				if (isNaN(newHeight)) {
					newHeight = parentHeight;
				}

				if (t.container.parent().length > 0 && t.container.parent()[0].tagName.toLowerCase() === 'body') { // && t.container.siblings().count == 0) {
					parentWidth = $(window).width();
					newHeight = $(window).height();
				}

				if ( newHeight && parentWidth ) {

					// set outer container size
					t.container
						.width(parentWidth)
						.height(newHeight);

					// set native <video> or <audio> and shims
					t.$media.add(t.container.find('.mejs-shim'))
						.width('100%')
						.height('100%');

					// if shim is ready, send the size to the embeded plugin
					if (t.isVideo) {
						if (t.media.setVideoSize) {
							t.media.setVideoSize(parentWidth, newHeight);
						}
					}

					// set the layers
					t.layers.children('.mejs-layer')
						.width('100%')
						.height('100%');
				}


			} else {

				t.container
					.width(t.width)
					.height(t.height);

				t.layers.children('.mejs-layer')
					.width(t.width)
					.height(t.height);

			}

		},

		setControlsSize: function() {
			var t = this,
				usedWidth = 0,
				railWidth = 0,
				rail = t.controls.find('.mejs-time-rail'),
				total = t.controls.find('.mejs-time-total'),
				others = rail.siblings(),
				lastControl = others.last(),
				lastControlPosition = null;

			// skip calculation if hidden
			if (!t.container.is(':visible') || !rail.length || !rail.is(':visible')) {
				return;
			}


			// allow the size to come from custom CSS
			if (t.options && !t.options.autosizeProgress) {
				// Also, frontends devs can be more flexible
				// due the opportunity of absolute positioning.
				railWidth = parseInt(rail.css('width'), 10);
			}

			// attempt to autosize
			if (railWidth === 0 || !railWidth) {

				// find the size of all the other controls besides the rail
				others.each(function() {
					var $this = $(this);
					if ($this.css('position') != 'absolute' && $this.is(':visible')) {
						usedWidth += $(this).outerWidth(true);
					}
				});

				// fit the rail into the remaining space
				railWidth = t.controls.width() - usedWidth - (rail.outerWidth(true) - rail.width());
			}

			// resize the rail,
			// but then check if the last control (say, the fullscreen button) got pushed down
			// this often happens when zoomed
			do {
				// outer area
				rail.width(railWidth);
				// dark space
				total.width(railWidth - (total.outerWidth(true) - total.width()));

				if (lastControl.css('position') != 'absolute') {
					lastControlPosition = lastControl.length ? lastControl.position() : null;
					railWidth--;
				}
			} while (lastControlPosition !== null && lastControlPosition.top > 0 && railWidth > 0);

			t.container.trigger('controlsresize');
		},


		buildposter: function(player, controls, layers, media) {
			var t = this,
				poster =
					$('<div class="mejs-poster mejs-layer">' +
						'</div>')
						.appendTo(layers),
				posterUrl = player.$media.attr('poster');

			// prioriy goes to option (this is useful if you need to support iOS 3.x (iOS completely fails with poster)
			if (player.options.poster !== '') {
				posterUrl = player.options.poster;
			}

			// second, try the real poster
			if ( posterUrl ) {
				t.setPoster(posterUrl);
			} else {
				poster.hide();
			}

			media.addEventListener('play',function() {
				poster.hide();
			}, false);

			if(player.options.showPosterWhenEnded && player.options.autoRewind){
				media.addEventListener('ended',function() {
					poster.show();
				}, false);
			}
		},

		setPoster: function(url) {
			var t = this,
				posterDiv = t.container.find('.mejs-poster'),
				posterImg = posterDiv.find('img');

			if (posterImg.length === 0) {
				posterImg = $('<img width="100%" height="100%" alt="" />').appendTo(posterDiv);
			}

			posterImg.attr('src', url);
			posterDiv.css({'background-image' : 'url(' + url + ')'});
		},

		buildoverlays: function(player, controls, layers, media) {
			var t = this;
			if (!player.isVideo)
				return;

			var
				loading =
					$('<div class="mejs-overlay mejs-layer">'+
						'<div class="mejs-overlay-loading"><span></span></div>'+
						'</div>')
						.hide() // start out hidden
						.appendTo(layers),
				error =
					$('<div class="mejs-overlay mejs-layer">'+
						'<div class="mejs-overlay-error"></div>'+
						'</div>')
						.hide() // start out hidden
						.appendTo(layers),
			// this needs to come last so it's on top
				bigPlay =
					$('<div class="mejs-overlay mejs-layer mejs-overlay-play">'+
						'<div class="mejs-overlay-button"></div>'+
						'</div>')
						.appendTo(layers)
						.bind('click', function() {  // Removed 'touchstart' due issues on Samsung Android devices where a tap on bigPlay started and immediately stopped the video
							if (t.options.clickToPlayPause) {
								if (media.paused) {
									media.play();
								}
							}
						});

			/*
			 if (mejs.MediaFeatures.isiOS || mejs.MediaFeatures.isAndroid) {
			 bigPlay.remove();
			 loading.remove();
			 }
			 */


			// show/hide big play button
			media.addEventListener('play',function() {
				bigPlay.hide();
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				error.hide();
			}, false);

			media.addEventListener('playing', function() {
				bigPlay.hide();
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				error.hide();
			}, false);

			media.addEventListener('seeking', function() {
				loading.show();
				controls.find('.mejs-time-buffering').show();
			}, false);

			media.addEventListener('seeked', function() {
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
			}, false);

			media.addEventListener('pause',function() {
				if (!mejs.MediaFeatures.isiPhone) {
					bigPlay.show();
				}
			}, false);

			media.addEventListener('waiting', function() {
				loading.show();
				controls.find('.mejs-time-buffering').show();
			}, false);


			// show/hide loading
			media.addEventListener('loadeddata',function() {
				// for some reason Chrome is firing this event
				//if (mejs.MediaFeatures.isChrome && media.getAttribute && media.getAttribute('preload') === 'none')
				//	return;

				loading.show();
				controls.find('.mejs-time-buffering').show();
				// Firing the 'canplay' event after a timeout which isn't getting fired on some Android 4.1 devices (https://github.com/johndyer/mediaelement/issues/1305)
				if (mejs.MediaFeatures.isAndroid) {
					media.canplayTimeout = window.setTimeout(
						function() {
							if (document.createEvent) {
								var evt = document.createEvent('HTMLEvents');
								evt.initEvent('canplay', true, true);
								return media.dispatchEvent(evt);
							}
						}, 300
					);
				}
			}, false);
			media.addEventListener('canplay',function() {
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				clearTimeout(media.canplayTimeout); // Clear timeout inside 'loadeddata' to prevent 'canplay' to fire twice
			}, false);

			// error handling
			media.addEventListener('error',function(e) {
				t.handleError(e);
				loading.hide();
				bigPlay.hide();
				error.show();
				error.find('.mejs-overlay-error').html("Error loading this resource");
			}, false);

			media.addEventListener('keydown', function(e) {
				t.onkeydown(player, media, e);
			}, false);
		},

		buildkeyboard: function(player, controls, layers, media) {

			var t = this;

			t.container.keydown(function () {
				t.keyboardAction = true;
			});

			// listen for key presses
			t.globalBind('keydown', function(event) {
				player.hasFocus = $(event.target).closest('.mejs-container').length !== 0;
				return t.onkeydown(player, media, event);
			});


			// check if someone clicked outside a player region, then kill its focus
			t.globalBind('click', function(event) {
				player.hasFocus = $(event.target).closest('.mejs-container').length !== 0;
			});

		},
		onkeydown: function(player, media, e) {
			if (player.hasFocus && player.options.enableKeyboard) {
				// find a matching key
				for (var i = 0, il = player.options.keyActions.length; i < il; i++) {
					var keyAction = player.options.keyActions[i];

					for (var j = 0, jl = keyAction.keys.length; j < jl; j++) {
						if (e.keyCode == keyAction.keys[j]) {
							if (typeof(e.preventDefault) == "function") e.preventDefault();
							keyAction.action(player, media, e.keyCode);
							return false;
						}
					}
				}
			}

			return true;
		},

		findTracks: function() {
			var t = this,
				tracktags = t.$media.find('track');

			// store for use by plugins
			t.tracks = [];
			tracktags.each(function(index, track) {

				track = $(track);

				t.tracks.push({
					srclang: (track.attr('srclang')) ? track.attr('srclang').toLowerCase() : '',
					src: track.attr('src'),
					kind: track.attr('kind'),
					label: track.attr('label') || '',
					entries: [],
					isLoaded: false
				});
			});
		},
		changeSkin: function(className) {
			this.container[0].className = 'mejs-container ' + className;
			this.setPlayerSize(this.width, this.height);
			this.setControlsSize();
		},
		play: function() {
			this.load();
			this.media.play();
		},
		pause: function() {
			try {
				this.media.pause();
			} catch (e) {}
		},
		load: function() {
			if (!this.isLoaded) {
				this.media.load();
			}

			this.isLoaded = true;
		},
		setMuted: function(muted) {
			this.media.setMuted(muted);
		},
		setCurrentTime: function(time) {
			this.media.setCurrentTime(time);
		},
		getCurrentTime: function() {
			return this.media.currentTime;
		},
		setVolume: function(volume) {
			this.media.setVolume(volume);
		},
		getVolume: function() {
			return this.media.volume;
		},
		setSrc: function(src) {
			this.media.setSrc(src);
		},
		remove: function() {
			var t = this, featureIndex, feature;

			t.container.prev('.mejs-offscreen').remove();

			// invoke features cleanup
			for (featureIndex in t.options.features) {
				feature = t.options.features[featureIndex];
				if (t['clean' + feature]) {
					try {
						t['clean' + feature](t);
					} catch (e) {
						// TODO: report control error
						//throw e;
						//
						//
					}
				}
			}

			// grab video and put it back in place
			if (!t.isDynamic) {
				t.$media.prop('controls', true);
				// detach events from the video
				// TODO: detach event listeners better than this;
				//       also detach ONLY the events attached by this plugin!
				t.$node.clone().insertBefore(t.container).show();
				t.$node.remove();
			} else {
				t.$node.insertBefore(t.container);
			}

			if (t.media.pluginType !== 'native') {
				t.media.remove();
			}

			// Remove the player from the mejs.players object so that pauseOtherPlayers doesn't blow up when trying to pause a non existance flash api.
			delete mejs.players[t.id];

			if (typeof t.container == 'object') {
				t.container.remove();
			}
			t.globalUnbind();
			delete t.node.player;
		},
		rebuildtracks: function(){
			var t = this;
			t.findTracks();
			t.buildtracks(t, t.controls, t.layers, t.media);
		},
		resetSize: function(){
			var t = this;
			// webkit has trouble doing this without a delay
			setTimeout(function () {
				//
				t.setPlayerSize(t.width, t.height);
				t.setControlsSize();
			}, 50);
		}
	};

	(function(){
		var rwindow = /^((after|before)print|(before)?unload|hashchange|message|o(ff|n)line|page(hide|show)|popstate|resize|storage)\b/;

		function splitEvents(events, id) {
			// add player ID as an event namespace so it's easier to unbind them all later
			var ret = {d: [], w: []};
			$.each((events || '').split(' '), function(k, v){
				var eventname = v + '.' + id;
				if (eventname.indexOf('.') === 0) {
					ret.d.push(eventname);
					ret.w.push(eventname);
				}
				else {
					ret[rwindow.test(v) ? 'w' : 'd'].push(eventname);
				}
			});
			ret.d = ret.d.join(' ');
			ret.w = ret.w.join(' ');
			return ret;
		}

		mejs.MediaElementPlayer.prototype.globalBind = function(events, data, callback) {
			var t = this;
			var doc = t.node ? t.node.ownerDocument : document;

			events = splitEvents(events, t.id);
			if (events.d) $(doc).bind(events.d, data, callback);
			if (events.w) $(window).bind(events.w, data, callback);
		};

		mejs.MediaElementPlayer.prototype.globalUnbind = function(events, callback) {
			var t = this;
			var doc = t.node ? t.node.ownerDocument : document;

			events = splitEvents(events, t.id);
			if (events.d) $(doc).unbind(events.d, callback);
			if (events.w) $(window).unbind(events.w, callback);
		};
	})();

	// turn into jQuery plugin
	if (typeof $ != 'undefined') {
		$.fn.mediaelementplayer = function (options) {
			if (options === false) {
				this.each(function () {
					var player = $(this).data('mediaelementplayer');
					if (player) {
						player.remove();
					}
					$(this).removeData('mediaelementplayer');
				});
			}
			else {
				this.each(function () {
					$(this).data('mediaelementplayer', new mejs.MediaElementPlayer(this, options));
				});
			}
			return this;
		};


		$(document).ready(function() {
			// auto enable using JSON attribute
			$('.mejs-player').mediaelementplayer();
		});
	}

	// push out to window
	window.MediaElementPlayer = mejs.MediaElementPlayer;

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		playText: mejs.i18n.t('Play'),
		pauseText: mejs.i18n.t('Pause')
	});

	// PLAY/pause BUTTON
	$.extend(MediaElementPlayer.prototype, {
		buildplaypause: function(player, controls, layers, media) {
			var
				t = this,
				op = t.options,
				play =
					$('<div class="mejs-button mejs-playpause-button mejs-play" >' +
						'<button type="button" aria-controls="' + t.id + '" title="' + op.playText + '" aria-label="' + op.playText + '"></button>' +
						'</div>')
						.appendTo(controls)
						.click(function(e) {
							e.preventDefault();

							if (media.paused) {
								media.play();
							} else {
								media.pause();
							}

							return false;
						}),
				play_btn = play.find('button');


			function togglePlayPause(which) {
				if ('play' === which) {
					play.removeClass('mejs-play').addClass('mejs-pause');
					play_btn.attr({
						'title': op.pauseText,
						'aria-label': op.pauseText
					});
				} else {
					play.removeClass('mejs-pause').addClass('mejs-play');
					play_btn.attr({
						'title': op.playText,
						'aria-label': op.playText
					});
				}
			};
			togglePlayPause('pse');


			media.addEventListener('play',function() {
				togglePlayPause('play');
			}, false);
			media.addEventListener('playing',function() {
				togglePlayPause('play');
			}, false);


			media.addEventListener('pause',function() {
				togglePlayPause('pse');
			}, false);
			media.addEventListener('paused',function() {
				togglePlayPause('pse');
			}, false);
		}
	});

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		stopText: 'Stop'
	});

	// STOP BUTTON
	$.extend(MediaElementPlayer.prototype, {
		buildstop: function(player, controls, layers, media) {
			var t = this;

			$('<div class="mejs-button mejs-stop-button mejs-stop">' +
				'<button type="button" aria-controls="' + t.id + '" title="' + t.options.stopText + '" aria-label="' + t.options.stopText + '"></button>' +
				'</div>')
				.appendTo(controls)
				.click(function() {
					if (!media.paused) {
						media.pause();
					}
					if (media.currentTime > 0) {
						media.setCurrentTime(0);
						media.pause();
						controls.find('.mejs-time-current').width('0px');
						controls.find('.mejs-time-handle').css('left', '0px');
						controls.find('.mejs-time-float-current').html( mejs.Utility.secondsToTimeCode(0, player.options));
						controls.find('.mejs-currenttime').html( mejs.Utility.secondsToTimeCode(0, player.options));
						layers.find('.mejs-poster').show();
					}
				});
		}
	});

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		progessHelpText: mejs.i18n.t(
			'Use Left/Right Arrow keys to advance one second, Up/Down arrows to advance ten seconds.')
	});

	// progress/loaded bar
	$.extend(MediaElementPlayer.prototype, {
		buildprogress: function(player, controls, layers, media) {

			$('<div class="mejs-time-rail">' +
				'<span  class="mejs-time-total mejs-time-slider">' +
					//'<span class="mejs-offscreen">' + this.options.progessHelpText + '</span>' +
				'<span class="mejs-time-buffering"></span>' +
				'<span class="mejs-time-loaded"></span>' +
				'<span class="mejs-time-current"></span>' +
				'<span class="mejs-time-handle"></span>' +
				'<span class="mejs-time-float">' +
				'<span class="mejs-time-float-current">00:00</span>' +
				'<span class="mejs-time-float-corner"></span>' +
				'</span>' +
				'</span>' +
				'</div>')
				.appendTo(controls);
			controls.find('.mejs-time-buffering').hide();

			var
				t = this,
				total = controls.find('.mejs-time-total'),
				loaded  = controls.find('.mejs-time-loaded'),
				current  = controls.find('.mejs-time-current'),
				handle  = controls.find('.mejs-time-handle'),
				timefloat  = controls.find('.mejs-time-float'),
				timefloatcurrent  = controls.find('.mejs-time-float-current'),
				slider = controls.find('.mejs-time-slider'),
				handleMouseMove = function (e) {

					var offset = total.offset(),
						width = total.width(),
						percentage = 0,
						newTime = 0,
						pos = 0,
						x;

					// mouse or touch position relative to the object
					if (e.originalEvent && e.originalEvent.changedTouches) {
						x = e.originalEvent.changedTouches[0].pageX;
					} else if (e.changedTouches) { // for Zepto
						x = e.changedTouches[0].pageX;
					} else {
						x = e.pageX;
					}

					if (media.duration) {
						if (x < offset.left) {
							x = offset.left;
						} else if (x > width + offset.left) {
							x = width + offset.left;
						}

						pos = x - offset.left;
						percentage = (pos / width);
						newTime = (percentage <= 0.02) ? 0 : percentage * media.duration;

						// seek to where the mouse is
						if (mouseIsDown && newTime !== media.currentTime) {
							media.setCurrentTime(newTime);
						}

						// position floating time box
						if (!mejs.MediaFeatures.hasTouch) {
							timefloat.css('left', pos);
							timefloatcurrent.html( mejs.Utility.secondsToTimeCode(newTime, player.options) );
							timefloat.show();
						}
					}
				},
				mouseIsDown = false,
				mouseIsOver = false,
				lastKeyPressTime = 0,
				startedPaused = false,
				autoRewindInitial = player.options.autoRewind;
			// Accessibility for slider
			var updateSlider = function (e) {

				var seconds = media.currentTime,
					timeSliderText = mejs.i18n.t('Time Slider'),
					time = mejs.Utility.secondsToTimeCode(seconds, player.options),
					duration = media.duration;

				slider.attr({
					'aria-label': timeSliderText,
					'aria-valuemin': 0,
					'aria-valuemax': duration,
					'aria-valuenow': seconds,
					'aria-valuetext': time,
					'role': 'slider',
					'tabindex': 0
				});

			};

			var restartPlayer = function () {
				var now = new Date();
				if (now - lastKeyPressTime >= 1000) {
					media.play();
				}
			};

			slider.bind('focus', function (e) {
				player.options.autoRewind = false;
			});

			slider.bind('blur', function (e) {
				player.options.autoRewind = autoRewindInitial;
			});

			slider.bind('keydown', function (e) {

				if ((new Date() - lastKeyPressTime) >= 1000) {
					startedPaused = media.paused;
				}

				var keyCode = e.keyCode,
					duration = media.duration,
					seekTime = media.currentTime;

				switch (keyCode) {
					case 37: // left
						seekTime -= 1;
						break;
					case 39: // Right
						seekTime += 1;
						break;
					case 38: // Up
						seekTime += Math.floor(duration * 0.1);
						break;
					case 40: // Down
						seekTime -= Math.floor(duration * 0.1);
						break;
					case 36: // Home
						seekTime = 0;
						break;
					case 35: // end
						seekTime = duration;
						break;
					case 10: // enter
						media.paused ? media.play() : media.pause();
						return;
					case 13: // space
						media.paused ? media.play() : media.pause();
						return;
					default:
						return;
				}

				seekTime = seekTime < 0 ? 0 : (seekTime >= duration ? duration : Math.floor(seekTime));
				lastKeyPressTime = new Date();
				if (!startedPaused) {
					media.pause();
				}

				if (seekTime < media.duration && !startedPaused) {
					setTimeout(restartPlayer, 1100);
				}

				media.setCurrentTime(seekTime);

				e.preventDefault();
				e.stopPropagation();
				return false;
			});


			// handle clicks
			//controls.find('.mejs-time-rail').delegate('span', 'click', handleMouseMove);
			total
				.bind('mousedown touchstart', function (e) {
					// only handle left clicks or touch
					if (e.which === 1 || e.which === 0) {
						mouseIsDown = true;
						handleMouseMove(e);
						t.globalBind('mousemove.dur touchmove.dur', function(e) {
							handleMouseMove(e);
						});
						t.globalBind('mouseup.dur touchend.dur', function (e) {
							mouseIsDown = false;
							timefloat.hide();
							t.globalUnbind('.dur');
						});
					}
				})
				.bind('mouseenter', function(e) {
					mouseIsOver = true;
					t.globalBind('mousemove.dur', function(e) {
						handleMouseMove(e);
					});
					if (!mejs.MediaFeatures.hasTouch) {
						timefloat.show();
					}
				})
				.bind('mouseleave',function(e) {
					mouseIsOver = false;
					if (!mouseIsDown) {
						t.globalUnbind('.dur');
						timefloat.hide();
					}
				});

			// loading
			media.addEventListener('progress', function (e) {
				player.setProgressRail(e);
				player.setCurrentRail(e);
			}, false);

			// current time
			media.addEventListener('timeupdate', function(e) {
				player.setProgressRail(e);
				player.setCurrentRail(e);
				updateSlider(e);
			}, false);

			t.container.on('controlsresize', function() {
				player.setProgressRail();
				player.setCurrentRail();
			});

			// store for later use
			t.loaded = loaded;
			t.total = total;
			t.current = current;
			t.handle = handle;
		},
		setProgressRail: function(e) {

			var
				t = this,
				target = (e !== undefined) ? e.target : t.media,
				percent = null;

			// newest HTML5 spec has buffered array (FF4, Webkit)
			if (target && target.buffered && target.buffered.length > 0 && target.buffered.end && target.duration) {
				// account for a real array with multiple values - always read the end of the last buffer
				percent = target.buffered.end(target.buffered.length - 1) / target.duration;
			}
			// Some browsers (e.g., FF3.6 and Safari 5) cannot calculate target.bufferered.end()
			// to be anything other than 0. If the byte count is available we use this instead.
			// Browsers that support the else if do not seem to have the bufferedBytes value and
			// should skip to there. Tested in Safari 5, Webkit head, FF3.6, Chrome 6, IE 7/8.
			else if (target && target.bytesTotal !== undefined && target.bytesTotal > 0 && target.bufferedBytes !== undefined) {
				percent = target.bufferedBytes / target.bytesTotal;
			}
			// Firefox 3 with an Ogg file seems to go this way
			else if (e && e.lengthComputable && e.total !== 0) {
				percent = e.loaded / e.total;
			}

			// finally update the progress bar
			if (percent !== null) {
				percent = Math.min(1, Math.max(0, percent));
				// update loaded bar
				if (t.loaded && t.total) {
					t.loaded.width(t.total.width() * percent);
				}
			}
		},
		setCurrentRail: function() {

			var t = this;

			if (t.media.currentTime !== undefined && t.media.duration) {

				// update bar and handle
				if (t.total && t.handle) {
					var
						newWidth = Math.round(t.total.width() * t.media.currentTime / t.media.duration),
						handlePos = newWidth - Math.round(t.handle.outerWidth(true) / 2);

					t.current.width(newWidth);
					t.handle.css('left', handlePos);
				}
			}

		}
	});
})(mejs.$);

(function($) {

	// options
	$.extend(mejs.MepDefaults, {
		duration: -1,
		timeAndDurationSeparator: '<span> | </span>'
	});


	// current and duration 00:00 / 00:00
	$.extend(MediaElementPlayer.prototype, {
		buildcurrent: function(player, controls, layers, media) {
			var t = this;

			$('<div class="mejs-time" role="timer" aria-live="off">' +
				'<span class="mejs-currenttime">' +
				mejs.Utility.secondsToTimeCode(0, player.options) +
				'</span>'+
				'</div>')
				.appendTo(controls);

			t.currenttime = t.controls.find('.mejs-currenttime');

			media.addEventListener('timeupdate',function() {
				player.updateCurrent();
			}, false);
		},


		buildduration: function(player, controls, layers, media) {
			var t = this;

			if (controls.children().last().find('.mejs-currenttime').length > 0) {
				$(t.options.timeAndDurationSeparator +
					'<span class="mejs-duration">' +
					mejs.Utility.secondsToTimeCode(t.options.duration, t.options) +
					'</span>')
					.appendTo(controls.find('.mejs-time'));
			} else {

				// add class to current time
				controls.find('.mejs-currenttime').parent().addClass('mejs-currenttime-container');

				$('<div class="mejs-time mejs-duration-container">'+
					'<span class="mejs-duration">' +
					mejs.Utility.secondsToTimeCode(t.options.duration, t.options) +
					'</span>' +
					'</div>')
					.appendTo(controls);
			}

			t.durationD = t.controls.find('.mejs-duration');

			media.addEventListener('timeupdate',function() {
				player.updateDuration();
			}, false);
		},

		updateCurrent:  function() {
			var t = this;

			var currentTime = t.media.currentTime;

			if (isNaN(currentTime)) {
				currentTime = 0;
			}

			if (t.currenttime) {
				t.currenttime.html(mejs.Utility.secondsToTimeCode(currentTime, t.options));
			}
		},

		updateDuration: function() {
			var t = this;

			var duration = t.media.duration;
			if (t.options.duration > 0) {
				duration = t.options.duration;
			}

			if (isNaN(duration)) {
				duration = 0;
			}

			//Toggle the long video class if the video is longer than an hour.
			t.container.toggleClass("mejs-long-video", duration > 3600);

			if (t.durationD && duration > 0) {
				t.durationD.html(mejs.Utility.secondsToTimeCode(duration, t.options));
			}
		}
	});

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		muteText: mejs.i18n.t('Mute Toggle'),
		allyVolumeControlText: mejs.i18n.t('Use Up/Down Arrow keys to increase or decrease volume.'),
		hideVolumeOnTouchDevices: true,

		audioVolume: 'horizontal',
		videoVolume: 'vertical'
	});

	$.extend(MediaElementPlayer.prototype, {
		buildvolume: function(player, controls, layers, media) {

			// Android and iOS don't support volume controls
			if ((mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS) && this.options.hideVolumeOnTouchDevices)
				return;

			var t = this,
				mode = (t.isVideo) ? t.options.videoVolume : t.options.audioVolume,
				mute = (mode == 'horizontal') ?

					// horizontal version
					$('<div class="mejs-button mejs-volume-button mejs-mute">' +
						'<button type="button" aria-controls="' + t.id +
						'" title="' + t.options.muteText +
						'" aria-label="' + t.options.muteText +
						'"></button>'+
						'</div>' +
						'<a href="javascript:void(0);" class="mejs-horizontal-volume-slider">' + // outer background
						'<span class="mejs-offscreen">' + t.options.allyVolumeControlText + '</span>' +
						'<div class="mejs-horizontal-volume-total"></div>'+ // line background
						'<div class="mejs-horizontal-volume-current"></div>'+ // current volume
						'<div class="mejs-horizontal-volume-handle"></div>'+ // handle
						'</a>'
					)
						.appendTo(controls) :

					// vertical version
					$('<div class="mejs-button mejs-volume-button mejs-mute">'+
						'<button type="button" aria-controls="' + t.id +
						'" title="' + t.options.muteText +
						'" aria-label="' + t.options.muteText +
						'"></button>'+
						'<a href="javascript:void(0);" class="mejs-volume-slider">'+ // outer background
						'<span class="mejs-offscreen">' + t.options.allyVolumeControlText + '</span>' +
						'<div class="mejs-volume-total"></div>'+ // line background
						'<div class="mejs-volume-current"></div>'+ // current volume
						'<div class="mejs-volume-handle"></div>'+ // handle
						'</a>'+
						'</div>')
						.appendTo(controls),
				volumeSlider = t.container.find('.mejs-volume-slider, .mejs-horizontal-volume-slider'),
				volumeTotal = t.container.find('.mejs-volume-total, .mejs-horizontal-volume-total'),
				volumeCurrent = t.container.find('.mejs-volume-current, .mejs-horizontal-volume-current'),
				volumeHandle = t.container.find('.mejs-volume-handle, .mejs-horizontal-volume-handle'),

				positionVolumeHandle = function(volume, secondTry) {

					if (!volumeSlider.is(':visible') && typeof secondTry == 'undefined') {
						volumeSlider.show();
						positionVolumeHandle(volume, true);
						volumeSlider.hide();
						return;
					}

					// correct to 0-1
					volume = Math.max(0,volume);
					volume = Math.min(volume,1);

					// ajust mute button style
					if (volume === 0) {
						mute.removeClass('mejs-mute').addClass('mejs-unmute');
						mute.children('button').attr('title', mejs.i18n.t('Unmute')).attr('aria-label', mejs.i18n.t('Unmute'));
					} else {
						mute.removeClass('mejs-unmute').addClass('mejs-mute');
						mute.children('button').attr('title', mejs.i18n.t('Mute')).attr('aria-label', mejs.i18n.t('Mute'));
					}

					// top/left of full size volume slider background
					var totalPosition = volumeTotal.position();
					// position slider
					if (mode == 'vertical') {
						var
						// height of the full size volume slider background
							totalHeight = volumeTotal.height(),

						// the new top position based on the current volume
						// 70% volume on 100px height == top:30px
							newTop = totalHeight - (totalHeight * volume);

						// handle
						volumeHandle.css('top', Math.round(totalPosition.top + newTop - (volumeHandle.height() / 2)));

						// show the current visibility
						volumeCurrent.height(totalHeight - newTop );
						volumeCurrent.css('top', totalPosition.top + newTop);
					} else {
						var
						// height of the full size volume slider background
							totalWidth = volumeTotal.width(),

						// the new left position based on the current volume
							newLeft = totalWidth * volume;

						// handle
						volumeHandle.css('left', Math.round(totalPosition.left + newLeft - (volumeHandle.width() / 2)));

						// rezize the current part of the volume bar
						volumeCurrent.width( Math.round(newLeft) );
					}
				},
				handleVolumeMove = function(e) {

					var volume = null,
						totalOffset = volumeTotal.offset();

					// calculate the new volume based on the moust position
					if (mode === 'vertical') {

						var
							railHeight = volumeTotal.height(),
							newY = e.pageY - totalOffset.top;

						volume = (railHeight - newY) / railHeight;

						// the controls just hide themselves (usually when mouse moves too far up)
						if (totalOffset.top === 0 || totalOffset.left === 0) {
							return;
						}

					} else {
						var
							railWidth = volumeTotal.width(),
							newX = e.pageX - totalOffset.left;

						volume = newX / railWidth;
					}

					// ensure the volume isn't outside 0-1
					volume = Math.max(0,volume);
					volume = Math.min(volume,1);

					// position the slider and handle
					positionVolumeHandle(volume);

					// set the media object (this will trigger the volumechanged event)
					if (volume === 0) {
						media.setMuted(true);
					} else {
						media.setMuted(false);
					}
					media.setVolume(volume);
				},
				mouseIsDown = false,
				mouseIsOver = false;

			// SLIDER

			mute
				.hover(function() {
					volumeSlider.show();
					mouseIsOver = true;
				}, function() {
					mouseIsOver = false;

					if (!mouseIsDown && mode == 'vertical')	{
						volumeSlider.hide();
					}
				});

			var updateVolumeSlider = function (e) {

				var volume = Math.floor(media.volume*100);

				volumeSlider.attr({
					'aria-label': mejs.i18n.t('volumeSlider'),
					'aria-valuemin': 0,
					'aria-valuemax': 100,
					'aria-valuenow': volume,
					'aria-valuetext': volume+'%',
					'role': 'slider',
					'tabindex': 0
				});

			};

			volumeSlider
				.bind('mouseover', function() {
					mouseIsOver = true;
				})
				.bind('mousedown', function (e) {
					handleVolumeMove(e);
					t.globalBind('mousemove.vol', function(e) {
						handleVolumeMove(e);
					});
					t.globalBind('mouseup.vol', function () {
						mouseIsDown = false;
						t.globalUnbind('.vol');

						if (!mouseIsOver && mode == 'vertical') {
							volumeSlider.hide();
						}
					});
					mouseIsDown = true;

					return false;
				})
				.bind('keydown', function (e) {
					var keyCode = e.keyCode;
					var volume = media.volume;
					switch (keyCode) {
						case 38: // Up
							volume += 0.1;
							break;
						case 40: // Down
							volume = volume - 0.1;
							break;
						default:
							return true;
					}

					mouseIsDown = false;
					positionVolumeHandle(volume);
					media.setVolume(volume);
					return false;
				});

			// MUTE button
			mute.find('button').click(function() {
				media.setMuted( !media.muted );
			});

			//Keyboard input
			mute.find('button').bind('focus', function () {
				volumeSlider.show();
			});

			// listen for volume change events from other sources
			media.addEventListener('volumechange', function(e) {
				if (!mouseIsDown) {
					if (media.muted) {
						positionVolumeHandle(0);
						mute.removeClass('mejs-mute').addClass('mejs-unmute');
					} else {
						positionVolumeHandle(media.volume);
						mute.removeClass('mejs-unmute').addClass('mejs-mute');
					}
				}
				updateVolumeSlider(e);
			}, false);

			// mutes the media and sets the volume icon muted if the initial volume is set to 0
			if (player.options.startVolume === 0) {
				media.setMuted(true);
			}

			// shim gets the startvolume as a parameter, but we have to set it on the native <video> and <audio> elements
			if (media.pluginType === 'native') {
				media.setVolume(player.options.startVolume);
			}

			t.container.on('controlsresize', function() {
				positionVolumeHandle(media.volume);
			});
		}
	});

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		usePluginFullScreen: true,
		newWindowCallback: function() { return '';},
		fullscreenText: mejs.i18n.t('Fullscreen')
	});

	$.extend(MediaElementPlayer.prototype, {

		isFullScreen: false,

		isNativeFullScreen: false,

		isInIframe: false,

		// Possible modes
		// (1) 'native-native' 	HTML5 video  + browser fullscreen (IE10+, etc.)
		// (2) 'plugin-native' 	plugin video + browser fullscreen (fails in some versions of Firefox)
		// (3) 'fullwindow' 	Full window (retains all UI)
		// usePluginFullScreen = true
		// (4) 'plugin-click' 	Flash 1 - click through with pointer events
		// (5) 'plugin-hover' 	Flash 2 - hover popup in flash (IE6-8)
		fullscreenMode: '',

		buildfullscreen: function(player, controls, layers, media) {

			if (!player.isVideo)
				return;

			player.isInIframe = (window.location != window.parent.location);

			// detect on start
			media.addEventListener('play', function() { player.detectFullscreenMode(); });

			// build button
			var t = this,
				hideTimeout = null,
				fullscreenBtn =
					$('<div class="mejs-button mejs-fullscreen-button">' +
						'<button type="button" aria-controls="' + t.id + '" title="' + t.options.fullscreenText + '" aria-label="' + t.options.fullscreenText + '"></button>' +
						'</div>')
						.appendTo(controls)
						.on('click', function() {

							// toggle fullscreen
							var isFullScreen = (mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || player.isFullScreen;

							if (isFullScreen) {
								player.exitFullScreen();
							} else {
								player.enterFullScreen();
							}
						})
						.on('mouseover', function() {

							// very old browsers with a plugin
							if (t.fullscreenMode == 'plugin-hover') {
								if (hideTimeout !== null) {
									clearTimeout(hideTimeout);
									delete hideTimeout;
								}

								var buttonPos = fullscreenBtn.offset(),
									containerPos = player.container.offset();

								media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, true);
							}

						})
						.on('mouseout', function() {

							if (t.fullscreenMode == 'plugin-hover') {
								if (hideTimeout !== null) {
									clearTimeout(hideTimeout);
									delete hideTimeout;
								}

								hideTimeout = setTimeout(function() {
									media.hideFullscreenButton();
								}, 1500);
							}

						});



			player.fullscreenBtn = fullscreenBtn;

			t.globalBind('keydown',function (e) {
				if (e.keyCode == 27 && ((mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || t.isFullScreen)) {
					player.exitFullScreen();
				}
			});

			t.normalHeight = 0;
			t.normalWidth = 0;

			// setup native fullscreen event
			if (mejs.MediaFeatures.hasTrueNativeFullScreen) {

				// chrome doesn't alays fire this in an iframe
				var fullscreenChanged = function(e) {
					if (player.isFullScreen) {
						if (mejs.MediaFeatures.isFullScreen()) {
							player.isNativeFullScreen = true;
							// reset the controls once we are fully in full screen
							player.setControlsSize();
						} else {
							player.isNativeFullScreen = false;
							// when a user presses ESC
							// make sure to put the player back into place
							player.exitFullScreen();
						}
					}
				};

				player.globalBind(mejs.MediaFeatures.fullScreenEventName, fullscreenChanged);
			}

		},

		detectFullscreenMode: function() {

			var t = this,
				mode = '',
				features = mejs.MediaFeatures;

			if (features.hasTrueNativeFullScreen && t.media.pluginType === 'native') {
				mode = 'native-native';
			} else if (features.hasTrueNativeFullScreen && t.media.pluginType !== 'native' && !features.hasFirefoxPluginMovingProblem) {
				mode = 'plugin-native';
			} else if (t.usePluginFullScreen) {
				if (mejs.MediaFeatures.supportsPointerEvents) {
					mode = 'plugin-click';
					// this needs some special setup
					t.createPluginClickThrough();
				} else {
					mode = 'plugin-hover';
				}

			} else {
				mode = 'fullwindow';
			}


			t.fullscreenMode = mode;
			return mode;
		},

		isPluginClickThroughCreated: false,

		createPluginClickThrough: function() {

			var t = this;

			// don't build twice
			if (t.isPluginClickThroughCreated) {
				return;
			}

			// allows clicking through the fullscreen button and controls down directly to Flash

			/*
			 When a user puts his mouse over the fullscreen button, we disable the controls so that mouse events can go down to flash (pointer-events)
			 We then put a divs over the video and on either side of the fullscreen button
			 to capture mouse movement and restore the controls once the mouse moves outside of the fullscreen button
			 */

			var fullscreenIsDisabled = false,
				restoreControls = function() {
					if (fullscreenIsDisabled) {
						// hide the hovers
						for (var i in hoverDivs) {
							hoverDivs[i].hide();
						}

						// restore the control bar
						t.fullscreenBtn.css('pointer-events', '');
						t.controls.css('pointer-events', '');

						// prevent clicks from pausing video
						t.media.removeEventListener('click', t.clickToPlayPauseCallback);

						// store for later
						fullscreenIsDisabled = false;
					}
				},
				hoverDivs = {},
				hoverDivNames = ['top', 'left', 'right', 'bottom'],
				i, len,
				positionHoverDivs = function() {
					var fullScreenBtnOffsetLeft = fullscreenBtn.offset().left - t.container.offset().left,
						fullScreenBtnOffsetTop = fullscreenBtn.offset().top - t.container.offset().top,
						fullScreenBtnWidth = fullscreenBtn.outerWidth(true),
						fullScreenBtnHeight = fullscreenBtn.outerHeight(true),
						containerWidth = t.container.width(),
						containerHeight = t.container.height();

					for (i in hoverDivs) {
						hoverDivs[i].css({position: 'absolute', top: 0, left: 0}); //, backgroundColor: '#f00'});
					}

					// over video, but not controls
					hoverDivs['top']
						.width( containerWidth )
						.height( fullScreenBtnOffsetTop );

					// over controls, but not the fullscreen button
					hoverDivs['left']
						.width( fullScreenBtnOffsetLeft )
						.height( fullScreenBtnHeight )
						.css({top: fullScreenBtnOffsetTop});

					// after the fullscreen button
					hoverDivs['right']
						.width( containerWidth - fullScreenBtnOffsetLeft - fullScreenBtnWidth )
						.height( fullScreenBtnHeight )
						.css({top: fullScreenBtnOffsetTop,
							left: fullScreenBtnOffsetLeft + fullScreenBtnWidth});

					// under the fullscreen button
					hoverDivs['bottom']
						.width( containerWidth )
						.height( containerHeight - fullScreenBtnHeight - fullScreenBtnOffsetTop )
						.css({top: fullScreenBtnOffsetTop + fullScreenBtnHeight});
				};

			t.globalBind('resize', function() {
				positionHoverDivs();
			});

			for (i = 0, len = hoverDivNames.length; i < len; i++) {
				hoverDivs[hoverDivNames[i]] = $('<div class="mejs-fullscreen-hover" />').appendTo(t.container).mouseover(restoreControls).hide();
			}

			// on hover, kill the fullscreen button's HTML handling, allowing clicks down to Flash
			fullscreenBtn.on('mouseover',function() {

				if (!t.isFullScreen) {

					var buttonPos = fullscreenBtn.offset(),
						containerPos = player.container.offset();

					// move the button in Flash into place
					media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, false);

					// allows click through
					t.fullscreenBtn.css('pointer-events', 'none');
					t.controls.css('pointer-events', 'none');

					// restore click-to-play
					t.media.addEventListener('click', t.clickToPlayPauseCallback);

					// show the divs that will restore things
					for (i in hoverDivs) {
						hoverDivs[i].show();
					}

					positionHoverDivs();

					fullscreenIsDisabled = true;
				}

			});

			// restore controls anytime the user enters or leaves fullscreen
			media.addEventListener('fullscreenchange', function(e) {
				t.isFullScreen = !t.isFullScreen;
				// don't allow plugin click to pause video - messes with
				// plugin's controls
				if (t.isFullScreen) {
					t.media.removeEventListener('click', t.clickToPlayPauseCallback);
				} else {
					t.media.addEventListener('click', t.clickToPlayPauseCallback);
				}
				restoreControls();
			});


			// the mouseout event doesn't work on the fullscren button, because we already killed the pointer-events
			// so we use the document.mousemove event to restore controls when the mouse moves outside the fullscreen button

			t.globalBind('mousemove', function(e) {

				// if the mouse is anywhere but the fullsceen button, then restore it all
				if (fullscreenIsDisabled) {

					var fullscreenBtnPos = fullscreenBtn.offset();


					if (e.pageY < fullscreenBtnPos.top || e.pageY > fullscreenBtnPos.top + fullscreenBtn.outerHeight(true) ||
						e.pageX < fullscreenBtnPos.left || e.pageX > fullscreenBtnPos.left + fullscreenBtn.outerWidth(true)
					) {

						fullscreenBtn.css('pointer-events', '');
						t.controls.css('pointer-events', '');

						fullscreenIsDisabled = false;
					}
				}
			});


			t.isPluginClickThroughCreated = true;
		},

		cleanfullscreen: function(player) {
			player.exitFullScreen();
		},

		containerSizeTimeout: null,

		enterFullScreen: function() {

			var t = this;

			if (mejs.MediaFeatures.hasiOSFullScreen && typeof t.media.webkitEnterFullScreen !== "undefined") {
				t.media.webkitEnterFullscreen();
				return;
			}

			// set it to not show scroll bars so 100% will work
			$(document.documentElement).addClass('mejs-fullscreen');

			// store sizing
			t.normalHeight = t.container.height();
			t.normalWidth = t.container.width();



			// attempt to do true fullscreen
			if (t.fullscreenMode === 'native-native' || t.fullscreenMode === 'plugin-native') {

				mejs.MediaFeatures.requestFullScreen(t.container[0]);
				//return;

				if (t.isInIframe) {
					// sometimes exiting from fullscreen doesn't work
					// notably in Chrome <iframe>. Fixed in version 17
					setTimeout(function checkFullscreen() {

						if (t.isNativeFullScreen) {
							var zoomMultiplier = window["devicePixelRatio"] || 1,
							// Use a percent error margin since devicePixelRatio is a float and not exact.
								percentErrorMargin = 0.002, // 0.2%
								windowWidth = zoomMultiplier * $(window).width(),
								screenWidth = screen.width,
							// ** 13twelve
							// Screen width is sort of useless: http://www.quirksmode.org/blog/archives/2013/11/screenwidth_is.html
							// My rMBP ignores devicePixelRatio when returning the values, so fullscreen would always fail the "suddenly not fullscreen" test
							// Theory: the gap between reported values should give us an indication of browser behavior with screen.width and devicePixelRatio
								zoomedWindowWidth = zoomMultiplier * windowWidth;

							if (Math.abs(screenWidth-windowWidth) > Math.abs(screenWidth-zoomedWindowWidth)) {
								// screen.width is likely true pixels, not CSS pixels, so we need to use the zoomed window width for comparison
								windowWidth = zoomedWindowWidth;
							}
							// ** / 13twelve

							var absDiff = Math.abs(screenWidth - windowWidth),
								marginError = screenWidth * percentErrorMargin;

							// check if the video is suddenly not really fullscreen
							if (absDiff > marginError) {
								// manually exit
								t.exitFullScreen();
							} else {
								// test again
								setTimeout(checkFullscreen, 500);
							}
						}

					}, 1000);
				}

			} else if (t.fullscreeMode == 'fullwindow') {
				// move into position

			}

			// make full size
			t.container
				.addClass('mejs-container-fullscreen')
				.width('100%')
				.height('100%');
			//.css({position: 'fixed', left: 0, top: 0, right: 0, bottom: 0, overflow: 'hidden', width: '100%', height: '100%', 'z-index': 1000});

			// Only needed for safari 5.1 native full screen, can cause display issues elsewhere
			// Actually, it seems to be needed for IE8, too
			//if (mejs.MediaFeatures.hasTrueNativeFullScreen) {
			t.containerSizeTimeout = setTimeout(function() {
				t.container.css({width: '100%', height: '100%'});
				t.setControlsSize();
			}, 500);
			//}

			if (t.media.pluginType === 'native') {
				t.$media
					.width('100%')
					.height('100%');
			} else {
				t.container.find('.mejs-shim')
					.width('100%')
					.height('100%');

				setTimeout(function() {
					var win = $(window),
						winW = win.width(),
						winH = win.height();

					t.media.setVideoSize(winW,winH);
				}, 500);
			}

			t.layers.children('div')
				.width('100%')
				.height('100%');

			if (t.fullscreenBtn) {
				t.fullscreenBtn
					.removeClass('mejs-fullscreen')
					.addClass('mejs-unfullscreen');
			}

			t.setControlsSize();
			t.isFullScreen = true;

			t.container.find('.mejs-captions-text').css('font-size', screen.width / t.width * 1.00 * 100 + '%');
			t.container.find('.mejs-captions-position').css('bottom', '45px');

			t.container.trigger('enteredfullscreen');
		},

		exitFullScreen: function() {

			var t = this;

			// Prevent container from attempting to stretch a second time
			clearTimeout(t.containerSizeTimeout);

			// firefox can't adjust plugins
			/*
			 if (t.media.pluginType !== 'native' && mejs.MediaFeatures.isFirefox) {
			 t.media.setFullscreen(false);
			 //player.isFullScreen = false;
			 return;
			 }
			 */

			// come out of native fullscreen
			if (mejs.MediaFeatures.hasTrueNativeFullScreen && (mejs.MediaFeatures.isFullScreen() || t.isFullScreen)) {
				mejs.MediaFeatures.cancelFullScreen();
			}

			// restore scroll bars to document
			$(document.documentElement).removeClass('mejs-fullscreen');

			t.container
				.removeClass('mejs-container-fullscreen')
				.width(t.normalWidth)
				.height(t.normalHeight);

			if (t.media.pluginType === 'native') {
				t.$media
					.width(t.normalWidth)
					.height(t.normalHeight);
			} else {
				t.container.find('.mejs-shim')
					.width(t.normalWidth)
					.height(t.normalHeight);

				t.media.setVideoSize(t.normalWidth, t.normalHeight);
			}

			t.layers.children('div')
				.width(t.normalWidth)
				.height(t.normalHeight);

			t.fullscreenBtn
				.removeClass('mejs-unfullscreen')
				.addClass('mejs-fullscreen');

			t.setControlsSize();
			t.isFullScreen = false;

			t.container.find('.mejs-captions-text').css('font-size','');
			t.container.find('.mejs-captions-position').css('bottom', '');

			t.container.trigger('exitedfullscreen');
		}
	});

})(mejs.$);

(function($) {

	// Speed
	$.extend(mejs.MepDefaults, {

		// We also support to pass object like this:
		// [{name: 'Slow', value: '0.75'}, {name: 'Normal', value: '1.00'}, ...]
		speeds: ['2.00', '1.50', '1.25', '1.00', '0.75'],

		defaultSpeed: '1.00',

		speedChar: 'x'

	});

	$.extend(MediaElementPlayer.prototype, {

		buildspeed: function(player, controls, layers, media) {
			var t = this;

			if (t.media.pluginType == 'native') {
				var
					speedButton = null,
					speedSelector = null,
					playbackSpeed = null,
					inputId = null;

				var speeds = [];
				var defaultInArray = false;
				for (var i=0, len=t.options.speeds.length; i < len; i++) {
					var s = t.options.speeds[i];
					if (typeof(s) === 'string'){
						speeds.push({
							name: s + t.options.speedChar,
							value: s
						});
						if(s === t.options.defaultSpeed) {
							defaultInArray = true;
						}
					}
					else {
						speeds.push(s);
						if(s.value === t.options.defaultSpeed) {
							defaultInArray = true;
						}
					}
				}

				if (!defaultInArray) {
					speeds.push({
						name: t.options.defaultSpeed + t.options.speedChar,
						value: t.options.defaultSpeed
					});
				}

				speeds.sort(function(a, b) {
					return parseFloat(b.value) - parseFloat(a.value);
				});

				var getSpeedNameFromValue = function(value) {
					for(i=0,len=speeds.length; i <len; i++) {
						if (speeds[i].value === value) {
							return speeds[i].name;
						}
					}
				};

				var html = '<div class="mejs-button mejs-speed-button">' +
					'<button type="button">' + getSpeedNameFromValue(t.options.defaultSpeed) + '</button>' +
					'<div class="mejs-speed-selector">' +
					'<ul>';

				for (i = 0, il = speeds.length; i<il; i++) {
					inputId = t.id + '-speed-' + speeds[i].value;
					html += '<li>' +
						'<input type="radio" name="speed" ' +
						'value="' + speeds[i].value + '" ' +
						'id="' + inputId + '" ' +
						(speeds[i].value === t.options.defaultSpeed ? ' checked' : '') +
						' />' +
						'<label for="' + inputId + '" ' +
						(speeds[i].value === t.options.defaultSpeed ? ' class="mejs-speed-selected"' : '') +
						'>' + speeds[i].name + '</label>' +
						'</li>';
				}
				html += '</ul></div></div>';

				speedButton = $(html).appendTo(controls);
				speedSelector = speedButton.find('.mejs-speed-selector');

				playbackSpeed = t.options.defaultSpeed;

				media.addEventListener('loadedmetadata', function(e) {
					if (playbackSpeed) {
						media.playbackRate = parseFloat(playbackSpeed);
					}
				}, true);

				speedSelector
					.on('click', 'input[type="radio"]', function() {
						var newSpeed = $(this).attr('value');
						playbackSpeed = newSpeed;
						media.playbackRate = parseFloat(newSpeed);
						speedButton.find('button').html(getSpeedNameFromValue(newSpeed));
						speedButton.find('.mejs-speed-selected').removeClass('mejs-speed-selected');
						speedButton.find('input[type="radio"]:checked').next().addClass('mejs-speed-selected');
					});
				speedButton
					.one( 'mouseenter focusin', function() {
						speedSelector
							.height(
								speedButton.find('.mejs-speed-selector ul').outerHeight(true) +
								speedButton.find('.mejs-speed-translations').outerHeight(true))
							.css('top', (-1 * speedSelector.height()) + 'px');
					});
			}
		}
	});

})(mejs.$);

(function($) {

	// add extra default options
	$.extend(mejs.MepDefaults, {
		// this will automatically turn on a <track>
		startLanguage: '',

		tracksText: mejs.i18n.t('Captions/Subtitles'),

		// By default, no WAI-ARIA live region - don't make a
		// screen reader speak captions over an audio track.
		tracksAriaLive: false,

		// option to remove the [cc] button when no <track kind="subtitles"> are present
		hideCaptionsButtonWhenEmpty: true,

		// If true and we only have one track, change captions to popup
		toggleCaptionsButtonWhenOnlyOne: false,

		// #id or .class
		slidesSelector: ''
	});

	$.extend(MediaElementPlayer.prototype, {

		hasChapters: false,

		cleartracks: function(player, controls, layers, media){
			if(player) {
				if(player.captions) player.captions.remove();
				if(player.chapters) player.chapters.remove();
				if(player.captionsText) player.captionsText.remove();
				if(player.captionsButton) player.captionsButton.remove();
			}
		},
		buildtracks: function(player, controls, layers, media) {
			if (player.tracks.length === 0)
				return;

			var t = this,
				attr = t.options.tracksAriaLive ?
					'role="log" aria-live="assertive" aria-atomic="false"' : '',
				i;

			if (t.domNode.textTracks) { // if browser will do native captions, prefer mejs captions, loop through tracks and hide
				for (i = t.domNode.textTracks.length - 1; i >= 0; i--) {
					t.domNode.textTracks[i].mode = "hidden";
				}
			}
			t.cleartracks(player, controls, layers, media);
			player.chapters =
				$('<div class="mejs-chapters mejs-layer"></div>')
					.prependTo(layers).hide();
			player.captions =
				$('<div class="mejs-captions-layer mejs-layer"><div class="mejs-captions-position mejs-captions-position-hover" ' +
					attr + '><span class="mejs-captions-text"></span></div></div>')
					.prependTo(layers).hide();
			player.captionsText = player.captions.find('.mejs-captions-text');
			player.captionsButton =
				$('<div class="mejs-button mejs-captions-button">'+
					'<button type="button" aria-controls="' + t.id + '" title="' + t.options.tracksText + '" aria-label="' + t.options.tracksText + '"></button>'+
					'<div class="mejs-captions-selector">'+
					'<ul>'+
					'<li>'+
					'<input type="radio" name="' + player.id + '_captions" id="' + player.id + '_captions_none" value="none" checked="checked" />' +
					'<label for="' + player.id + '_captions_none">' + mejs.i18n.t('None') +'</label>'+
					'</li>'	+
					'</ul>'+
					'</div>'+
					'</div>')
					.appendTo(controls);


			var subtitleCount = 0;
			for (i=0; i<player.tracks.length; i++) {
				if (player.tracks[i].kind == 'subtitles') {
					subtitleCount++;
				}
			}

			// if only one language then just make the button a toggle
			if (t.options.toggleCaptionsButtonWhenOnlyOne && subtitleCount == 1){
				// click
				player.captionsButton.on('click',function() {
					if (player.selectedTrack === null) {
						lang = player.tracks[0].srclang;
					} else {
						lang = 'none';
					}
					player.setTrack(lang);
				});
			} else {
				// hover or keyboard focus
				player.captionsButton.on( 'mouseenter focusin', function() {
						$(this).find('.mejs-captions-selector').removeClass('mejs-offscreen');
					})

					// handle clicks to the language radio buttons
					.on('click','input[type=radio]',function() {
						lang = this.value;
						player.setTrack(lang);
					});

				player.captionsButton.on( 'mouseleave focusout', function() {
					$(this).find(".mejs-captions-selector").addClass("mejs-offscreen");
				});

			}

			if (!player.options.alwaysShowControls) {
				// move with controls
				player.container
					.bind('controlsshown', function () {
						// push captions above controls
						player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');

					})
					.bind('controlshidden', function () {
						if (!media.paused) {
							// move back to normal place
							player.container.find('.mejs-captions-position').removeClass('mejs-captions-position-hover');
						}
					});
			} else {
				player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');
			}

			player.trackToLoad = -1;
			player.selectedTrack = null;
			player.isLoadingTrack = false;

			// add to list
			for (i=0; i<player.tracks.length; i++) {
				if (player.tracks[i].kind == 'subtitles') {
					player.addTrackButton(player.tracks[i].srclang, player.tracks[i].label);
				}
			}

			// start loading tracks
			player.loadNextTrack();

			media.addEventListener('timeupdate',function(e) {
				player.displayCaptions();
			}, false);

			if (player.options.slidesSelector !== '') {
				player.slidesContainer = $(player.options.slidesSelector);

				media.addEventListener('timeupdate',function(e) {
					player.displaySlides();
				}, false);

			}

			media.addEventListener('loadedmetadata', function(e) {
				player.displayChapters();
			}, false);

			player.container.hover(
				function () {
					// chapters
					if (player.hasChapters) {
						player.chapters.removeClass('mejs-offscreen');
						player.chapters.fadeIn(200).height(player.chapters.find('.mejs-chapter').outerHeight());
					}
				},
				function () {
					if (player.hasChapters && !media.paused) {
						player.chapters.fadeOut(200, function() {
							$(this).addClass('mejs-offscreen');
							$(this).css('display','block');
						});
					}
				});

			t.container.on('controlsresize', function() {
				t.adjustLanguageBox();
			});

			// check for autoplay
			if (player.node.getAttribute('autoplay') !== null) {
				player.chapters.addClass('mejs-offscreen');
			}
		},

		setTrack: function(lang){

			var t = this,
				i;

			if (lang == 'none') {
				t.selectedTrack = null;
				t.captionsButton.removeClass('mejs-captions-enabled');
			} else {
				for (i=0; i<t.tracks.length; i++) {
					if (t.tracks[i].srclang == lang) {
						if (t.selectedTrack === null)
							t.captionsButton.addClass('mejs-captions-enabled');
						t.selectedTrack = t.tracks[i];
						t.captions.attr('lang', t.selectedTrack.srclang);
						t.displayCaptions();
						break;
					}
				}
			}
		},

		loadNextTrack: function() {
			var t = this;

			t.trackToLoad++;
			if (t.trackToLoad < t.tracks.length) {
				t.isLoadingTrack = true;
				t.loadTrack(t.trackToLoad);
			} else {
				// add done?
				t.isLoadingTrack = false;

				t.checkForTracks();
			}
		},

		loadTrack: function(index){
			var
				t = this,
				track = t.tracks[index],
				after = function() {

					track.isLoaded = true;

					t.enableTrackButton(track.srclang, track.label);

					t.loadNextTrack();

				};


			$.ajax({
				url: track.src,
				dataType: "text",
				success: function(d) {

					// parse the loaded file
					if (typeof d == "string" && (/<tt\s+xml/ig).exec(d)) {
						track.entries = mejs.TrackFormatParser.dfxp.parse(d);
					} else {
						track.entries = mejs.TrackFormatParser.webvtt.parse(d);
					}

					after();

					if (track.kind == 'chapters') {
						t.media.addEventListener('play', function(e) {
							if (t.media.duration > 0) {
								t.displayChapters(track);
							}
						}, false);
					}

					if (track.kind == 'slides') {
						t.setupSlides(track);
					}
				},
				error: function() {
					t.removeTrackButton(track.srclang);
					t.loadNextTrack();
				}
			});
		},

		enableTrackButton: function(lang, label) {
			var t = this;

			if (label === '') {
				label = mejs.language.codes[lang] || lang;
			}

			t.captionsButton
				.find('input[value=' + lang + ']')
				.prop('disabled',false)
				.siblings('label')
				.html( label );

			// auto select
			if (t.options.startLanguage == lang) {
				$('#' + t.id + '_captions_' + lang).prop('checked', true).trigger('click');
			}

			t.adjustLanguageBox();
		},

		removeTrackButton: function(lang) {
			var t = this;

			t.captionsButton.find('input[value=' + lang + ']').closest('li').remove();

			t.adjustLanguageBox();
		},

		addTrackButton: function(lang, label) {
			var t = this;
			if (label === '') {
				label = mejs.language.codes[lang] || lang;
			}

			t.captionsButton.find('ul').append(
				$('<li>'+
					'<input type="radio" name="' + t.id + '_captions" id="' + t.id + '_captions_' + lang + '" value="' + lang + '" disabled="disabled" />' +
					'<label for="' + t.id + '_captions_' + lang + '">' + label + ' (loading)' + '</label>'+
					'</li>')
			);

			t.adjustLanguageBox();

			// remove this from the dropdownlist (if it exists)
			t.container.find('.mejs-captions-translations option[value=' + lang + ']').remove();
		},

		adjustLanguageBox:function() {
			var t = this;
			// adjust the size of the outer box
			t.captionsButton.find('.mejs-captions-selector').height(
				t.captionsButton.find('.mejs-captions-selector ul').outerHeight(true) +
				t.captionsButton.find('.mejs-captions-translations').outerHeight(true)
			);
		},

		checkForTracks: function() {
			var
				t = this,
				hasSubtitles = false;

			// check if any subtitles
			if (t.options.hideCaptionsButtonWhenEmpty) {
				for (i=0; i<t.tracks.length; i++) {
					if (t.tracks[i].kind == 'subtitles' && t.tracks[i].isLoaded) {
						hasSubtitles = true;
						break;
					}
				}

				if (!hasSubtitles) {
					t.captionsButton.hide();
					t.setControlsSize();
				}
			}
		},

		displayCaptions: function() {

			if (typeof this.tracks == 'undefined')
				return;

			var
				t = this,
				i,
				track = t.selectedTrack;

			if (track !== null && track.isLoaded) {
				for (i=0; i<track.entries.times.length; i++) {
					if (t.media.currentTime >= track.entries.times[i].start && t.media.currentTime <= track.entries.times[i].stop) {
						// Set the line before the timecode as a class so the cue can be targeted if needed
						t.captionsText.html(track.entries.text[i]).attr('class', 'mejs-captions-text ' + (track.entries.times[i].identifier || ''));
						t.captions.show().height(0);
						return; // exit out if one is visible;
					}
				}
				t.captions.hide();
			} else {
				t.captions.hide();
			}
		},

		setupSlides: function(track) {
			var t = this;

			t.slides = track;
			t.slides.entries.imgs = [t.slides.entries.text.length];
			t.showSlide(0);

		},

		showSlide: function(index) {
			if (typeof this.tracks == 'undefined' || typeof this.slidesContainer == 'undefined') {
				return;
			}

			var t = this,
				url = t.slides.entries.text[index],
				img = t.slides.entries.imgs[index];

			if (typeof img == 'undefined' || typeof img.fadeIn == 'undefined') {

				t.slides.entries.imgs[index] = img = $('<img src="' + url + '">')
					.on('load', function() {
						img.appendTo(t.slidesContainer)
							.hide()
							.fadeIn()
							.siblings(':visible')
							.fadeOut();

					});

			} else {

				if (!img.is(':visible') && !img.is(':animated')) {

					//

					img.fadeIn()
						.siblings(':visible')
						.fadeOut();
				}
			}

		},

		displaySlides: function() {

			if (typeof this.slides == 'undefined')
				return;

			var
				t = this,
				slides = t.slides,
				i;

			for (i=0; i<slides.entries.times.length; i++) {
				if (t.media.currentTime >= slides.entries.times[i].start && t.media.currentTime <= slides.entries.times[i].stop){

					t.showSlide(i);

					return; // exit out if one is visible;
				}
			}
		},

		displayChapters: function() {
			var
				t = this,
				i;

			for (i=0; i<t.tracks.length; i++) {
				if (t.tracks[i].kind == 'chapters' && t.tracks[i].isLoaded) {
					t.drawChapters(t.tracks[i]);
					t.hasChapters = true;
					break;
				}
			}
		},

		drawChapters: function(chapters) {
			var
				t = this,
				i,
				dur,
			//width,
			//left,
				percent = 0,
				usedPercent = 0;

			t.chapters.empty();

			for (i=0; i<chapters.entries.times.length; i++) {
				dur = chapters.entries.times[i].stop - chapters.entries.times[i].start;
				percent = Math.floor(dur / t.media.duration * 100);
				if (percent + usedPercent > 100 || // too large
					i == chapters.entries.times.length-1 && percent + usedPercent < 100) // not going to fill it in
				{
					percent = 100 - usedPercent;
				}
				//width = Math.floor(t.width * dur / t.media.duration);
				//left = Math.floor(t.width * chapters.entries.times[i].start / t.media.duration);
				//if (left + width > t.width) {
				//	width = t.width - left;
				//}

				t.chapters.append( $(
					'<div class="mejs-chapter" rel="' + chapters.entries.times[i].start + '" style="left: ' + usedPercent.toString() + '%;width: ' + percent.toString() + '%;">' +
					'<div class="mejs-chapter-block' + ((i==chapters.entries.times.length-1) ? ' mejs-chapter-block-last' : '') + '">' +
					'<span class="ch-title">' + chapters.entries.text[i] + '</span>' +
					'<span class="ch-time">' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].start, t.options) + '&ndash;' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].stop, t.options) + '</span>' +
					'</div>' +
					'</div>'));
				usedPercent += percent;
			}

			t.chapters.find('div.mejs-chapter').click(function() {
				t.media.setCurrentTime( parseFloat( $(this).attr('rel') ) );
				if (t.media.paused) {
					t.media.play();
				}
			});

			t.chapters.show();
		}
	});



	mejs.language = {
		codes:  {
			af:'Afrikaans',
			sq:'Albanian',
			ar:'Arabic',
			be:'Belarusian',
			bg:'Bulgarian',
			ca:'Catalan',
			zh:'Chinese',
			'zh-cn':'Chinese Simplified',
			'zh-tw':'Chinese Traditional',
			hr:'Croatian',
			cs:'Czech',
			da:'Danish',
			nl:'Dutch',
			en:'English',
			et:'Estonian',
			fl:'Filipino',
			fi:'Finnish',
			fr:'French',
			gl:'Galician',
			de:'German',
			el:'Greek',
			ht:'Haitian Creole',
			iw:'Hebrew',
			hi:'Hindi',
			hu:'Hungarian',
			is:'Icelandic',
			id:'Indonesian',
			ga:'Irish',
			it:'Italian',
			ja:'Japanese',
			ko:'Korean',
			lv:'Latvian',
			lt:'Lithuanian',
			mk:'Macedonian',
			ms:'Malay',
			mt:'Maltese',
			no:'Norwegian',
			fa:'Persian',
			pl:'Polish',
			pt:'Portuguese',
			// 'pt-pt':'Portuguese (Portugal)',
			ro:'Romanian',
			ru:'Russian',
			sr:'Serbian',
			sk:'Slovak',
			sl:'Slovenian',
			es:'Spanish',
			sw:'Swahili',
			sv:'Swedish',
			tl:'Tagalog',
			th:'Thai',
			tr:'Turkish',
			uk:'Ukrainian',
			vi:'Vietnamese',
			cy:'Welsh',
			yi:'Yiddish'
		}
	};

	/*
	 Parses WebVTT format which should be formatted as
	 ================================
	 WEBVTT

	 1
	 00:00:01,1 --> 00:00:05,000
	 A line of text

	 2
	 00:01:15,1 --> 00:02:05,000
	 A second line of text

	 ===============================

	 Adapted from: http://www.delphiki.com/html5/playr
	 */
	mejs.TrackFormatParser = {
		webvtt: {
			pattern_timecode: /^((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{1,3})?) --\> ((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{3})?)(.*)$/,

			parse: function(trackText) {
				var
					i = 0,
					lines = mejs.TrackFormatParser.split2(trackText, /\r?\n/),
					entries = {text:[], times:[]},
					timecode,
					text,
					identifier;
				for(; i<lines.length; i++) {
					timecode = this.pattern_timecode.exec(lines[i]);

					if (timecode && i<lines.length) {
						if ((i - 1) >= 0 && lines[i - 1] !== '') {
							identifier = lines[i - 1];
						}
						i++;
						// grab all the (possibly multi-line) text that follows
						text = lines[i];
						i++;
						while(lines[i] !== '' && i<lines.length){
							text = text + '\n' + lines[i];
							i++;
						}
						text = $.trim(text).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
						// Text is in a different array so I can use .join
						entries.text.push(text);
						entries.times.push(
							{
								identifier: identifier,
								start: (mejs.Utility.convertSMPTEtoSeconds(timecode[1]) === 0) ? 0.200 : mejs.Utility.convertSMPTEtoSeconds(timecode[1]),
								stop: mejs.Utility.convertSMPTEtoSeconds(timecode[3]),
								settings: timecode[5]
							});
					}
					identifier = '';
				}
				return entries;
			}
		},
		// Thanks to Justin Capella: https://github.com/johndyer/mediaelement/pull/420
		dfxp: {
			parse: function(trackText) {
				trackText = $(trackText).filter("tt");
				var
					i = 0,
					container = trackText.children("div").eq(0),
					lines = container.find("p"),
					styleNode = trackText.find("#" + container.attr("style")),
					styles,
					text,
					entries = {text:[], times:[]};


				if (styleNode.length) {
					var attributes = styleNode.removeAttr("id").get(0).attributes;
					if (attributes.length) {
						styles = {};
						for (i = 0; i < attributes.length; i++) {
							styles[attributes[i].name.split(":")[1]] = attributes[i].value;
						}
					}
				}

				for(i = 0; i<lines.length; i++) {
					var style;
					var _temp_times = {
						start: null,
						stop: null,
						style: null
					};
					if (lines.eq(i).attr("begin")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("begin"));
					if (!_temp_times.start && lines.eq(i-1).attr("end")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i-1).attr("end"));
					if (lines.eq(i).attr("end")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("end"));
					if (!_temp_times.stop && lines.eq(i+1).attr("begin")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i+1).attr("begin"));
					if (styles) {
						style = "";
						for (var _style in styles) {
							style += _style + ":" + styles[_style] + ";";
						}
					}
					if (style) _temp_times.style = style;
					if (_temp_times.start === 0) _temp_times.start = 0.200;
					entries.times.push(_temp_times);
					text = $.trim(lines.eq(i).html()).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
					entries.text.push(text);
					if (entries.times.start === 0) entries.times.start = 2;
				}
				return entries;
			}
		},
		split2: function (text, regex) {
			// normal version for compliant browsers
			// see below for IE fix
			return text.split(regex);
		}
	};

	// test for browsers with bad String.split method.
	if ('x\n\ny'.split(/\n/gi).length != 3) {
		// add super slow IE8 and below version
		mejs.TrackFormatParser.split2 = function(text, regex) {
			var
				parts = [],
				chunk = '',
				i;

			for (i=0; i<text.length; i++) {
				chunk += text.substring(i,i+1);
				if (regex.test(chunk)) {
					parts.push(chunk.replace(regex, ''));
					chunk = '';
				}
			}
			parts.push(chunk);
			return parts;
		};
	}

})(mejs.$);

/*
 * ContextMenu Plugin
 *
 *
 */

(function($) {

	$.extend(mejs.MepDefaults,
		{ 'contextMenuItems': [
			// demo of a fullscreen option
			{
				render: function(player) {

					// check for fullscreen plugin
					if (typeof player.enterFullScreen == 'undefined')
						return null;

					if (player.isFullScreen) {
						return mejs.i18n.t('Turn off Fullscreen');
					} else {
						return mejs.i18n.t('Go Fullscreen');
					}
				},
				click: function(player) {
					if (player.isFullScreen) {
						player.exitFullScreen();
					} else {
						player.enterFullScreen();
					}
				}
			}
			,
			// demo of a mute/unmute button
			{
				render: function(player) {
					if (player.media.muted) {
						return mejs.i18n.t('Unmute');
					} else {
						return mejs.i18n.t('Mute');
					}
				},
				click: function(player) {
					if (player.media.muted) {
						player.setMuted(false);
					} else {
						player.setMuted(true);
					}
				}
			},
			// separator
			{
				isSeparator: true
			}
			,
			// demo of simple download video
			{
				render: function(player) {
					return mejs.i18n.t('Download Video');
				},
				click: function(player) {
					window.location.href = player.media.currentSrc;
				}
			}
		]}
	);


	$.extend(MediaElementPlayer.prototype, {
		buildcontextmenu: function(player, controls, layers, media) {

			// create context menu
			player.contextMenu = $('<div class="mejs-contextmenu"></div>')
				.appendTo($('body'))
				.hide();

			// create events for showing context menu
			player.container.bind('contextmenu', function(e) {
				if (player.isContextMenuEnabled) {
					e.preventDefault();
					player.renderContextMenu(e.clientX-1, e.clientY-1);
					return false;
				}
			});
			player.container.bind('click', function() {
				player.contextMenu.hide();
			});
			player.contextMenu.bind('mouseleave', function() {

				//
				player.startContextMenuTimer();

			});
		},

		cleancontextmenu: function(player) {
			player.contextMenu.remove();
		},

		isContextMenuEnabled: true,
		enableContextMenu: function() {
			this.isContextMenuEnabled = true;
		},
		disableContextMenu: function() {
			this.isContextMenuEnabled = false;
		},

		contextMenuTimeout: null,
		startContextMenuTimer: function() {
			//

			var t = this;

			t.killContextMenuTimer();

			t.contextMenuTimer = setTimeout(function() {
				t.hideContextMenu();
				t.killContextMenuTimer();
			}, 750);
		},
		killContextMenuTimer: function() {
			var timer = this.contextMenuTimer;

			//

			if (timer != null) {
				clearTimeout(timer);
				delete timer;
				timer = null;
			}
		},

		hideContextMenu: function() {
			this.contextMenu.hide();
		},

		renderContextMenu: function(x,y) {

			// alway re-render the items so that things like "turn fullscreen on" and "turn fullscreen off" are always written correctly
			var t = this,
				html = '',
				items = t.options.contextMenuItems;

			for (var i=0, il=items.length; i<il; i++) {

				if (items[i].isSeparator) {
					html += '<div class="mejs-contextmenu-separator"></div>';
				} else {

					var rendered = items[i].render(t);

					// render can return null if the item doesn't need to be used at the moment
					if (rendered != null) {
						html += '<div class="mejs-contextmenu-item" data-itemindex="' + i + '" id="element-' + (Math.random()*1000000) + '">' + rendered + '</div>';
					}
				}
			}

			// position and show the context menu
			t.contextMenu
				.empty()
				.append($(html))
				.css({top:y, left:x})
				.show();

			// bind events
			t.contextMenu.find('.mejs-contextmenu-item').each(function() {

				// which one is this?
				var $dom = $(this),
					itemIndex = parseInt( $dom.data('itemindex'), 10 ),
					item = t.options.contextMenuItems[itemIndex];

				// bind extra functionality?
				if (typeof item.show != 'undefined')
					item.show( $dom , t);

				// bind click action
				$dom.click(function() {
					// perform click action
					if (typeof item.click != 'undefined')
						item.click(t);

					// close
					t.contextMenu.hide();
				});
			});

			// stop the controls from hiding
			setTimeout(function() {
				t.killControlsTimer('rev3');
			}, 100);

		}
	});

})(mejs.$);
(function($) {
	// skip back button

	$.extend(mejs.MepDefaults, {
		skipBackInterval: 30,
		// %1 will be replaced with skipBackInterval in this string
		skipBackText: mejs.i18n.t('Skip back %1 seconds')
	});

	$.extend(MediaElementPlayer.prototype, {
		buildskipback: function(player, controls, layers, media) {
			var
				t = this,
			// Replace %1 with skip back interval
				backText = t.options.skipBackText.replace('%1', t.options.skipBackInterval),
			// create the loop button
				loop =
					$('<div class="mejs-button mejs-skip-back-button">' +
						'<button type="button" aria-controls="' + t.id + '" title="' + backText + '" aria-label="' + backText + '">' + t.options.skipBackInterval + '</button>' +
						'</div>')
					// append it to the toolbar
						.appendTo(controls)
						// add a click toggle event
						.click(function() {
							media.setCurrentTime(Math.max(media.currentTime - t.options.skipBackInterval, 0));
							$(this).find('button').blur();
						});
		}
	});

})(mejs.$);

/**
 * Postroll plugin
 */
(function($) {

	$.extend(mejs.MepDefaults, {
		postrollCloseText: mejs.i18n.t('Close')
	});

	// Postroll
	$.extend(MediaElementPlayer.prototype, {
		buildpostroll: function(player, controls, layers, media) {
			var
				t = this,
				postrollLink = t.container.find('link[rel="postroll"]').attr('href');

			if (typeof postrollLink !== 'undefined') {
				player.postroll =
					$('<div class="mejs-postroll-layer mejs-layer"><a class="mejs-postroll-close" onclick="$(this).parent().hide();return false;">' + t.options.postrollCloseText + '</a><div class="mejs-postroll-layer-content"></div></div>').prependTo(layers).hide();

				t.media.addEventListener('ended', function (e) {
					$.ajax({
						dataType: 'html',
						url: postrollLink,
						success: function (data, textStatus) {
							layers.find('.mejs-postroll-layer-content').html(data);
						}
					});
					player.postroll.show();
				}, false);
			}
		}
	});

})(mejs.$);

/*! Hammer.JS - v2.0.6 - 2016-01-06
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the  license */
(function(window, document, exportName, undefined) {
    'use strict';

    var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
    var TEST_ELEMENT = document.createElement('div');

    var TYPE_FUNCTION = 'function';

    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;

        if (!obj) {
            return;
        }

        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    /**
     * wrap a method with a deprecation warning and stack trace
     * @param {Function} method
     * @param {String} name
     * @param {String} message
     * @returns {Function} A new function wrapping the supplied method.
     */
    function deprecate(method, name, message) {
        var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
        return function() {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                .replace(/^\s+at\s+/gm, '')
                .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
                log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
        };
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} target
     * @param {...Object} objects_to_assign
     * @returns {Object} target
     */
    var assign;
    if (typeof Object.assign !== 'function') {
        assign = function assign(target) {
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (var nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    } else {
        assign = Object.assign;
    }

    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge=false]
     * @returns {Object} dest
     */
    var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || (merge && dest[keys[i]] === undefined)) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }, 'extend', 'Use `assign`.');

    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    var merge = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, 'merge', 'Use `assign`.');

    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;

        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;

        if (properties) {
            assign(childP, properties);
        }
    }

    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }

    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return (val1 === undefined) ? val2 : val1;
    }

    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }

    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }

    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;

        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }

        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }

        return results;
    }

    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);

        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = (prefix) ? prefix + camelProp : property;

            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    /**
     * get a unique id
     * @returns {number} uniqueId
     */
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }

    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return (doc.defaultView || doc.parentWindow || window);
    }

    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';

    var COMPUTE_INTERVAL = 25;

    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };

        this.init();

    }

    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() { },

        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },

        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;

        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new (Type)(manager, inputHandler);
    }

    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
        var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manager.session = {};
        }

        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;

        // compute scale, rotation etc
        computeInputData(manager, input);

        // emit secret event
        manager.emit('hammer.input', input);

        manager.recognize(input);
        manager.session.prevInput = input;
    }

    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

        computeIntervalInputData(session, input);

        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }

    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity, velocityX, velocityY, direction;

        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;

            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);

            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }

        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }

    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }

    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }

        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }

    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }

    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }

    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt((x * x) + (y * y));
    }

    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }

    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }

    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };

    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;

        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state

        Input.apply(this, arguments);
    }

    inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];

            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }

            // mouse must be down, and mouse events are allowed (see the TouchMouse input)
            if (!this.pressed || !this.allow) {
                return;
            }

            if (eventType & INPUT_END) {
                this.pressed = false;
            }

            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });

    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };

// in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };

    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;

        Input.apply(this, arguments);

        this.store = (this.manager.session.pointerEvents = []);
    }

    inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;

            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

            var isTouch = (pointerType == INPUT_TYPE_TOUCH);

            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');

            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }

            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) {
                return;
            }

            // update the event in the store
            store[storeIndex] = ev;

            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });

            if (removePointer) {
                // remove from the store
                store.splice(storeIndex, 1);
            }
        }
    });

    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;

        Input.apply(this, arguments);
    }

    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

            // should we handle the touch events?
            if (type === INPUT_START) {
                this.started = true;
            }

            if (!this.started) {
                return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type);

            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                this.started = false;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);

        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }

        return [all, changed];
    }

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};

        Input.apply(this, arguments);
    }

    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }

            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;

        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }

        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;

        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });

        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }

        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }

            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }

        if (!changedTargetTouches.length) {
            return;
        }

        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }

    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);

        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

            // when we're in a touch event, so  block all upcoming mouse events
            // most mobile browser also emit mouseevents, right after touchstart
            if (isTouch) {
                this.mouse.allow = false;
            } else if (isMouse && !this.mouse.allow) {
                return;
            }

            // reset the allowMouse when we're done
            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                this.mouse.allow = true;
            }

            this.callback(manager, inputEvent, inputData);
        },

        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });

    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },

        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set(this.manager.options.touchAction);
        },

        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },

        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
            // not needed with native support for the touchAction property
            if (NATIVE_TOUCH_ACTION) {
                return;
            }

            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;

            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE);
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

            if (hasNone) {
                //do not prevent defaults if this is a tap gesture

                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;

                if (isTapPointer && isTapMovement && isTapTouchTime) {
                    return;
                }
            }

            if (hasPanX && hasPanY) {
                // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                return;
            }

            if (hasNone ||
                (hasPanY && direction & DIRECTION_HORIZONTAL) ||
                (hasPanX && direction & DIRECTION_VERTICAL)) {
                return this.preventSrc(srcEvent);
            }
        },

        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }

        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
        }

        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }

        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }

        return TOUCH_ACTION_AUTO;
    }

    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});

        this.id = uniqueId();

        this.manager = null;

        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;

        this.simultaneous = {};
        this.requireFail = [];
    }

    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},

        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
            assign(this.options, options);

            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },

        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },

        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },

        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },

        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },

        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },

        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },

        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
                self.manager.emit(event, input);
            }

            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
                emit(input.additionalEvent);
            }

            // panend and pancancel
            if (state >= STATE_ENDED) {
                emit(self.options.event + stateStr(state));
            }
        },

        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },

        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },

        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);

            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }

            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone);

            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },

        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) { }, // jshint ignore:line

        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() { },

        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() { }
    };

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }

    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }

    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },

        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },

        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
            var state = this.state;
            var eventType = input.eventType;

            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);

            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);

        this.pX = null;
        this.pY = null;
    }

    inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },

        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },

        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;

            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },

        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) &&
                (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
        },

        emit: function(input) {

            this.pX = input.deltaX;
            this.pY = input.deltaY;

            var direction = directionStr(input.direction);

            if (direction) {
                input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },

        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);

        this._timer = null;
        this._input = null;
    }

    inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 251, // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
        },

        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;

            this._input = input;

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }

            if (input && (input.eventType & INPUT_END)) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
        },

        attrTest: function(input) {
            return this._super.attrTest.call(this, input) &&
                (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },

        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },

        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) &&
                direction & input.offsetDirection &&
                input.distance > this.options.threshold &&
                input.maxPointers == this.options.pointers &&
                abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },

        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
        }
    });

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);

        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;

        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 9, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },

        getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
        },

        process: function(input) {
            var options = this.options;

            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;

            this.reset();

            if ((input.eventType & INPUT_START) && (this.count === 0)) {
                return this.failTimeout();
            }

            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }

                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                this.pTime = input.timeStamp;
                this.pCenter = input.center;

                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }

                this._input = input;

                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },

        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },

        reset: function() {
            clearTimeout(this._timer);
        },

        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });

    /**
     * Simple way to create a manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * @const {string}
     */
    Hammer.VERSION = '2.0.6';

    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,

        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,

        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,

        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,

        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,

        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, {enable: false}],
            [PinchRecognizer, {enable: false}, ['rotate']],
            [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
            [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
            [TapRecognizer],
            [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
            [PressRecognizer]
        ],

        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    var STOP = 1;
    var FORCED_STOP = 2;

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});

        this.options.inputTarget = this.options.inputTarget || element;

        this.handlers = {};
        this.session = {};
        this.recognizers = [];

        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);

        toggleCssProps(this, true);

        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new (item[0])(item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
            assign(this.options, options);

            // Options that need a little more setup
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },

        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },

        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }

            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);

            var recognizer;
            var recognizers = this.recognizers;

            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;

            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = null;
            }

            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];

                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }

                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },

        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }

            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },

        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }

            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;

            this.touchAction.update();
            return recognizer;
        },

        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }

            recognizer = this.get(recognizer);

            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);

                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }

            return this;
        },

        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },

        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },

        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }

            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }

            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };

            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },

        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps(this, false);

            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) {
            return;
        }
        each(manager.options.cssProps, function(value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }

    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }

    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,

        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,

        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,

        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,

        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,

        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,

        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
    var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
    freeGlobal.Hammer = Hammer;

    if (typeof define === 'function' && define.amd) {
        define(function() {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }

})(window, document, 'Hammer');
/**
 * http://api.jquery.com/jQuery.browser/
 */

(function() {
	"use strict";

	var matched, browser;

	var uaMatch = function(ua) {
		ua = ua.toLowerCase();

		var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
			/(webkit)[ \/]([\w.]+)/.exec(ua) ||
			/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
			/(msie) ([\w.]+)/.exec(ua) ||
			ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
			[];

		return {
			browser: match[1] || "",
			version: match[2] || "0"
		};
	};

	matched = uaMatch(navigator.userAgent);
	browser = {};

	if (matched.browser) {
		browser[matched.browser] = true;
		browser.version = matched.version;
	}

	// Chrome is Webkit, but Webkit is also Safari.
	if (browser.chrome) {
		browser.webkit = true;
	} else if (browser.webkit) {
		browser.safari = true;
	}

	Cog.registerStatic({
		name: "utils.browser",
		sharedApi: browser,
		api: {}
	});
})();

Cog.utils = Cog.utils || {};

/**
 * Creates objects so a passed path exists
 * @param namespaceString string representation of object's path
 */

(function() {
	"use strict";

	function namespace(namespaceString) {
		var parts = namespaceString.split("."),
			parent = window,
			currentPart = "";

		for (var i = 0, length = parts.length; i < length; i++) {
			currentPart = parts[i];
			parent[currentPart] = parent[currentPart] || {};
			parent = parent[currentPart];
		}

		return parent;
	}

	Cog.registerStatic({
		name: "utils.namespace",
		sharedApi: namespace,
		api: {}
	});
})();

/**
 * Utils - Overlay
 */
(function($) {
	'use strict';

	var api = {},
		overlayContainer,
		overlayContent,
		overlayContentInner,
		overlayBackground,
		overlayLoading,
		overlayClose,
		mobileChecked = false,
		mobile = false,
		status,
		startingPositionTop = 100; //default top

	function Overlay(elem, url) {
		this.obj = elem;
		this.url = url;
		this.isFirstTimeUser = false;
		this.properties = {
			'href': $(elem).attr('href'),
			'width': $(elem).data('overlaywidth')
		};
	}

	Overlay.prototype.attachEvents = function() {
		var self = this;

		$(self.obj).on('click', function(event) {
			event.preventDefault();
			event.stopPropagation();

			self.openLink();
		});

		$(document)
			.on('click touchstart', '.overlay-content', function(event) {
				event.stopPropagation();
			})
			.on('click touchstart', '.overlay-background, .overlay-container, .overlay-close', function() {
				if (self.visible) {
					self.hideOverlay();
				}
			})
			.on('keydown', function (event) {
				if (event.keyCode === 27) {
					self.hideOverlay();
				}
			});
	};

	Overlay.prototype.openLink = function(){
		var self = this,
			url = self.properties.href;

		this.visible = true;

		if (!mobile) {
			url = url.indexOf('.html') > -1 ? this.url.setSelector(url, 'lightbox') : url;
			this.initOverlayContainer();
			this.showLoadingContainer();
		}

		$.ajax({
			type: 'GET',
			url: url,
			dataType: 'html',
			success: function(response) {
				this.overlayBuilder(response);
				Cog.init({$element: overlayContentInner});
			}.bind(this)
		});
	};

	Overlay.prototype.firstTimeUserCheck = function(){
		var visited = Cog.Cookie.read('visited');

		if (!visited && !status.isAuthor() && this.properties.href.indexOf('first-time-user-notification') > -1) {
			this.openLink();
			this.isFirstTimeUser = true;
		}
	};

	Overlay.prototype.initOverlayContainer = function() {
		var body = $('body'),
			overlayBackgroundHtml = '<div class="overlay-background"></div>',
			overlayContainerHtml = '<div class="overlay-container">' +
				'<div class="overlay-content">' +
				'<div tabindex="0" class="overlay-close"></div>' +
				'<div class="overlay-loading"></div>' +
				'<div class="overlay-content-inner"></div>' +
				'</div>' +
				'</div>';

		if (!overlayContainer) {
			body.append(overlayBackgroundHtml, overlayContainerHtml);
			overlayBackground = $('.overlay-background');
			overlayContainer = $('.overlay-container');
			overlayContent = $('.overlay-content');
			overlayContentInner = $('.overlay-content-inner');
			overlayLoading = $('.overlay-loading');
			overlayClose = $('.overlay-close');
		} else {
			overlayContentInner.empty();
		}
	};

	Overlay.prototype.showLoadingContainer = function() {
		overlayClose.hide();
		overlayBackground.show();
		overlayContainer.css({
			'top': $(window).scrollTop() + parseInt(startingPositionTop, 10) + 'px'
		});
		overlayContainer.show();
		overlayLoading.show();
	};

	Overlay.prototype.overlayBuilder = function(response) {
		var self = this;

		if (mobile) {
			window.open(self.properties.href, '_blank');
		} else {
			self.showOverlay(response);
		}
	};

	Overlay.prototype.showOverlay = function(response) {
		var overlayWidth = this.properties.width;

		overlayLoading.hide();
		overlayClose.show();
		overlayContent.css({
			'width': '90%',
			'max-width': overlayWidth
		});
		overlayContentInner.append(response);
	};

	Overlay.prototype.hideOverlay = function() {
		overlayContainer.fadeOut();
		overlayBackground.fadeOut();

		if (this.visible) {
			this.visible = false;
			Cog.fireEvent('overlay', 'close');
		}

		if (this.isFirstTimeUser) {
			Cog.Cookie.create('visited', true, 365);
		}
	};

	function checkMobile() {
		var device = Cog.Cookie.read('device-group');
		return (device === 'mobile');

	}

	api.onRegister = function(elements) {
		var self = this;

		status = this.external.status;

		if (!mobileChecked) {
			mobile = checkMobile();
			mobileChecked = true;
		}

		elements.$scope.each(function() {
			var overlay = new Overlay(this, self.external.url);
			overlay.firstTimeUserCheck();
			overlay.attachEvents();
		});
	};

	Cog.registerComponent({
		name: 'overlay',
		api: api,
		selector: 'a.lightbox',
		requires: [
			{
				name: 'utils.url',
				apiId: 'url'
			},
			{
				name: 'utils.status',
				apiId: 'status'
			}
		]
	});

})(Cog.jQuery());


(function ($) {
    'use strict';

    var api = {},
        cookieHeight,
        screenReader;

    function getCookieHeight($scope) {
        return $scope.length ? $scope[0].scrollHeight : 0;
    }

    function setCookieHeight($scope, height) {
        cookieHeight = height;
        $scope.css('max-height', height);
        $('.cookiePolicy-accept').attr('data-id', 'link_content');
                $('.cookiePolicy-accept').attr('data-text', 'XT | Cookie Policy Top | Dismiss');
              	$('.cookiePolicy-text').find('.richText-content p a').attr('data-id', 'link_content');
                $('.cookiePolicy-text').find('.richText-content p a').attr('data-text', 'XT | Cookie Policy Top | Tell me more');
        Cog.fireEvent('cookiePolicy', 'cookieHeightChanged', {
            cookieHeight: height
        });
    }

    function attachEvents($scope) {
        $(window).on('resize.cookie', _.debounce(function () {
            var newCookieHeight = getCookieHeight($scope);

            if (newCookieHeight !== cookieHeight) {
                setCookieHeight($scope, newCookieHeight);
            }
        }, 100));
    }

    function acceptCookie($scope) {
        $scope.addClass('collapsed');
        $('body').removeClass('cookie-space');
        Cog.Cookie.create('cookiePolicy', true, 30);
        screenReader.toggle($scope, true);
        $(window).off('resize.cookie');
        cookieHeight = 0;
        Cog.fireEvent('cookiePolicy', 'cookieHeightChanged', {cookieHeight: cookieHeight});
    }

    api.init = function (scope) {
        var cookie = Cog.Cookie.read('cookiePolicy'),
            $scope = $(scope);

        screenReader = this.external.screenReader;
        screenReader.toggle($scope, true);

        api.markup = $scope;

        if (!cookie && $scope.size()) {
            $scope.removeClass('collapsed');
            $('body').addClass('cookie-space');
            screenReader.toggle($scope, false);
            $scope.find('.cookiePolicy-accept').on('click', function (e) {
                e.preventDefault();
                acceptCookie($scope);
            });

            cookieHeight = getCookieHeight($scope);
            setCookieHeight($scope, cookieHeight);
            attachEvents($scope);
        }
    };

    Cog.register({
        name: 'cookiePolicy',
        api: api,
        selector: '.cookiePolicy',
        requires: [{
            name: 'utils.screenReader',
            apiId: 'screenReader'
        }]
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {},
        href,
        blank,
        hiddenClass = 'is-hidden',
        isMobile = checkMobile(),
        $pageContext = $('html, body'),
        scrollTopSpeed = 250,
        screenReader;

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    function isExternal($link) {
        return $link.attr('href')
            && $link.attr('href').indexOf(window.location.protocol + '//' + window.location.hostname) !== 0 // same domain as in the browser bar
            && $link.attr('href').indexOf('mailto:') !== 0 // mailto links
            && $link.attr('href').indexOf('tel:') !== 0; // tel links
    }

    function scrollViewToTop() {
        $($pageContext).animate({
            scrollTop: 0
        }, scrollTopSpeed);
    }

    function openDialog(event, $scope) {
        var $target = $(event.target);

        screenReader.toggle($scope, false);

        if (isExternal($target)) {
            event.preventDefault();

            if ($target.prop('tagName').toUpperCase() !== 'A') {
                $target = $target.closest('.external');
            }

            href = $target.attr('href');
            blank = $target.attr('target');

            $scope.removeClass(hiddenClass);

            if (isMobile && isExternal($target)) {
                scrollViewToTop();
            }

            return false;
        }
    }

    function acceptButton(e, $scope) {
        if (blank === '_blank') {
            window.open(href, '_blank');
            $scope.addClass(hiddenClass);
        } else {
            window.location.href = href;
        }
    }

    function denyButton(e, $scope) {
        e.preventDefault();
        $scope.addClass(hiddenClass);
        screenReader.toggle($scope, true);
    }

    function addCloseButton($scope) {
        var $close = $('<a href="#close" class="exit-notification-close">X</a>');
        $scope.find('.exit-notification-inner').append($close);
        $close.on('click', function (e) {
            denyButton(e, $scope);
        });
    }

    api.init = function ($scope) {
        screenReader = this.external.screenReader;

        if ($scope.length) {
            screenReader.toggle($scope, true);


            $scope.find('.exit-notification-accept').on('click', function (e) {
                acceptButton(e, $scope);
            });
            $scope.find('.exit-notification-deny').on('click', function (e) {
                denyButton(e, $scope);
            });
            $('body').on('click.exit-notification', 'a.external', function (e) {
                openDialog(e, $scope);
            });

            addCloseButton($scope);
        }
    };

    Cog.register({
        name: 'exitNotification',
        api: api,
        selector: '#exit-notification',
        requires: [{
            name: 'utils.screenReader',
            apiId: 'screenReader'
        }]
    });
})(Cog.jQuery());

/**
 * Post link
 */

/**
 * Utils - Settings
 * File for setting initials
 */

(function($) {
	"use strict";

	var api = {},
		sharedApi = {};

	api.init = function() {
		// Set lo-dash delimiters to mustache-like
		_.templateSettings = {
			interpolate: /\{\{(.+?)\}\}/g,
			evaluate: /\{\%(.+?)\%\}/g
		};

		// Set external api with data passed on body
		$.extend(sharedApi, $("body").data());
	};

	Cog.registerStatic({
		name: "utils.settings",
		api: api,
		sharedApi: sharedApi
	});
})(Cog.jQuery());
/**
 * Utils - Scroll
 * Smooth scrolling to components
 */

(function($) {
	"use strict";

	var api = {};

	api.init = function() {
		$(document).on("click", "a[href*=#]:not([href^=#])", function(e) {
			var target = this.hash;
			var $target = $("[id=" + target.substring(1) + "]").size() ?
				$("[id=" + target.substring(1) + "]") : $("[name=" + target.substring(1) + "]");

			if ($target.size() && window.location.origin + window.location.pathname + this.hash === this.href) {
				$("html, body").stop().animate({
					"scrollTop": $target.offset().top
				}, 800, function() {
					window.location.hash = target;
				});

				e.preventDefault();
			}
		});
	};

	Cog.registerStatic({
		name: "utils.scroll",
		api: api
	});
})(Cog.jQuery());
/**
 * Utils - URL - url modification helpers
 */

(function() {
	"use strict";
	var api = {},
		sharedApi = {};

	/* @CQ.shared.HTTP.setSelector */
	sharedApi.setSelector = function(url, selector, index) {

		var post = "";
		var pIndex = url.indexOf("?");
		if (pIndex === -1) {
			pIndex = url.indexOf("#");
		}
		if (pIndex !== -1) {
			post = url.substring(pIndex);
			url = url.substring(0, pIndex);
		}

		index = index ? index : 0;

		var selectors = sharedApi.getSelectors(url);
		var ext = url.substring(url.lastIndexOf("."));
		// cut extension
		url = url.substring(0, url.lastIndexOf("."));
		// cut selectors
		var fragment = (selectors.length > 0) ? url.replace("." + selectors.join("."), "") : url;

		if (selectors.length > 0) {
			for (var i = 0; i < selectors.length; i++) {
				if (index === i) {
					fragment += "." + selector;
				} else {
					fragment += "." + selectors[i];
				}
			}
		} else {
			fragment += "." + selector;
		}

		return fragment + ext + post;
	};

	/* @CQ.shared.HTTP.getSelectors */
	sharedApi.getSelectors = function(url) {
		var selectors = [];
		url = url || window.location.href;
		url = sharedApi.removeParameters(url);
		url = sharedApi.removeAnchor(url);
		var fragment = url.substring(url.lastIndexOf("/"));
		if (fragment) {
			var split = fragment.split(".");
			if (split.length > 2) {
				for (var i = 0; i < split.length; i++) {
					// don't add node name and extension as selectors
					if (i > 0 && i < split.length - 1) {
						selectors.push(split[i]);
					}
				}
			}
		}

		return selectors;
	};

	/* @_g.HTTP.removeParameters */
	sharedApi.removeParameters = function(url) {
		if (url.indexOf("?") !== -1) {
			return url.substring(0, url.indexOf("?"));
		}
		return url;
	};

	/* @_g.HTTP.removeAnchor*/
	sharedApi.removeAnchor = function(url) {
		if (url.indexOf("#") !== -1) {
			return url.substring(0, url.indexOf("#"));
		}
		return url;
	};

	Cog.registerStatic({
		name: "utils.url",
		api: api,
		sharedApi: sharedApi
	});

})();
/**
 * Status - get current page status
 */

(function($) {
	'use strict';

	var api = {},
		cache = {},
		sharedApi = {};

	function checkMobile() {
		return window.Modernizr.mq('only screen and (max-width: 992px)');
	}

	function checkTab() {
		return window.Modernizr.mq('only screen and (max-width: 768px)');
	}

	function checkPhone() {
		return window.Modernizr.mq('only screen and (max-width: 480px)');
	}

	sharedApi.isNonTouchAuthor = function() {
		if (typeof cache.isNonTouchAuthor === 'undefined') {
			cache.isNonTouchAuthor = $('body').hasClass('cq-wcm-edit');
		}

		return cache.isNonTouchAuthor;
	};

	sharedApi.isTouchAuthor = function() {
		if (typeof cache.isTouchAuthor === 'undefined') {
			cache.isTouchAuthor = $('body').hasClass('cq-wcm-edit-touch');
		}

		return cache.isTouchAuthor;
	};

	sharedApi.isAuthor = function() {
		if (typeof cache.isAuthor === 'undefined') {
			cache.isAuthor = sharedApi.isNonTouchAuthor() || sharedApi.isTouchAuthor();
		}

		return cache.isAuthor;
	};

	sharedApi.isPublish = function() {
		return !sharedApi.isAuthor();
	};

	sharedApi.isMobile = function() {
		if (typeof cache.isMobile === 'undefined' || cache.isMobile === null) {
			cache.isMobile = checkMobile();
		}

		return cache.isMobile;
	};

	sharedApi.isTablet = function() {
		if (typeof cache.isTablet === 'undefined' || cache.isTablet === null) {
			cache.isTablet = checkTab();
		}

		return cache.isTablet;
	};

	sharedApi.isPhone = function() {
		if (typeof cache.isPhone === 'undefined' || cache.isPhone === null) {
			cache.isPhone = checkPhone();
		}

		return cache.isPhone;
	};

	api.init = function() {
		$(window).on('resize', _.debounce(function() {
			cache.isMobile = checkMobile();
			cache.isPhone = checkPhone();
			cache.isTablet = checkTab();
		}));
	};

	Cog.registerStatic({
		name: 'utils.status',
		api: api,
		sharedApi: sharedApi
	});
})(Cog.jQuery());

/*! waitForImages jQuery Plugin - v2.0.2 - 2015-06-02
* https://github.com/alexanderdickson/waitForImages
* Copyright (c) 2015 Alex Dickson; Licensed MIT */
;(function (factory) {
    var $ = Cog.jQuery();
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS / nodejs module
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory($);
    }
}(function ($) {
    // Namespace all events.
    var eventNamespace = 'waitForImages';

    // CSS properties which contain references to images.
    $.waitForImages = {
        hasImageProperties: [
            'backgroundImage',
            'listStyleImage',
            'borderImage',
            'borderCornerImage',
            'cursor'
        ],
        hasImageAttributes: ['srcset']
    };

    // Custom selector to find all `img` elements with a valid `src` attribute.
    $.expr[':']['has-src'] = function (obj) {
        // Ensure we are dealing with an `img` element with a valid
        // `src` attribute.
        return $(obj).is('img[src][src!=""]');
    };

    // Custom selector to find images which are not already cached by the
    // browser.
    $.expr[':'].uncached = function (obj) {
        // Ensure we are dealing with an `img` element with a valid
        // `src` attribute.
        if (!$(obj).is(':has-src')) {
            return false;
        }

        return !obj.complete;
    };

    $.fn.waitForImages = function () {

        var allImgsLength = 0;
        var allImgsLoaded = 0;
        var deferred = $.Deferred();

        var finishedCallback;
        var eachCallback;
        var waitForAll;

        // Handle options object (if passed).
        if ($.isPlainObject(arguments[0])) {

            waitForAll = arguments[0].waitForAll;
            eachCallback = arguments[0].each;
            finishedCallback = arguments[0].finished;

        } else {

            // Handle if using deferred object and only one param was passed in.
            if (arguments.length === 1 && $.type(arguments[0]) === 'boolean') {
                waitForAll = arguments[0];
            } else {
                finishedCallback = arguments[0];
                eachCallback = arguments[1];
                waitForAll = arguments[2];
            }

        }

        // Handle missing callbacks.
        finishedCallback = finishedCallback || $.noop;
        eachCallback = eachCallback || $.noop;

        // Convert waitForAll to Boolean
        waitForAll = !! waitForAll;

        // Ensure callbacks are functions.
        if (!$.isFunction(finishedCallback) || !$.isFunction(eachCallback)) {
            throw new TypeError('An invalid callback was supplied.');
        }

        this.each(function () {
            // Build a list of all imgs, dependent on what images will
            // be considered.
            var obj = $(this);
            var allImgs = [];
            // CSS properties which may contain an image.
            var hasImgProperties = $.waitForImages.hasImageProperties || [];
            // Element attributes which may contain an image.
            var hasImageAttributes = $.waitForImages.hasImageAttributes || [];
            // To match `url()` references.
            // Spec: http://www.w3.org/TR/CSS2/syndata.html#value-def-uri
            var matchUrl = /url\(\s*(['"]?)(.*?)\1\s*\)/g;

            if (waitForAll) {

                // Get all elements (including the original), as any one of
                // them could have a background image.
                obj.find('*').addBack().each(function () {
                    var element = $(this);

                    // If an `img` element, add it. But keep iterating in
                    // case it has a background image too.
                    if (element.is('img:has-src')) {
                        allImgs.push({
                            src: element.attr('src'),
                            element: element[0]
                        });
                    }

                    $.each(hasImgProperties, function (i, property) {
                        var propertyValue = element.css(property);
                        var match;

                        // If it doesn't contain this property, skip.
                        if (!propertyValue) {
                            return true;
                        }

                        // Get all url() of this element.
                        while (match = matchUrl.exec(propertyValue)) {
                            allImgs.push({
                                src: match[2],
                                element: element[0]
                            });
                        }
                    });

                    $.each(hasImageAttributes, function (i, attribute) {
                        var attributeValue = element.attr(attribute);
                        var attributeValues;

                        // If it doesn't contain this property, skip.
                        if (!attributeValue) {
                            return true;
                        }

                        // Check for multiple comma separated images
                        attributeValues = attributeValue.split(',');

                        $.each(attributeValues, function(i, value) {
                            // Trim value and get string before first
                            // whitespace (for use with srcset).
                            value = $.trim(value).split(' ')[0];
                            allImgs.push({
                                src: value,
                                element: element[0]
                            });
                        });
                    });
                });
            } else {
                // For images only, the task is simpler.
                obj.find('img:has-src')
                    .each(function () {
                    allImgs.push({
                        src: this.src,
                        element: this
                    });
                });
            }

            allImgsLength = allImgs.length;
            allImgsLoaded = 0;

            // If no images found, don't bother.
            if (allImgsLength === 0) {
                finishedCallback.call(obj[0]);
                deferred.resolveWith(obj[0]);
            }

            $.each(allImgs, function (i, img) {

                var image = new Image();
                var events =
                  'load.' + eventNamespace + ' error.' + eventNamespace;

                // Handle the image loading and error with the same callback.
                $(image).one(events, function me (event) {
                    // If an error occurred with loading the image, set the
                    // third argument accordingly.
                    var eachArguments = [
                        allImgsLoaded,
                        allImgsLength,
                        event.type == 'load'
                    ];
                    allImgsLoaded++;

                    eachCallback.apply(img.element, eachArguments);
                    deferred.notifyWith(img.element, eachArguments);

                    // Unbind the event listeners. I use this in addition to
                    // `one` as one of those events won't be called (either
                    // 'load' or 'error' will be called).
                    $(this).off(events, me);

                    if (allImgsLoaded == allImgsLength) {
                        finishedCallback.call(obj[0]);
                        deferred.resolveWith(obj[0]);
                        return false;
                    }

                });

                image.src = img.src;
            });
        });

        return deferred.promise();

    };
}));
/*
 * easy-autocomplete
 * jQuery plugin for autocompletion
 *
 * @author Łukasz Pawełczak (http://github.com/pawelczak)
 * @version 1.3.5
 * Copyright  License: MIT
 */

/*
 * EasyAutocomplete - Configuration
 */
var EasyAutocomplete = (function(scope, $){

    scope.Configuration = function Configuration(options) {
        var defaults = {
            data: "list-required",
            url: "list-required",
            dataType: "json",

            listLocation: function(data) {
                return data;
            },

            xmlElementName: "",

            getValue: function(element) {
                return element;
            },

            autocompleteOff: true,

            placeholder: false,

            ajaxCallback: function() {},

            matchResponseProperty: false,

            list: {
                sort: {
                    enabled: false,
                    method: function(a, b) {
                        a = defaults.getValue(a);
                        b = defaults.getValue(b);
                        if (a < b) {
                            return -1;
                        }
                        if (a > b) {
                            return 1;
                        }
                        return 0;
                    }
                },

                maxNumberOfElements: 6,

                hideOnEmptyPhrase: true,

                match: {
                    enabled: false,
                    caseSensitive: false,
                    method: function(element, phrase) {

                        if (element.search(phrase) > -1) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                },

                showAnimation: {
                    type: "normal", //normal|slide|fade
                    time: 400,
                    callback: function() {}
                },

                hideAnimation: {
                    type: "normal",
                    time: 400,
                    callback: function() {}
                },

                /* Events */
                onClickEvent: function() {},
                onSelectItemEvent: function() {},
                onLoadEvent: function() {},
                onChooseEvent: function() {},
                onKeyEnterEvent: function() {},
                onMouseOverEvent: function() {},
                onMouseOutEvent: function() {},
                onShowListEvent: function() {},
                onHideListEvent: function() {}
            },

            highlightPhrase: true,

            theme: "",

            cssClasses: "",

            minCharNumber: 0,

            requestDelay: 0,

            adjustWidth: true,

            ajaxSettings: {},

            preparePostData: function(data, inputPhrase) {return data;},

            loggerEnabled: true,

            template: "",

            categoriesAssigned: false,

            categories: [{
                maxNumberOfElements: 4
            }]

        };

        var externalObjects = ["ajaxSettings", "template"];

        this.get = function(propertyName) {
            return defaults[propertyName];
        };

        this.equals = function(name, value) {
            if (isAssigned(name)) {
                if (defaults[name] === value) {
                    return true;
                }
            }

            return false;
        };

        this.checkDataUrlProperties = function() {
            if (defaults.url === "list-required" && defaults.data === "list-required") {
                return false;
            }
            return true;
        };
        this.checkRequiredProperties = function() {
            for (var propertyName in defaults) {
                if (defaults[propertyName] === "required") {
                    logger.error("Option " + propertyName + " must be defined");
                    return false;
                }
            }
            return true;
        };

        this.printPropertiesThatDoesntExist = function(consol, optionsToCheck) {
            printPropertiesThatDoesntExist(consol, optionsToCheck);
        };


        prepareDefaults();

        mergeOptions();

        if (defaults.loggerEnabled === true) {
            printPropertiesThatDoesntExist(console, options);
        }

        addAjaxSettings();

        processAfterMerge();
        function prepareDefaults() {

            if (options.dataType === "xml") {

                if (!options.getValue) {

                    options.getValue = function(element) {
                        return $(element).text();
                    };
                }


                if (!options.list) {

                    options.list = {};
                }

                if (!options.list.sort) {
                    options.list.sort = {};
                }


                options.list.sort.method = function(a, b) {
                    a = options.getValue(a);
                    b = options.getValue(b);
                    if (a < b) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                };

                if (!options.list.match) {
                    options.list.match = {};
                }

                options.list.match.method = function(element, phrase) {

                    if (element.search(phrase) > -1) {
                        return true;
                    } else {
                        return false;
                    }
                };

            }
            if (options.categories !== undefined && options.categories instanceof Array) {

                var categories = [];

                for (var i = 0, length = options.categories.length; i < length; i += 1) {

                    var category = options.categories[i];

                    for (var property in defaults.categories[0]) {

                        if (category[property] === undefined) {
                            category[property] = defaults.categories[0][property];
                        }
                    }

                    categories.push(category);
                }

                options.categories = categories;
            }
        }

        function mergeOptions() {

            defaults = mergeObjects(defaults, options);

            function mergeObjects(source, target) {
                var mergedObject = source || {};

                for (var propertyName in source) {
                    if (target[propertyName] !== undefined && target[propertyName] !== null) {

                        if (typeof target[propertyName] !== "object" ||
                            target[propertyName] instanceof Array) {
                            mergedObject[propertyName] = target[propertyName];
                        } else {
                            mergeObjects(source[propertyName], target[propertyName]);
                        }
                    }
                }

                /* If data is an object */
                if (target.data !== undefined && target.data !== null && typeof target.data === "object") {
                    mergedObject.data = target.data;
                }

                return mergedObject;
            }
        }


        function processAfterMerge() {

            if (defaults.url !== "list-required" && typeof defaults.url !== "function") {
                var defaultUrl = defaults.url;
                defaults.url = function() {
                    return defaultUrl;
                };
            }

            if (defaults.ajaxSettings.url !== undefined && typeof defaults.ajaxSettings.url !== "function") {
                var defaultUrl = defaults.ajaxSettings.url;
                defaults.ajaxSettings.url = function() {
                    return defaultUrl;
                };
            }

            if (typeof defaults.listLocation === "string") {
                var defaultlistLocation = defaults.listLocation;

                if (defaults.dataType.toUpperCase() === "XML") {
                    defaults.listLocation = function(data) {
                        return $(data).find(defaultlistLocation);
                    };
                } else {
                    defaults.listLocation = function(data) {
                        return data[defaultlistLocation];
                    };
                }
            }

            if (typeof defaults.getValue === "string") {
                var defaultsGetValue = defaults.getValue;
                defaults.getValue = function(element) {
                    return element[defaultsGetValue];
                };
            }

            if (options.categories !== undefined) {
                defaults.categoriesAssigned = true;
            }

        }

        function addAjaxSettings() {

            if (options.ajaxSettings !== undefined && typeof options.ajaxSettings === "object") {
                defaults.ajaxSettings = options.ajaxSettings;
            } else {
                defaults.ajaxSettings = {};
            }

        }

        function isAssigned(name) {
            if (defaults[name] !== undefined && defaults[name] !== null) {
                return true;
            } else {
                return false;
            }
        }
        function printPropertiesThatDoesntExist(consol, optionsToCheck) {

            checkPropertiesIfExist(defaults, optionsToCheck);

            function checkPropertiesIfExist(source, target) {
                for(var property in target) {
                    if (source[property] === undefined) {
                        consol.log("Property '" + property + "' does not exist in EasyAutocomplete options API.");
                    }

                    if (typeof source[property] === "object" && $.inArray(property, externalObjects) === -1) {
                        checkPropertiesIfExist(source[property], target[property]);
                    }
                }
            }
        }
    };

    return scope;

})(EasyAutocomplete || {}, Cog.jQuery());


/*
 * EasyAutocomplete - Logger
 */
var EasyAutocomplete = (function(scope, $){

    scope.Logger = function Logger() {

        this.error = function(message) {
            console.log("ERROR: " + message);
        };

        this.warning = function(message) {
            console.log("WARNING: " + message);
        };
    };

    return scope;

})(EasyAutocomplete || {}, Cog.jQuery());


/*
 * EasyAutocomplete - Constans
 */
var EasyAutocomplete = (function(scope, $){

    scope.Constans = function Constans() {
        var constants = {
            CONTAINER_CLASS: "easy-autocomplete-container",
            CONTAINER_ID: "eac-container-",

            WRAPPER_CSS_CLASS: "easy-autocomplete"
        };

        this.getValue = function(propertyName) {
            return constants[propertyName];
        };

    };

    return scope;

})(EasyAutocomplete || {}, Cog.jQuery());

/*
 * EasyAutocomplete - ListBuilderService
 *
 * @author Łukasz Pawełczak
 *
 */
var EasyAutocomplete = (function(scope, $) {

    scope.ListBuilderService = function ListBuilderService(configuration, proccessResponseData) {


        this.init = function(data) {
            var listBuilder = [],
                builder = {};

            builder.data = configuration.get("listLocation")(data);
            builder.getValue = configuration.get("getValue");
            builder.maxListSize = configuration.get("list").maxNumberOfElements;


            listBuilder.push(builder);

            return listBuilder;
        };

        this.updateCategories = function(listBuilder, data) {

            if (configuration.get("categoriesAssigned")) {

                listBuilder = [];

                for(var i = 0; i < configuration.get("categories").length; i += 1) {

                    var builder = convertToListBuilder(configuration.get("categories")[i], data);

                    listBuilder.push(builder);
                }

            }

            return listBuilder;
        };

        this.convertXml = function(listBuilder) {
            if(configuration.get("dataType").toUpperCase() === "XML") {

                for(var i = 0; i < listBuilder.length; i += 1) {
                    listBuilder[i].data = convertXmlToList(listBuilder[i]);
                }
            }

            return listBuilder;
        };

        this.processData = function(listBuilder, inputPhrase) {

            for(var i = 0, length = listBuilder.length; i < length; i+=1) {
                listBuilder[i].data = proccessResponseData(configuration, listBuilder[i], inputPhrase);
            }

            return listBuilder;
        };

        this.checkIfDataExists = function(listBuilders) {

            for(var i = 0, length = listBuilders.length; i < length; i += 1) {

                if (listBuilders[i].data !== undefined && listBuilders[i].data instanceof Array) {
                    if (listBuilders[i].data.length > 0) {
                        return true;
                    }
                }
            }

            return false;
        };


        function convertToListBuilder(category, data) {

            var builder = {};

            if(configuration.get("dataType").toUpperCase() === "XML") {

                builder = convertXmlToListBuilder();
            } else {

                builder = convertDataToListBuilder();
            }


            if (category.header !== undefined) {
                builder.header = category.header;
            }

            if (category.maxNumberOfElements !== undefined) {
                builder.maxNumberOfElements = category.maxNumberOfElements;
            }

            if (configuration.get("list").maxNumberOfElements !== undefined) {

                builder.maxListSize = configuration.get("list").maxNumberOfElements;
            }

            if (category.getValue !== undefined) {

                if (typeof category.getValue === "string") {
                    var defaultsGetValue = category.getValue;
                    builder.getValue = function(element) {
                        return element[defaultsGetValue];
                    };
                } else if (typeof category.getValue === "function") {
                    builder.getValue = category.getValue;
                }

            } else {
                builder.getValue = configuration.get("getValue");
            }


            return builder;


            function convertXmlToListBuilder() {

                var builder = {},
                    listLocation;

                if (category.xmlElementName !== undefined) {
                    builder.xmlElementName = category.xmlElementName;
                }

                if (category.listLocation !== undefined) {

                    listLocation = category.listLocation;
                } else if (configuration.get("listLocation") !== undefined) {

                    listLocation = configuration.get("listLocation");
                }

                if (listLocation !== undefined) {
                    if (typeof listLocation === "string") {
                        builder.data = $(data).find(listLocation);
                    } else if (typeof listLocation === "function") {

                        builder.data = listLocation(data);
                    }
                } else {

                    builder.data = data;
                }

                return builder;
            }


            function convertDataToListBuilder() {

                var builder = {};

                if (category.listLocation !== undefined) {

                    if (typeof category.listLocation === "string") {
                        builder.data = data[category.listLocation];
                    } else if (typeof category.listLocation === "function") {
                        builder.data = category.listLocation(data);
                    }
                } else {
                    builder.data = data;
                }

                return builder;
            }
        }

        function convertXmlToList(builder) {
            var simpleList = [];

            if (builder.xmlElementName === undefined) {
                builder.xmlElementName = configuration.get("xmlElementName");
            }


            $(builder.data).find(builder.xmlElementName).each(function() {
                simpleList.push(this);
            });

            return simpleList;
        }

    };

    return scope;

})(EasyAutocomplete || {}, Cog.jQuery());


/*
 * EasyAutocomplete - Data proccess module
 *
 * Process list to display:
 * - sort
 * - decrease number to specific number
 * - show only matching list
 *
 */
var EasyAutocomplete = (function(scope, $) {

    scope.proccess = function proccessData(config, listBuilder, phrase) {

        scope.proccess.match = match;

        var list = listBuilder.data,
            inputPhrase = phrase;//TODO REFACTOR

        list = findMatch(list, inputPhrase);
        list = reduceElementsInList(list);
        list = sort(list);

        return list;


        function findMatch(list, phrase) {
            var preparedList = [],
                value = "";

            if (config.get("list").match.enabled) {

                for(var i = 0, length = list.length; i < length; i += 1) {

                    value = config.get("getValue")(list[i]);

                    if (match(value, phrase)) {
                        preparedList.push(list[i]);
                    }

                }

            } else {
                preparedList = list;
            }

            return preparedList;
        }

        function match(value, phrase) {

            if (!config.get("list").match.caseSensitive) {

                if (typeof value === "string") {
                    value = value.toLowerCase();
                }

                phrase = phrase.toLowerCase();
            }
            if (config.get("list").match.method(value, phrase)) {
                return true;
            } else {
                return false;
            }
        }

        function reduceElementsInList(list) {
            if (listBuilder.maxNumberOfElements !== undefined && list.length > listBuilder.maxNumberOfElements) {
                list = list.slice(0, listBuilder.maxNumberOfElements);
            }

            return list;
        }

        function sort(list) {
            if (config.get("list").sort.enabled) {
                list.sort(config.get("list").sort.method);
            }

            return list;
        }

    };


    return scope;


})(EasyAutocomplete || {}, Cog.jQuery());


/*
 * EasyAutocomplete - Template
 *
 *
 *
 */
var EasyAutocomplete = (function(scope, $) {

    scope.Template = function Template(options) {


        var genericTemplates = {
                basic: {
                    type: "basic",
                    method: function(element) { return element; },
                    cssClass: ""
                },
                description: {
                    type: "description",
                    fields: {
                        description: "description"
                    },
                    method: function(element) {	return element + " - description"; },
                    cssClass: "eac-description"
                },
                iconLeft: {
                    type: "iconLeft",
                    fields: {
                        icon: ""
                    },
                    method: function(element) {
                        return element;
                    },
                    cssClass: "eac-icon-left"
                },
                iconRight: {
                    type: "iconRight",
                    fields: {
                        iconSrc: ""
                    },
                    method: function(element) {
                        return element;
                    },
                    cssClass: "eac-icon-right"
                },
                links: {
                    type: "links",
                    fields: {
                        link: ""
                    },
                    method: function(element) {
                        return element;
                    },
                    cssClass: ""
                },
                custom: {
                    type: "custom",
                    method: function() {},
                    cssClass: ""
                }
            },



            /*
             * Converts method with {{text}} to function
             */
            convertTemplateToMethod = function(template) {


                var _fields = template.fields,
                    buildMethod;

                if (template.type === "description") {

                    buildMethod = genericTemplates.description.method;

                    if (typeof _fields.description === "string") {
                        buildMethod = function(elementValue, element) {
                            return elementValue + " - <span>" + element[_fields.description] + "</span>";
                        };
                    } else if (typeof _fields.description === "function") {
                        buildMethod = function(elementValue, element) {
                            return elementValue + " - <span>" + _fields.description(element) + "</span>";
                        };
                    }

                    return buildMethod;
                }

                if (template.type === "iconRight") {

                    if (typeof _fields.iconSrc === "string") {
                        buildMethod = function(elementValue, element) {
                            return elementValue + "<img class='eac-icon' src='" + element[_fields.iconSrc] + "' />" ;
                        };
                    } else if (typeof _fields.iconSrc === "function") {
                        buildMethod = function(elementValue, element) {
                            return elementValue + "<img class='eac-icon' src='" + _fields.iconSrc(element) + "' />" ;
                        };
                    }

                    return buildMethod;
                }


                if (template.type === "iconLeft") {

                    if (typeof _fields.iconSrc === "string") {
                        buildMethod = function(elementValue, element) {
                            return "<img class='eac-icon' src='" + element[_fields.iconSrc] + "' />" + elementValue;
                        };
                    } else if (typeof _fields.iconSrc === "function") {
                        buildMethod = function(elementValue, element) {
                            return "<img class='eac-icon' src='" + _fields.iconSrc(element) + "' />" + elementValue;
                        };
                    }

                    return buildMethod;
                }

                if(template.type === "links") {

                    if (typeof _fields.link === "string") {
                        buildMethod = function(elementValue, element) {
                            return "<a href='" + element[_fields.link] + "' >" + elementValue + "</a>";
                        };
                    } else if (typeof _fields.link === "function") {
                        buildMethod = function(elementValue, element) {
                            return "<a href='" + _fields.link(element) + "' >" + elementValue + "</a>";
                        };
                    }

                    return buildMethod;
                }


                if (template.type === "custom") {

                    return template.method;
                }

                return genericTemplates.basic.method;

            },


            prepareBuildMethod = function(options) {
                if (!options || !options.type) {

                    return genericTemplates.basic.method;
                }

                if (options.type && genericTemplates[options.type]) {

                    return convertTemplateToMethod(options);
                } else {

                    return genericTemplates.basic.method;
                }

            },

            templateClass = function(options) {
                var emptyStringFunction = function() {return "";};

                if (!options || !options.type) {

                    return emptyStringFunction;
                }

                if (options.type && genericTemplates[options.type]) {
                    return (function () {
                        var _cssClass = genericTemplates[options.type].cssClass;
                        return function() { return _cssClass;};
                    })();
                } else {
                    return emptyStringFunction;
                }
            };


        this.getTemplateClass = templateClass(options);

        this.build = prepareBuildMethod(options);


    };

    return scope;

})(EasyAutocomplete || {}, Cog.jQuery());


/*
 * EasyAutocomplete - jQuery plugin for autocompletion
 *
 */
var EasyAutocomplete = (function(scope, $) {


    scope.main = function Core($input, options) {

        var module = {
            name: "EasyAutocomplete",
            shortcut: "eac"
        };

        var consts = new scope.Constans(),
            config = new scope.Configuration(options),
            logger = new scope.Logger(),
            template = new scope.Template(options.template),
            listBuilderService = new scope.ListBuilderService(config, scope.proccess),
            checkParam = config.equals,

            $field = $input,
            $container = "",
            elementsList = [],
            selectedElement = -1,
            requestDelayTimeoutId;

        scope.consts = consts;

        this.getConstants = function() {
            return consts;
        };

        this.getConfiguration = function() {
            return config;
        };

        this.getContainer = function() {
            return $container;
        };

        this.getSelectedItemIndex = function() {
            return selectedElement;
        };

        this.getItems = function () {
            return elementsList;
        };

        this.getItemData = function(index) {

            if (elementsList.length < index || elementsList[index] === undefined) {
                return -1;
            } else {
                return elementsList[index];
            }
        };

        this.getSelectedItemData = function() {
            return this.getItemData(selectedElement);
        };

        this.build = function() {
            prepareField();
        };

        this.init = function() {
            init();
        };
        function init() {

            if ($field.length === 0) {
                logger.error("Input field doesn't exist.");
                return;
            }

            if (!config.checkDataUrlProperties()) {
                logger.error("One of options variables 'data' or 'url' must be defined.");
                return;
            }

            if (!config.checkRequiredProperties()) {
                logger.error("Will not work without mentioned properties.");
                return;
            }


            prepareField();
            bindEvents();

        }
        function prepareField() {


            if ($field.parent().hasClass(consts.getValue("WRAPPER_CSS_CLASS"))) {
                removeContainer();
                removeWrapper();
            }

            createWrapper();
            createContainer();

            $container = $("#" + getContainerId());
            if (config.get("placeholder")) {
                $field.attr("placeholder", config.get("placeholder"));
            }


            function createWrapper() {
                var $wrapper = $("<div>"),
                    classes = consts.getValue("WRAPPER_CSS_CLASS");


                if (config.get("theme") && config.get("theme") !== "") {
                    classes += " eac-" + config.get("theme");
                }

                if (config.get("cssClasses") && config.get("cssClasses") !== "") {
                    classes += " " + config.get("cssClasses");
                }

                if (template.getTemplateClass() !== "") {
                    classes += " " + template.getTemplateClass();
                }


                $wrapper
                    .addClass(classes);
                $field.wrap($wrapper);


                if (config.get("adjustWidth") === true) {
                    adjustWrapperWidth();
                }


            }

            function adjustWrapperWidth() {
                var fieldWidth = $field.outerWidth();

                $field.parent().css("width", fieldWidth);
            }

            function removeWrapper() {
                $field.unwrap();
            }

            function createContainer() {
                var $elements_container = $("<div>").addClass(consts.getValue("CONTAINER_CLASS"));

                $elements_container
                    .attr("id", getContainerId())
                    .prepend($("<ul>"));


                (function() {

                    $elements_container
                    /* List show animation */
                        .on("show.eac", function() {

                            switch(config.get("list").showAnimation.type) {

                                case "slide":
                                    var animationTime = config.get("list").showAnimation.time,
                                        callback = config.get("list").showAnimation.callback;

                                    $elements_container.find("ul").slideDown(animationTime, callback);
                                    break;

                                case "fade":
                                    var animationTime = config.get("list").showAnimation.time,
                                        callback = config.get("list").showAnimation.callback;

                                    $elements_container.find("ul").fadeIn(animationTime), callback;
                                    break;

                                default:
                                    $elements_container.find("ul").show();
                                    break;
                            }

                            config.get("list").onShowListEvent();

                        })
                        /* List hide animation */
                        .on("hide.eac", function() {

                            switch(config.get("list").hideAnimation.type) {

                                case "slide":
                                    var animationTime = config.get("list").hideAnimation.time,
                                        callback = config.get("list").hideAnimation.callback;

                                    $elements_container.find("ul").slideUp(animationTime, callback);
                                    break;

                                case "fade":
                                    var animationTime = config.get("list").hideAnimation.time,
                                        callback = config.get("list").hideAnimation.callback;

                                    $elements_container.find("ul").fadeOut(animationTime, callback);
                                    break;

                                default:
                                    $elements_container.find("ul").hide();
                                    break;
                            }

                            config.get("list").onHideListEvent();

                        })
                        .on("selectElement.eac", function() {
                            $elements_container.find("ul li").removeClass("selected");
                            $elements_container.find("ul li").eq(selectedElement).addClass("selected");

                            config.get("list").onSelectItemEvent();
                        })
                        .on("loadElements.eac", function(event, listBuilders, phrase) {


                            var $item = "",
                                $listContainer = $elements_container.find("ul");

                            $listContainer
                                .empty()
                                .detach();

                            elementsList = [];
                            var counter = 0;
                            for(var builderIndex = 0, listBuildersLength = listBuilders.length; builderIndex < listBuildersLength; builderIndex += 1) {

                                var listData = listBuilders[builderIndex].data;

                                if (listData.length === 0) {
                                    continue;
                                }

                                if (listBuilders[builderIndex].header !== undefined && listBuilders[builderIndex].header.length > 0) {
                                    $listContainer.append("<div class='eac-category' >" + listBuilders[builderIndex].header + "</div>");
                                }

                                for(var i = 0, listDataLength = listData.length; i < listDataLength && counter < listBuilders[builderIndex].maxListSize; i += 1) {
                                    $item = $("<li><div class='eac-item'></div></li>");


                                    (function() {
                                        var j = i,
                                            itemCounter = counter,
                                            elementsValue = listBuilders[builderIndex].getValue(listData[j]);

                                        $item.find(" > div")
                                            .on("click", function() {

                                                $field.val(elementsValue).trigger("change");

                                                selectedElement = itemCounter;
                                                selectElement(itemCounter);

                                                config.get("list").onClickEvent();
                                                config.get("list").onChooseEvent();
                                            })
                                            .mouseover(function() {

                                                selectedElement = itemCounter;
                                                selectElement(itemCounter);

                                                config.get("list").onMouseOverEvent();
                                            })
                                            .mouseout(function() {
                                                config.get("list").onMouseOutEvent();
                                            })
                                            .html(template.build(highlight(elementsValue, phrase), listData[j]));
                                    })();

                                    $listContainer.append($item);
                                    elementsList.push(listData[i]);
                                    counter += 1;
                                }
                            }

                            $elements_container.append($listContainer);

                            config.get("list").onLoadEvent();
                        });

                })();

                $field.after($elements_container);
            }

            function removeContainer() {
                $field.next("." + consts.getValue("CONTAINER_CLASS")).remove();
            }

            function highlight(string, phrase) {

                if(config.get("highlightPhrase") && phrase !== "") {
                    return highlightPhrase(string, phrase);
                } else {
                    return string;
                }

            }

            function escapeRegExp(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }

            function highlightPhrase(string, phrase) {
                var escapedPhrase = escapeRegExp(phrase);
                return (string + "").replace(new RegExp("(" + escapedPhrase + ")", "gi") , "<b>$1</b>");
            }



        }
        function getContainerId() {

            var elementId = $field.attr("id");

            elementId = consts.getValue("CONTAINER_ID") + elementId;

            return elementId;
        }
        function bindEvents() {

            bindAllEvents();


            function bindAllEvents() {
                if (checkParam("autocompleteOff", true)) {
                    removeAutocomplete();
                }

                bindFocusOut();
                bindKeyup();
                bindKeydown();
                bindKeypress();
                bindFocus();
                bindBlur();
            }

            function bindFocusOut() {
                $field.focusout(function () {

                    var fieldValue = $field.val(),
                        phrase;

                    if (!config.get("list").match.caseSensitive) {
                        fieldValue = fieldValue.toLowerCase();
                    }

                    for (var i = 0, length = elementsList.length; i < length; i += 1) {

                        phrase = config.get("getValue")(elementsList[i]);
                        if (!config.get("list").match.caseSensitive) {
                            phrase = phrase.toLowerCase();
                        }

                        if (phrase === fieldValue) {
                            selectedElement = i;
                            selectElement(selectedElement);
                            return;
                        }
                    }
                });
            }

            function bindKeyup() {
                $field
                    .off("keyup")
                    .keyup(function(event) {

                        switch(event.keyCode) {

                            case 27:

                                hideContainer();
                                loseFieldFocus();
                                break;

                            case 38:

                                event.preventDefault();

                                if(elementsList.length > 0 && selectedElement > 0) {

                                    selectedElement -= 1;

                                    $field.val(config.get("getValue")(elementsList[selectedElement]));

                                    selectElement(selectedElement);

                                }
                                break;

                            case 40:

                                event.preventDefault();

                                if(elementsList.length > 0 && selectedElement < elementsList.length - 1) {

                                    selectedElement += 1;

                                    $field.val(config.get("getValue")(elementsList[selectedElement]));

                                    selectElement(selectedElement);

                                }

                                break;

                            default:

                                if (event.keyCode > 40 || event.keyCode === 8) {

                                    var inputPhrase = $field.val();

                                    if (!(config.get("list").hideOnEmptyPhrase === true && event.keyCode === 8 && inputPhrase === "")) {

                                        if (config.get("requestDelay") > 0) {
                                            if (requestDelayTimeoutId !== undefined) {
                                                clearTimeout(requestDelayTimeoutId);
                                            }

                                            requestDelayTimeoutId = setTimeout(function () { loadData(inputPhrase);}, config.get("requestDelay"));
                                        } else {
                                            loadData(inputPhrase);
                                        }

                                    } else {
                                        hideContainer();
                                    }

                                }


                                break;
                        }


                        function loadData(inputPhrase) {


                            if (inputPhrase.length < config.get("minCharNumber")) {
                                return;
                            }


                            if (config.get("data") !== "list-required") {

                                var data = config.get("data");

                                var listBuilders = listBuilderService.init(data);

                                listBuilders = listBuilderService.updateCategories(listBuilders, data);

                                listBuilders = listBuilderService.processData(listBuilders, inputPhrase);

                                loadElements(listBuilders, inputPhrase);

                                if ($field.parent().find("li").length > 0) {
                                    showContainer();
                                } else {
                                    hideContainer();
                                }

                            }

                            var settings = createAjaxSettings();

                            if (settings.url === undefined || settings.url === "") {
                                settings.url = config.get("url");
                            }

                            if (settings.dataType === undefined || settings.dataType === "") {
                                settings.dataType = config.get("dataType");
                            }


                            if (settings.url !== undefined && settings.url !== "list-required") {

                                settings.url = settings.url(inputPhrase);

                                settings.data = config.get("preparePostData")(settings.data, inputPhrase);

                                $.ajax(settings)
                                    .done(function(data) {
                                        if (!data[0] && data.content) {
                                            data = data.content;
                                        }

                                        var listBuilders = listBuilderService.init(data);

                                        listBuilders = listBuilderService.updateCategories(listBuilders, data);

                                        listBuilders = listBuilderService.convertXml(listBuilders);
                                        if (checkInputPhraseMatchResponse(inputPhrase, data)) {

                                            listBuilders = listBuilderService.processData(listBuilders, inputPhrase);

                                            loadElements(listBuilders, inputPhrase);

                                        }

                                        if (listBuilderService.checkIfDataExists(listBuilders) && $field.parent().find("li").length > 0) {
                                            showContainer();
                                        } else {
                                            hideContainer();
                                        }

                                        config.get("ajaxCallback")();

                                    })
                                    .fail(function() {
                                        logger.warning("Fail to load response data");
                                    })
                                    .always(function() {

                                    });
                            }



                            function createAjaxSettings() {

                                var settings = {},
                                    ajaxSettings = config.get("ajaxSettings") || {};

                                for (var set in ajaxSettings) {
                                    settings[set] = ajaxSettings[set];
                                }

                                return settings;
                            }

                            function checkInputPhraseMatchResponse(inputPhrase, data) {

                                if (config.get("matchResponseProperty") !== false) {
                                    if (typeof config.get("matchResponseProperty") === "string") {
                                        return (data[config.get("matchResponseProperty")] === inputPhrase);
                                    }

                                    if (typeof config.get("matchResponseProperty") === "function") {
                                        return (config.get("matchResponseProperty")(data) === inputPhrase);
                                    }

                                    return true;
                                } else {
                                    return true;
                                }

                            }

                        }


                    });
            }

            function bindKeydown() {
                $field
                    .on("keydown", function(evt) {
                        evt = evt || window.event;
                        var keyCode = evt.keyCode;
                        if (keyCode === 38) {
                            suppressKeypress = true;
                            return false;
                        }
                    })
                    .keydown(function(event) {

                        if (event.keyCode === 13 && selectedElement > -1) {

                            $field.val(config.get("getValue")(elementsList[selectedElement]));

                            config.get("list").onKeyEnterEvent();
                            config.get("list").onChooseEvent();

                            selectedElement = -1;
                            hideContainer();

                            event.preventDefault();
                        }
                    });
            }

            function bindKeypress() {
                $field
                    .off("keypress");
            }

            function bindFocus() {
                $field.focus(function() {

                    if ($field.val() !== "" && elementsList.length > 0) {

                        selectedElement = -1;
                        showContainer();
                    }

                });
            }

            function bindBlur() {
                $field.blur(function() {
                    setTimeout(function() {

                        selectedElement = -1;
                        hideContainer();
                    }, 250);
                });
            }

            function removeAutocomplete() {
                $field.attr("autocomplete","off");
            }

        }

        function showContainer() {
            $container.trigger("show.eac");
        }

        function hideContainer() {
            $container.trigger("hide.eac");
        }

        function selectElement(index) {

            $container.trigger("selectElement.eac", index);
        }

        function loadElements(list, phrase) {
            $container.trigger("loadElements.eac", [list, phrase]);
        }

        function loseFieldFocus() {
            $field.trigger("blur");
        }


    };
    scope.eacHandles = [];

    scope.getHandle = function(id) {
        return scope.eacHandles[id];
    };

    scope.inputHasId = function(input) {

        if($(input).attr("id") !== undefined && $(input).attr("id").length > 0) {
            return true;
        } else {
            return false;
        }

    };

    scope.assignRandomId = function(input) {

        var fieldId = "";

        do {
            fieldId = "eac-" + Math.floor(Math.random() * 10000);
        } while ($("#" + fieldId).length !== 0);

        elementId = scope.consts.getValue("CONTAINER_ID") + fieldId;

        $(input).attr("id", fieldId);

    };

    scope.setHandle = function(handle, id) {
        scope.eacHandles[id] = handle;
    };


    return scope;

})(EasyAutocomplete || {}, Cog.jQuery());

(function($) {

    $.fn.easyAutocomplete = function(options) {

        return this.each(function() {
            var $this = $(this),
                eacHandle = new EasyAutocomplete.main($this, options);

            if (!EasyAutocomplete.inputHasId($this)) {
                EasyAutocomplete.assignRandomId($this);
            }

            eacHandle.init();

            EasyAutocomplete.setHandle(eacHandle, $this.attr("id"));

        });
    };

    $.fn.getSelectedItemIndex = function() {

        var inputId = $(this).attr("id");

        if (inputId !== undefined) {
            return EasyAutocomplete.getHandle(inputId).getSelectedItemIndex();
        }

        return -1;
    };

    $.fn.getItems = function () {

        var inputId = $(this).attr("id");

        if (inputId !== undefined) {
            return EasyAutocomplete.getHandle(inputId).getItems();
        }

        return -1;
    };

    $.fn.getItemData = function(index) {

        var inputId = $(this).attr("id");

        if (inputId !== undefined && index > -1) {
            return EasyAutocomplete.getHandle(inputId).getItemData(index);
        }

        return -1;
    };

    $.fn.getSelectedItemData = function() {

        var inputId = $(this).attr("id");

        if (inputId !== undefined) {
            return EasyAutocomplete.getHandle(inputId).getSelectedItemData();
        }

        return -1;
    };

})(Cog.jQuery());

/**
 * currencyHelper - performs various compound interest rate calculations as well as currency
 *                  formatting and validation.
 */

(function($) {
	"use strict";

	var api = {},
		sharedApi = {};

    /****************************************************************************************************************************************/

    // Aiming to phase-out all of the methods in this section in favor of those in the next.
    
    /**
     * Monthly payment calculator
     * @param L principal
     * @param i interest rate
     * @param n number of months
     */
	sharedApi.calcMonthlyPayments = function(L, i, n) {
		return Math.round(L * (i / 12) / (1 - (1 / Math.pow(1 + (i / 12), n))) * 100) / 100;
	};

    /**
     * Future value calculator
     * @param P monthly payment
     * @param i interest rate
     * @param n compounding frequency (interest per time unit)
     */
    sharedApi.calcFutureValue = function(P, i, n) {
        return Math.round(P * (1 - (1 / Math.pow(1 + (i / 12), n))) / (i / 12) * 100) / 100;
    };

	/**
	 * Lump future value calculator
	 * @param P present value
	 * @param i interest rate
	 * @param n compounding frequency (interest per time unit)
	 * @param t time
	 */
	sharedApi.calcLumpFutureValue = function(P, i, n, t) {
		return Math.round(P * Math.pow(1 + (i / 12), n * t));
	};

    /**
     * Present Value calculator for Annuities
     * @param rate - The interest rate per period.
     * @param nper - The total number of payment periods.
     * @param pmt - The payment made each period. Must be entered as a negative number.
     * @param fv - The future value.
     */
    sharedApi.calcAnnuityPresentValue = function(rate, nper, pmt, fv) {
        var pmt = (typeof pmt !== 'undefined') ?  pmt : 0;
        var fv = (typeof fv !== 'undefined') ?  fv : 0;

        if (nper == 0)
            return(0);

        if (rate == 0) {
            return Math.round(fv + (pmt * nper));
        } else {
            var x = Math.pow(1 + rate, -nper);
            var y = Math.pow(1 + rate, nper);
            return Math.round(( x * ( fv * rate - pmt + y * pmt )) / rate);
        }
    };

    /**
     * Future value calculator for Annuities
     * @param rate - The interest rate per period.
     * @param nper - The total number of payment periods.
     * @param pmt - The payment made each period. Must be entered as a negative number.
     * @param pv - [optional] The present value of future payments. If omitted, assumed to be zero. Must be entered as a negative number.
     */
    sharedApi.calcAnnuityFutureValue = function(rate, nper, pmt, pv) {
        var pmt = (typeof pmt !== 'undefined') ?  pmt : 0;
        var pv = (typeof pv !== 'undefined') ?  pv : 0;

        if(nper == 0)
            return 0;

        if(rate == 0)
            return Math.round(pv + (pmt * nper));
        else{
            var x = Math.pow(1 + rate, nper);
            return Math.round((-pmt + x * pmt + rate * x * pv) / rate);
        }
    };

    /**
     * PMT calculator for Annuities
     * @param rate - The interest rate per period.
     * @param nper - The total number of payment periods.
     * @param pv - [optional] The present value of future payments. If omitted, assumed to be zero. Must be entered as a negative number.
     * @param fv - The future value.
     */

    sharedApi.calcAnnuityPMT = function(rate, nper, pv, fv)
    {
        var pv = (typeof pv !== 'undefined') ?  pv : 0;
        var fv = (typeof fv !== 'undefined') ?  fv : 0;

        //if (nper == 0)
          //  return 0;

        if ( rate == 0 ) {
            return Math.round((fv + pv)/nper);
        } else {
            var x = Math.pow(1 + rate,nper);
            return (rate * (fv + x * pv))/(-1 + x);
        }
    };

    /****************************************************************************************************************************************/

    /* I have renamed the following methods to allow for all future calculations to use these functions, without the 'Annuity' keyword
       The intention is to replace all methods above with these.
    */
    
    /**
     * Present Value calculator for Annuities
     * @param rate - The interest rate per period.
     * @param nper - The total number of payment periods.
     * @param pmt - The payment made each period.
     * @param fv - The future value.
     */
    sharedApi.calculatePresentValue = function(rate, nper, pmt, fv) {
        var _pmt = (typeof pmt !== 'undefined') ?  pmt : 0;
        var _fv = (typeof fv !== 'undefined') ?  fv : 0;

        if (nper == 0)
            return(0);

        if (rate == 0) {
            return Math.round(fv + (_pmt * nper));
        } else {
            var x = Math.pow(1 + rate, -nper);
            var y = Math.pow(1 + rate, nper);
            return ( x * ( _fv * rate - _pmt + y * _pmt )) / rate;
        }
    };

    /**
     * Future value calculator for Annuities
     * @param rate - The interest rate per period.
     * @param nper - The total number of payment periods.
     * @param pmt - The payment made each period. Must be entered as a negative number.
     * @param pv - [optional] The present value of future payments. If omitted, assumed to be zero. Must be entered as a negative number.
     */
    sharedApi.calculateFutureValue = function(rate, nper, pmt, pv) {
        var _pmt = (typeof pmt !== 'undefined') ?  pmt : 0;
        var _pv = (typeof pv !== 'undefined') ?  pv : 0;

        if(nper == 0)
            return 0;

        if(rate == 0)
            return Math.round(pv + (_pmt * nper));
        else{
            var x = Math.pow(1 + rate, nper);
            return (-_pmt + x * _pmt + rate * x * _pv) / rate;
        }
    };
    
    /**
     * PMT calculator for Annuities
     * @param rate - The interest rate per period.
     * @param nper - The total number of payment periods.
     * @param pv - The present value of future payments. If omitted, assumed to be zero. Must be entered as a negative number.
     * @param fv - [optional] The future value.
     * @param type - [optional] 0 payment made at end of period, 1 payment made at start of period
     */    
    sharedApi.calculatePMT = function(rate, nper, pv, fv, type)
    {
        var _pv = (typeof pv !== 'undefined') ?  pv : 0;
        var _fv = (typeof fv !== 'undefined') ?  fv : 0;
        var _type = (typeof type !== 'undefined') ?  type : 0;

        if ( rate == 0 ) {
            return Math.round( -(_fv + _pv) / nper);
        } else {
            var x = Math.pow(1 + rate,nper);
            return -(rate * (_fv + x * _pv)) / ((-1 + x) * (1 + rate * _type));
        }
    };

/****************************************************************************************************************************************/    
    
	/**
	 * Number to Currency formatter
	 * @param number unformatted numeric value
	 * @param decimal boolean to toggle decimals
	 */
	sharedApi.numberToCurrency = function(number, decimals) {

		var str = String(number),
 			num = null,
		    dec = null;

		if (str.indexOf('.') != -1){

			num = str.substring(0, str.indexOf('.'));
			dec = str.substring(str.indexOf('.'), str.length);
			if (dec.length < 3){
				dec += '0';
			}
		}else{
			num = str;
			dec = ".00";
		}

		for (var c = num.length; c > 0; c--){
			if ((num.length - c + 1) % 4 === 0 && c != num.length){
				num = [num.slice(0, c), ',', num.slice(c)].join('');
			}
		}

		if (decimals){
			return num + dec;
		}else{
			return num;
		}
	};

	/**
	 * Currency to number formatter
	 * @param currencyString formatted string value
	 */
	sharedApi.currencyToNumber = function(currencyString) {
		var str = currencyString.replace(/,/g, '');
		return parseFloat(str);
	};

	/**
	 * Currency string validator
	 * @param value input string value
	 * @param max maximum length of string
	 */
	sharedApi.currencyValidate = function(value, max) {
		var re = new RegExp("^[0-9\,]{1," + max + "}$");
		return re.test(value);
	};

	/**
	 * Currency string formatter
	 * @param value input string value
	 * @param max maximum length of string
	 */
	sharedApi.currencyFormat = function(value, max) {
		value = value.replace(/[^0-9\,]+/g, '');
		//value = value.replace(/[0]/, '');
		value = value.substring(0, max);
		return value;
	};

	/**
	 * Decimal string validator
	 * @param value input string value
	 */
	sharedApi.decimalValidate = function(value) {
		var re = new RegExp("^[0-9]{0,2}[\.\,]?[0-9]{0,2}?$");
		return re.test(value);
	};

	/**
	 * Decimal string formatter
	 * @param value input string value
	 */
	sharedApi.decimalFormat = function(value) {
		if (value.indexOf(',') != -1){
			value = value.replace(',', '.');
			value = value.replace(/\,/g, '');
		}

		return value;
	};

    /**
     * Maps a value within a specified range to a percentage
     * @param amount value to map
     * @param start beginning of range
     * @param end end of range
     */
    sharedApi.mapRangePercentage = function(amount, start, end){
		if (end == start){
			return 0;
		}
        return ((amount - start) / (end - start)) * 100;
    }

    sharedApi.maxLength = function(amount){
        return amount.length + Math.floor((Math.max(amount.length-1, 0)) / 3);
    }

	Cog.registerStatic({
		name: "utils.currencyHelper",
		api: api,
		sharedApi: sharedApi
	});
})(Cog.jQuery());

/**
 * calculatorHelper - various helper methods shared across all calculators
 */

(function($) {
	"use strict";

	var api = {},
		sharedApi = {},
        currencyHelper = null;

    var bindingMap = {
        'currency': bindCurrency,
        'numeric': bindNumeric
    };

    /**
     * Binds inputs to model fields
     * @param type Type of input to bind (currency, numeric, range, etc.)
     * @param event Type of event to listen for
     * @param inputs An array of inputs
     * @param model The model with associated fields
     * @param callback Function to run once inputs are bound
     */
	sharedApi.bindInputs = function(type, event, inputs, model, callback) {
        // Set callback to empty function if not supplied
        callback = callback || function(){};
        bindingMap[type](event, inputs, model, callback);
	};

    /**
     * Binds model fields to outputs
     * @param outputs An array of outputs
     * @param model The model with associated fields
     */
	sharedApi.bindOutputs = function(outputs, model) {
         _.forEach(outputs, function(output, key) {
             var result = model[key];
             if (result < 0) {
                 result = 0;
             }
             output.html(
                 currencyHelper.numberToCurrency(result, false)
             );
         });
	};

    // Private input binder methods
    function bindCurrency(event, inputs, model, callback) {

        _.forEach(inputs, function(input, key) {
            switch(event){
                case 'input':
                    input.on(event, function () {
                        var $this = $(this);

                        var value = $this.val();
                        var max = $this.attr('max');
                        var min = $this.attr('min');
                        var maxLen = max.length;

                        if (parseInt(value) > parseInt(max)) {
                            value = max;
                            $this.parent().addClass('error');
                        } else if(parseInt(value) < parseInt(min)){
                            value = min;
                            $this.parent().addClass('error');
                        } else {
                            $this.parent().removeClass('error');
                        }

                        if (currencyHelper.currencyValidate(value, maxLen) === true) {
                            if (value !== 0 || value != '') {
                                value = currencyHelper.currencyToNumber(value);
                                model[key] = value;
                            } else {
                                model[key] = 0;
                            }
                        } else {

                            value = currencyHelper.currencyFormat(value, maxLen);
                            $this.val(value);

                            // Added this to zero many of the calculations
                            model[key] = 0;
                        }
                        
                        callback(input);
                    });
                    break;

                case 'focusin':
                    input.on(event, function () {
                        var $this = $(this);
                        var value = $this.val();
                        var max = $this.attr('max');

                        value = currencyHelper.currencyToNumber(value);
                        //var maxLen = max.length;

                        if (currencyHelper.currencyValidate(value, max) === true) {
                            $this.val(value);
                        }
                    });
                    break;

                case 'focusout':
                     input.on(event, function () {
                        var $this = $(this);
                        var value = $this.val();
                        var max = $this.attr('max');

                         if (currencyHelper.currencyValidate(value, max) === true) {
                            value = currencyHelper.numberToCurrency(model[key], false);
                            $this.val(value);
                        }
                        $this.parent().removeClass('error');
                    });
                    break;
            }
        });
    }

    function bindNumeric(event, inputs, model, callback) {
        _.forEach(inputs, function(input, key) {
            switch(event){

                case 'input':
                    input.on(event, function () {
                        var $this = $(this);
                        var value = $this.val();
                        var max = $this.attr('max');
                        var min = $this.attr('min');
                        var num = parseFloat(value);

                        if (num > max) {
                            num = max;
                            $this.parent().addClass('error');
                        } else if(num < min){
                            num = min;
                            $this.parent().addClass('error');
                        } else {
                            $this.parent().removeClass('error');
                        }

                        if (value !== 0 && value !== '') {
                            if (currencyHelper.decimalValidate(value)) {
                                model[key] = num;
                            } else {
                                value = currencyHelper.currencyFormat(value, max);
                                $this.val(value);
                            }
                        } else {
                            model[key] = 0;
                        }
                        callback();
                    });
                    break;

                case 'focusout':
                    input.on(event, function () {
                        var $this = $(this);
                        var value = $this.val();
                        var max = $this.attr('max');

                        if (value !== 0) { // jshint ignore:line
                            var num = parseFloat(model[key]);

                            value = num.toFixed(2);
                            model[key] = value;
                            $this.val(value);
                        }
                        $this.parent().removeClass('error');
                    });
                    break;
            }
        });
    }

    api.init = function ($scope) {
        currencyHelper = this.external.currencyHelper;
    };

	Cog.registerStatic({
		name: "utils.calculatorHelper",
		api: api,
		sharedApi: sharedApi,
        requires: [{
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }]
	});
})(Cog.jQuery());

/**
 * Utils - Loader
 * Loading indicator
 */

(function($) {
    'use strict';

    var api = {};

    function Loader() {
        this.create();
        this.attachEvents();
    }

    Loader.prototype.animate = function(progress) {
        this.show();
        this.$loader.css('width', progress * 100 + '%');
        if (progress === 1) {
            _.delay(function() {
                this.hide();
            }.bind(this), 750);
        }
    };

    Loader.prototype.create = function() {
        this.$loader = $('<div class="loading-indicator is-hidden" />');
        this.$loader.appendTo($('body'));
    };

    Loader.prototype.show = function() {
        this.$loader.removeClass('is-hidden');
    };

    Loader.prototype.hide = function() {
        this.$loader.addClass('is-hidden');
    };

    Loader.prototype.attachEvents = function() {
        Cog.addListener('loader', 'change', function (data) {
            this.animate(data.eventData);
        }.bind(this));
    };

    api.init = function() {
        $(document).ready(function() {
            if ($('.loading-indicator').length < 1) {
                new Loader();
            }
        });
    };

    Cog.registerStatic({
        name: 'utils.loader',
        api: api
    });
})(Cog.jQuery());
(function ($) {
    'use strict';

    var api = {},
        $window = $(window),
        sharedApi = {
            isForceReload: false
        };

    sharedApi.isSupported = !!(window.history && history.pushState);

    sharedApi.push = function (state, title, url) {
        history.pushState(state, title, url);
    };

    sharedApi.replace = function (state, title, url) {
        if (url) {
            history.replaceState(state, title, url);
        }
    };

    sharedApi.onpopstate = function (fn) {
        sharedApi.isForceReload = true;

        return $window.on('popstate', function (e) {
            fn(e);
        });
    };

    $window.on('popstate', function (e) {
        if (!sharedApi.isForceReload && e.originalEvent.state) {
            window.location.reload();
        }
    });

    Cog.registerStatic({
        name: 'utils.history',
        api: api,
        sharedApi: sharedApi
    });

})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {},
        sharedApi = {};

    sharedApi.toggle = function ($element, isHidden) {
        $element.attr('aria-hidden', isHidden);

        if (!isHidden) {
            $element.attr('aria-live', 'polite');
        }
    };

    Cog.registerStatic({
        name: 'utils.screenReader',
        api: api,
        sharedApi: sharedApi
    });

})(Cog.jQuery());

/**
 * Accordion
 */

/* global Modernizr */

(function($) {
    'use strict';

    var api = {
            accordions: []
        },
        refs = {
            showHideContentList: '.accordion-content-wrapper'
        },
        isMobile = checkMobile();

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    function isBlackBerry() {
        return !!navigator.userAgent.match(/BlackBerry|BB|PlayBook/i);
    }

    function Accordion($el) {
        this.$el = $el;
        this.$container = this.$el.find('.accordion-container');
        this.$slides = this.$container.children();
        this.$heads = this.$slides.children('.accordion-head');
        this.$headsArrow = this.$heads.append('<div class="accordion-arrow"></div>');
        this.hasDesktopOption = false;
        this.recountHeight = false;
        this.isAccordionMenu = $el.hasClass('accordion-menu');
        this.hasAutoCollapse = $el.hasClass('accordion-auto-collapse');
        this.accordionMenu = this.$el.hasClass('accordion-menu');

        if (this.$el.hasClass('accordion-faq') || this.$el.hasClass('accordion-mosaic') || this.accordionMenu ||
            $el.hasClass('accordion-menu-redesigned')) {
            this.hasDesktopOption = true;
        }

        if ($(this.$el).hasClass('accordion-contact') ||
            $(this.$el).hasClass('accordion-basic') || $(this.$el).hasClass('accordion-faq') ||
            $(this.$el).hasClass('accordion-mosaic')) {
            this.recountHeight = true;
        }

        if (this.hasDesktopOption) {
            this.handleDesktopHeaders();
            this.$desktopHeaders = this.$el.find('.js-desktop-headers .accordion-head');
        }

        if (this.$slides.hasClass('is-active') &&
            !this.$el.hasClass('accordion-faq') &&
            !this.$el.hasClass('accordion-mosaic')) {
            this.$slides.removeClass('is-active');
        }

        this.bindUIEvents();
    }

    Accordion.prototype.bindUIEvents = function() {
        var hasDesktopOption = this.hasDesktopOption,
            $desktopHeaders = this.$desktopHeaders,
            $activeSlide = this.$slides.filter('.is-active'),
            $desktopArrow = this.$el.find('.js-desktop-slide-arrow'),
            root = this;

        function checkPage() {

            if ($('body').hasClass('page-talk-to-us')) {

                $('.accordion-slide').find('.contactInfo').each(function() {
                    var columns = $(this).find('.col'),
                        columnHeadings = columns.find('h6').text(),
                        splitToken = ':',
                        splitHeading = columnHeadings.split(splitToken),
                        tel = null,
                        email = null,
                        address = null,
                        hours = null,
                        product = null;

                    $(splitHeading).each(function(i) {

                        if (splitHeading[i] == 'TELEPHONE') {
                            tel = columns[i];
                            $(tel).addClass('telephone');
                        } else if (splitHeading[i] == 'EMAIL ADDRESS') {
                            email = columns[i];
                            $(email).addClass('email');
                        } else if (splitHeading[i] == 'ADDRESS') {
                            address = columns[i];
                            $(address).addClass('address');
                        } else if (splitHeading[i] == 'HOURS') {
                            hours = columns[i];
                            $(hours).addClass('hours');
                        } else if (splitHeading[i] == 'PRODUCT') {
                            product = columns[i];
                            $(product).addClass('product');
                        }
                    });
                });

                $('.accordion-content').each(function() {
                    var contactInfo = $(this).find('.contactInfo');

                    contactInfo.each(function() {
                        var tel = $(this).find('.telephone'),
                            tel_h = tel.height(),
                            hours = $(this).find('.hours'),
                            hrs_h = hours.height(),
                            address = $(this).find('.address'),
                            ads_h = address.height(),
                            email = $(this).find('.email'),
                            eml_h = email.height(),
                            content = $(this).find('.content');


                        if (ads_h > hrs_h) {
                            content.css('height', ads_h + 30);
                        } else if (tel_h == hrs_h) {
                            content.css('height', tel_h + 30);
                        } else if (ads_h > hrs_h) {
                            content.css('height', ads_h + 30);
                        } else if (eml_h == tel_h) {
                            content.css('height', eml_h + 30);
                        } else if (ads_h > tel_h) {
                            content.css('height', ads_h + 30);
                        } else if (hrs_h > tel_h) {
                            content.css('height', hrs_h + 30);
                        } else {
                            content.css('height', tel_h + 30);
                        }

                        if (hrs_h > tel_h && ads_h > hrs_h) {
                            content.css('height', ads_h + 30);
                        } else if (hrs_h > tel_h) {
                            content.css('height', hrs_h + 30);
                        }
                    });
                });
            }
        }

        function getMarkerId($slide) {
            var id = $slide.find('.accordion-head').attr('id');

            return id ? id.replace('marker-', '') : null;
        }

        checkPage();

        function setActiveDesktopHeader(activeIndex, inactiveIndex) {
            $desktopHeaders.eq(inactiveIndex).removeClass('is-active');
            $desktopHeaders.eq(activeIndex).addClass('is-active');
            manageDesktopArrowPosition();
        }

        function manageDesktopArrowPosition() {
            var $active = $desktopHeaders.filter('.is-active');
            var $activeTop = $active.position().top;

            if ($active.length && $active.is(':visible')) {
                $desktopArrow.css('top', $activeTop + $active.height() / 2);

                if (root.$el.is('.accordion-faq')) {
                    $activeSlide.css('margin-top', $activeTop - 45);
                }
            }
        }

        function hide($slide, silent) {
            var $content = $slide.children(refs.showHideContentList);

            $content.css('max-height', 0);

            if (Modernizr.csstransitions && !isBlackBerry()) {
                $content.one('transitionend', _.debounce(function() {
                    $slide.removeClass('is-active');
                }, 1));
            } else {
                $slide.removeClass('is-active');
            }

            if (!silent) {
                Cog.fireEvent('accordion', 'closeSlide', {
                    id: getMarkerId($slide)
                });
            }
        }

        function resizeAccordionItems($items) {
            function resize() {
                _.each($items, function(accordionItem) {
                    var $item = $(accordionItem),
                        height = $item[0].scrollHeight;

                    $item.css('max-height', height);
                });
            }

            _.defer(resize);
        }

        function show($slide, silent) {
            var $inactivateSlide = $slide.siblings('.is-active'),
                $showContent = $slide.children(refs.showHideContentList);

            if ($slide.length === 0) {
                return null;
            }

            if (Modernizr.csstransitions) {
                $showContent.off('transitionend');
            }

            if (hasDesktopOption) {
                setActiveDesktopHeader($slide.index(), $inactivateSlide.index());
            }

            $slide.addClass('is-active');
            resizeAccordionItems($showContent);


            if ($inactivateSlide.length === 0) {
                $slide.addClass('is-animated');
            }

            if (hasDesktopOption && !isMobile) {
                $inactivateSlide.removeClass('is-active');
                Cog.fireEvent('accordionMenu', 'changedSlide');
            }

            if (!silent) {
                Cog.fireEvent('accordion', 'openSlide', {
                    id: getMarkerId($slide)
                });
            }
        }

        function showFirst() {
            var $active = root.$slides.filter('.is-active');

            if ($active.length !== 1 && !isMobile && hasDesktopOption) {
                $desktopHeaders.removeClass('is-active');
                show($(root.$slides[0]));
            }
        }

        function onHeaderClick() {
            /*jshint validthis:true */

            var $header = $(this),
                $slide = $header.parent();

            if ($slide.hasClass('is-active')) {
                if (!hasDesktopOption || isMobile) {
                    hide($slide);
                }
            } else {
                if (root.hasAutoCollapse) {
                    hide($slide.siblings('.is-active'));
                }

                show($slide);
            }

            if (root.isAccordionMenu) {
                Cog.fireEvent('accordion-menu', 'accordionToggle');
            }
        }

        Cog.addListener('mapCustom', 'openMarker', function(e) {
            var $slide = $('#' + e.eventData.id).parent();
            show($slide, true);
        }.bind(this));

        Cog.addListener('mapCustom', 'closeMarker', function(e) {
            var $slide = $('#' + e.eventData.id).parent();
            hide($slide, true);
        }.bind(this));

        Cog.addListener('tabsMenu', 'tabsChanged', function() {
            if (hasDesktopOption) {
                manageDesktopArrowPosition();
            }
        });

        Cog.addListener('comparisonTable', 'heightChanged', function() {
            var $slide = this.$slides.filter('.is-active');

            show($slide, true);
        }.bind(this));

        Cog.addListener('tab', 'change', function(data) {
            var activeSlides = this.$slides.filter('.is-active'),
                $slides = data.eventData.container.find(activeSlides);

            if ($slides.length) {
                show($slides, true);
            }

        }.bind(this));

        this.$container.on('click', '.accordion-head', onHeaderClick);
        this.$container.on('click', '.accordion-head > .accordion-title', function(e) {
            e.preventDefault();
        });

        if (hasDesktopOption) {
            $(window).on('resize', _.debounce(manageDesktopArrowPosition, 300));
        }

        $(window).on('resize', _.debounce(function() {
            isMobile = checkMobile();
            if (hasDesktopOption) {
                showFirst();
            }

            if (this.recountHeight) {
                show(this.$slides.filter('.is-active'), true);
            }
        }.bind(this), 300));

        //manage with default opened slide
        if ($activeSlide.length) {
            $activeSlide.removeClass('is-active');
            $activeSlide.find('.accordion-head').trigger('click');
        }
    };

    Accordion.prototype.handleDesktopHeaders = function() {
        var $desktopHeaders = $('<div class="js-desktop-headers"/>'),
            $title = this.$el.closest('.box-faq').find('.richText-faq-title');

        _.forEach(this.$heads, function(item) {
            var $currentHead = $(item),
                $headerClone = $currentHead.clone(false);

            $desktopHeaders.append($headerClone);
            $headerClone.on('click', function(e) {
                $currentHead.trigger('click');
                e.stopImmediatePropagation();
                e.preventDefault();
            });
        });

        if ($title.length) {
            $desktopHeaders.prepend($title.clone(false));
        }

        $desktopHeaders.append('<div class="js-desktop-slide-arrow"/>');

        this.$container.before($desktopHeaders);

        _.defer(function() {
            Cog.fireEvent('accordionMenu', 'headersReady', {
                $desktopHeaders: $desktopHeaders,
                $icons: this.$slides.find('.image-icon-in-accordion-menu-header img')
            });
        }.bind(this), 0);
    };

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        api.accordions.push(new Accordion($el));
    };

    Cog.registerComponent({
        name: 'accordion',
        api: api,
        selector: '.accordion:not(.accordionExtended)'
    });
})(Cog.jQuery());


/**
 * Accordion Extended
 */

(function($) {
    'use strict';

    var api = {
            accordions: []
        },
        refs = {
            showHideContentList: '.accordion-content-wrapper'
        },
        isMobile = checkMobile();

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    function isBlackBerry() {
        return !!navigator.userAgent.match(/BlackBerry|BB|PlayBook/i);
    }

    function Accordion($el) {
        this.$el = $el;
        this.$container = this.$el.find('.accordion-container');
        this.$slides = this.$container.children();
        this.$heads = this.$slides.children('.accordion-head');
        this.hasDesktopOption = false;
        this.recountHeight = false;
        this.isAccordionMenu = $el.hasClass('accordion-menu');
        this.hasAutoCollapse = $el.hasClass('accordion-auto-collapse');

        this.accordionMenu = this.$el.hasClass('accordion-menu');
        if (this.$el.hasClass('accordion-faq') || this.accordionMenu || this.$el.hasClass('accordion-mosaic') ||
            this.$el.hasClass('accordion-menu-redesigned')) {
            this.hasDesktopOption = true;
        }

        if ((this.$el).hasClass('accordion-contact') ||
            $(this.$el).hasClass('accordion-basic') || $(this.$el).hasClass('accordion-faq') ||
            $(this.$el).hasClass('accordion-mosaic')) {
            this.recountHeight = true;
        }

        if (this.hasDesktopOption) {
            this.handleDesktopHeaders();
            this.$desktopHeaders = this.$el.find('.js-desktop-headers .accordion-head');
        }

        this.bindUIEvents();
    }

    Accordion.prototype.bindUIEvents = function() {
        var hasDesktopOption = this.hasDesktopOption,
            $desktopHeaders = this.$desktopHeaders,
            $activeSlide = this.$slides.filter('.is-active'),
            $desktopArrow = this.$el.find('.js-desktop-slide-arrow'),
            root = this;

        function getMarkerId($slide) {
            var id = $slide.find('.accordion-head').attr('id');

            return id ? id.replace('marker-', '') : null;
        }

        function setActiveDesktopHeader(activeIndex, inactiveIndex) {
            $desktopHeaders.eq(inactiveIndex).removeClass('is-active');
            $desktopHeaders.eq(activeIndex).addClass('is-active');

            manageDesktopArrowPosition();
        }

        function manageDesktopArrowPosition() {
            var $active = $desktopHeaders.filter('.is-active');

            if ($active.length && $active.is(':visible')) {
                $desktopArrow.css('top', $active.position().top + $active.height() / 2);
            }
        }

        function hide($slide, silent) {
            var $content = $slide.children(refs.showHideContentList);

            $content.css('max-height', 0);

            if (Modernizr.csstransitions && !isBlackBerry()) {
                $content.one('transitionend', _.debounce(function() {
                    $slide.removeClass('is-active');
                }, 1));
            } else {
                $slide.removeClass('is-active');
            }

            if (!silent) {
                Cog.fireEvent('accordionExtended', 'closeSlide', {
                    id: getMarkerId($slide)
                });
            }
        }

        function resizeAccordionItems($items) {
            function resize() {
                _.each($items, function(accordionItem) {
                    var $item = $(accordionItem),
                        height = $item[0].scrollHeight;

                    $item.css('max-height', height);
                });
            }

            _.defer(resize);
        }

        function show($slide, silent) {
            var $inactivateSlide = $slide.siblings('.is-active'),
                $showContent = $slide.children(refs.showHideContentList);

            if ($slide.length === 0) {
                return null;
            }

            if (Modernizr.csstransitions) {
                $showContent.off('transitionend');
            }

            if (hasDesktopOption) {
                setActiveDesktopHeader($slide.index(), $inactivateSlide.index());
            }

            $slide.addClass('is-active');
            resizeAccordionItems($showContent);


            if ($inactivateSlide.length === 0) {
                $slide.addClass('is-animated');
            }

            if (hasDesktopOption && !isMobile) {
                $inactivateSlide.removeClass('is-active');
                Cog.fireEvent('accordionMenu', 'changedSlide');
            }

            if (!silent) {
                Cog.fireEvent('accordionExtended', 'openSlide', {
                    id: getMarkerId($slide)
                });
            }

            if ($slide.closest('.accordionExtended').hasClass('accordion-menu-redesigned')) {
                $('body').addClass('box-menu-is-active');
                $('html').addClass('no-scroll');
            }
        }

        function showFirst() {
            var $active = root.$slides.filter('.is-active');

            if ($active.length !== 1 && !isMobile && hasDesktopOption) {
                $desktopHeaders.removeClass('is-active');
                show($(root.$slides[0]));
            }
        }

        function onHeaderClick() {
            /*jshint validthis:true */

            var $header = $(this),
                $slide = $header.parent();

            if ($slide.hasClass('is-active')) {
                if (!hasDesktopOption || isMobile) {
                    hide($slide);
                }
            } else {
                if (root.hasAutoCollapse) {
                    hide($slide.siblings('.is-active'));
                }

                show($slide);
            }

            if (root.isAccordionMenu) {
                Cog.fireEvent('accordion-menu', 'accordionToggle');
            }
        }

        Cog.addListener('mapCustom', 'openMarker', function(e) {
            var $slide = $('#' + e.eventData.id).parent();
            show($slide, true);
        }.bind(this));

        Cog.addListener('mapCustom', 'closeMarker', function(e) {
            var $slide = $('#' + e.eventData.id).parent();
            hide($slide, true);
        }.bind(this));

        Cog.addListener('tabsMenu', 'tabsChanged', function() {
            if (hasDesktopOption) {
                manageDesktopArrowPosition();
            }
        });

        Cog.addListener('comparisonTable', 'heightChanged', function() {
            var $slide = this.$slides.filter('.is-active');

            show($slide, true);
        }.bind(this));

        Cog.addListener('tab', 'change', function(data) {
            var activeSlides = this.$slides.filter('.is-active'),
                $slides = data.eventData.container.find(activeSlides);

            if ($slides.length) {
                show($slides, true);
            }

        }.bind(this));

        this.$container.on('click', '.accordion-head', onHeaderClick);
        this.$container.on('click', '.accordion-head > .accordion-title', function(e) {
            e.preventDefault();
        });

        if (hasDesktopOption) {
            $(window).on('resize', _.debounce(manageDesktopArrowPosition, 300));
        }

        $(window).on('resize', _.debounce(function() {
            isMobile = checkMobile();

            if (hasDesktopOption && !this.$el.hasClass('accordion-menu-redesigned')) {
                showFirst();
            }
            if (this.recountHeight) {
                show(this.$slides.filter('.is-active'), true);
            }
        }.bind(this), 300));

        //manage with default opened slide
        if ($activeSlide.length) {
            $activeSlide.removeClass('is-active');
            $activeSlide.find('.accordion-head').trigger('click');
        }
    };

    Accordion.prototype.handleDesktopHeaders = function() {
        var $desktopHeaders = $('<div class="js-desktop-headers"/>'),
            $title = this.$el.closest('.box-faq').find('.richText-faq-title');

        _.forEach(this.$heads, function(item) {
            var $currentHead = $(item),
                $headerClone = $currentHead.clone(false);

            $desktopHeaders.append($headerClone);
            $headerClone.on('click', function(e) {
                $currentHead.trigger('click');
                e.stopImmediatePropagation();
                e.preventDefault();
            });
        });

        if ($title.length) {
            $desktopHeaders.prepend($title.clone(false));
        }

        $desktopHeaders.append('<div class="js-desktop-slide-arrow"/>');

        this.$container.before($desktopHeaders);

        _.defer(function() {
            Cog.fireEvent('accordionMenu', 'headersReady', {
                $desktopHeaders: $desktopHeaders,
                $icons: this.$slides.find('.image-icon-in-accordion-menu-header img')
            });
        }.bind(this), 0);
    };

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        api.accordions.push(new Accordion($el));
    };

    Cog.registerComponent({
        name: 'accordionExtended',
        api: api,
        selector: '.accordionExtended'
    });
})(Cog.jQuery());


/**
 * Accordion Menu
 */

(function($) {
    'use strict';

    var api = {
            accordions: []
        },
        $headerForAccordionMenu,
        status;

    function AccordionMenu($el) {
        this.$el = $el;
        this.$container = this.$el.find('.accordion-container');
        this.$innerWrapper = this.$container.find('.accordion-content-wrapper');
        this.$slides = this.$container.children();
        this.$heads = this.$slides.children('.accordion-head');
        this.$icons = this.$slides.find('.image-icon-in-accordion-menu-header img');

        this.slideToTop();
        this.attachEvents();
    }

    AccordionMenu.prototype.attachEvents = function() {
        if ($(this.$el).hasClass('accordion-menu-redesigned')) {
            this.addClose();
            $('.close-menu').on('click', this.actionClose.bind(this));

            Cog.addListener('login', 'open', function () {
                this.actionClose();
            }.bind(this));
    
            Cog.addListener('search', 'open', function () {
                this.actionClose();
            }.bind(this));
        } else {
            $(window).on('resize', this.setEqualHeight.bind(this));
        }
    };

    AccordionMenu.prototype.addClose = function() {
        $(this.$innerWrapper).append('<div class=\'close-menu\'></div>');
    };

    AccordionMenu.prototype.actionClose = function() {
        $(this.$el).find('.js-desktop-headers')
            .children('.accordion-head').removeClass('is-active');
        $(this.$el).closest('.accordion-menu-redesigned').find('.accordion-container')
            .children('.accordion-slide').removeClass('is-active is-animated');
        $('body').removeClass('box-menu-is-active');
        $('html').removeClass('no-scroll');
    };

    AccordionMenu.prototype.slideToTop = function() {

        var containerTop = 0,
            boxMenuTop = 0,
            $boxMenu = $('.box-menu');

        var containerTopOffset = $('.box-menu > .component-content').offset();
        var boxMenuOffset = $boxMenu.offset();

        if (containerTopOffset) {
            containerTop = containerTopOffset.top;
        }
        if (boxMenuOffset) {
            boxMenuTop = boxMenuOffset.top;
        }

        $boxMenu.on('scroll resize', function() {
            containerTop = $boxMenu.find('> .component-content').offset().top;
        });

        this.$heads.on('click tap', function() {
            var $parent = $(this).parent();

            Cog.fireEvent('accordionMenuSlide', 'toogleSlide');
            if (!$parent.hasClass('is-active')) {
                _.defer(function() {
                    $boxMenu.animate({
                        scrollTop: $(this).position().top - containerTop + boxMenuTop
                    });
                }.bind(this));
            }
        });
    };

    AccordionMenu.prototype.setEqualHeight = function() {
        var $activeSlide = this.$slides.filter('.is-active'),
            $quickLinks = $activeSlide.find('.box-menu-quick-links'),
            $bankingSolutions = $activeSlide.find('.box-menu-banking-solutions'),
            quickLinksHeight,
            bankingSolutionsHeight;

        $quickLinks.height('');
        $bankingSolutions.height('');
        quickLinksHeight = $quickLinks.height();
        bankingSolutionsHeight = $bankingSolutions.height();

        if (quickLinksHeight > bankingSolutionsHeight) {
            $quickLinks.height(quickLinksHeight);
            $bankingSolutions.height(quickLinksHeight);
        } else {
            $quickLinks.height(bankingSolutionsHeight);
            $bankingSolutions.height(bankingSolutionsHeight);
        }
    };

    AccordionMenu.prototype.prepareAnimation = function() {

        _.forEach(this.$slides, function(slide) {
            var $slide = $(slide),
                $quickLinks = $slide.find('.box-menu-quick-links .richText.last'),
                $bankingSolutions = $slide.find('.box-menu-banking-solutions');

            _.forEach($bankingSolutions, function(item) {
                var $boxBankingSolutions = $(item),
                    $columns = $boxBankingSolutions.find('.box.default-style'),
                    $linksGroups = [
                        $columns.first().find('.box-menu-links-group'),
                        $columns.last().find('.box-menu-links-group')
                    ],
                    $items = [],
                    i = 0,
                    j = 0,
                    k = 0;

                if ($columns.length === 2) {
                    for (i = 0; i < $boxBankingSolutions.find('.box-menu-links-group').length; i++) {
                        k = i % 2;

                        if (k === 1) {
                            $items.push($linksGroups[1][j]);
                            j++;
                        } else {
                            $items.push($linksGroups[0][j]);
                        }
                    }
                } else {
                    $items = $linksGroups[0];
                }

                $items.push($quickLinks);

                _.forEach($items, function(item, index) {
                    $(item).addClass('appear appear-delay-' + index);
                });


            });
        });
    };

    AccordionMenu.prototype.animateContent = function() {
        this.$slides.removeClass('is-animated');

        _.defer(function() {
            this.$slides.filter('.is-active').addClass('is-animated');
        }.bind(this));
    };

    function appendToHeaders($desktopHeaders, $icons) {
        var $accordionHeaders = $('.tabs-menu .js-desktop-headers');

        _.forEach($accordionHeaders, function(accordionHeader) {
            var $accordionHeader = $(accordionHeader),
                $clone;

            if ($accordionHeader.find('.header-for-accordion-menu').length === 0) {
                $clone = $headerForAccordionMenu.first().clone();
                $accordionHeader.prepend($clone);
            }
        });

        _.forEach($desktopHeaders.find('h3 a'), function(item, key) {
            if (!$(item).find('img').length) {
                $(item).prepend($($icons[key]).clone());
            }
        });

        _.forEach($desktopHeaders.siblings('.accordion-container').find('.accordion-head a'), function(item, key) {
            if (!$(item).find('img').length) {
                $(item).prepend($($icons[key]).clone());
            }
        });

    }

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        status = this.external.status;

        $headerForAccordionMenu = $('.header-for-accordion-menu');

        api.accordions.push(new AccordionMenu($el));

        Cog.addListener('accordionMenu', 'headersReady', _.debounce(function(e) {
            if (e.eventData) {
                appendToHeaders(e.eventData.$desktopHeaders, e.eventData.$icons);
            }
        }, 100));

        _.forEach(api.accordions, function(item) {
            item.prepareAnimation();
        });

        Cog.addListener('tabsMenu', 'tabsChanged', function() {
            _.forEach(api.accordions, function(item) {
                item.setEqualHeight();
                item.animateContent();
            });
        });

        Cog.addListener('accordionMenu', 'changedSlide', function() {
            _.forEach(api.accordions, function(item) {
                item.setEqualHeight();
                item.animateContent();
            });
        });
    };

    Cog.registerComponent({
        name: 'accordionMenu',
        api: api,
        selector: '.accordion-menu-redesigned',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }]
    });
})(Cog.jQuery());
/**
 * Advert piece card style
 *
 */

 (function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {},
        status;

    api.advertPiece = [];

    function AdvertPiece($el) {
        if (window.Modernizr.mq('only screen and (max-width: 767px)')) {
            moveMarkup($el);
        }

        setHeights($el);

        if($($el).hasClass('advert-clickable')) {
            addClickEvent($el);
        }
        
        $(window).resize(_.debounce(function() {
            setHeights($el);
        },500));

    }

    function addClickEvent(advertEl) {
        $(advertEl).on('click', function() {
            var gotoLink = $(advertEl).find('[class^=btn-action]').attr('href');
            window.open(gotoLink, '_self');
        });
    }

    function setHeights(element) {
        var showcases = element.find('span[class*=advertPiece-showcase-]'),
        headingHeights = [],
        subCopyHeights = [];
        element.find('.advertPiece-showcase-head').css('height', 'auto');
        element.find('.advertPiece-showcase-subcopy').css('height', 'auto');
        _.forEach(showcases, function (showcase) {
            var heading = $(showcase).find('.advertPiece-showcase-head'),
            subCopy = $(showcase).find('.advertPiece-showcase-subcopy');
            headingHeights.push(heading.outerHeight());
            subCopyHeights.push(subCopy.outerHeight());
        });

        element.find('.advertPiece-showcase-head').css('height', Math.max.apply(Math, headingHeights) + 'px');
        element.find('.advertPiece-showcase-subcopy').css('height', Math.max.apply(Math, subCopyHeights) + 'px');
    }

    function moveMarkup(element) {
        var button = element.find('[class*=btn-action-]').closest('p');
        button.appendTo(element.find('.advertPiece-text-container'));
        button.find('a').addClass('showButton');
    }

    api.onRegister = function (scope) {
        var $advertPieces = scope.$scope;
        status = this.external.status;
        _.forEach($advertPieces, function (advertPiece) {
            var $advertPiece = $(advertPiece);
            api.advertPiece.push(new AdvertPiece($advertPiece));
        });
    };

    Cog.registerComponent({
        name: 'advertPiece',
        api: api,
        selector: '.advertPiece.component',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));
/**
 *  Absa App Mobile Adoption Bar
 *
 */

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {},
        status;

    api.appBar = [];

    function AppBar($el) {
        var mobileOs = getMobileOperatingSystem(),
            visitAmountLimit = $($el).find('.outer-container').attr('data-visible-limit'),
            cooloffPeriod = $($el).find('.outer-container').attr('data-cooloff-period'),
            visitAmountCookie = getCookie('appAdoptionSeen');
        const appLinks = {
            ios: $($el).find('.adoption-button').attr('data-ios-link'),
            harmony: $($el).find('.adoption-button').attr('data-harmony-link'),
            android: $($el).find('.adoption-button').attr('data-android-link'),
            deepLink: $($el).find('.adoption-button').attr('data-deep-link')
        };

        if (status.isMobile() && visitAmountCookie < visitAmountLimit) {
            if (mobileOs == 'android' || mobileOs == 'ios' || mobileOs == 'harmony') {
                $($el).css('display', 'block');
                toggleBarSpace('add');
            }
        }

        $($el).find('.adoption-close').on('click', function () {
            hideBar($el, visitAmountCookie, cooloffPeriod);
        });

        $($el).find('.adoption-button').on('click', function () {
            hideBar($el, visitAmountCookie, cooloffPeriod);
            openDownloadApp(appLinks[mobileOs], appLinks.deepLink);
        });

        $(window).resize(function() {
            if(!status.isMobile()) {
                hideBar($el, visitAmountCookie - 1, cooloffPeriod);
            }
        });
    }

    function openDownloadApp(appLink, deepLink) {
        var now = new Date().valueOf();
        var app = {
            launchApp: function () {
                window.location.replace(deepLink);
                this.timer = setTimeout(this.openWebAppStore, 800);
            },
            openWebAppStore: function () {
                if (new Date().valueOf() - now > 1000) {
                    return;
                }
                window.location = appLink;
            }
        };
        app.launchApp();
    }


    function hideBar($el, visitAmountCookie, cooloffPeriod) {
        toggleBarSpace('remove');
        $($el).css('display', 'none');
        visitAmountCookie++;
        setCookie('appAdoptionSeen', visitAmountCookie, cooloffPeriod);
    }

    function toggleBarSpace(action) {
        if (action == 'add') {
            $('body').addClass('adoption-space');
        } else {
            $('body').removeClass('adoption-space');
        }
    }

    function getMobileOperatingSystem() {
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        // Test Huawei before android otherwise we will never match it
        if (/huawei/i.test(userAgent)) {
            return 'harmony';
        }
        if (/android/i.test(userAgent)) {
            return 'android';
        }

        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            return 'ios';
        }

        return 'na';
    }

    function getCookie(cname) {
        var name = cname + '=';
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return '';
    }

    function setCookie(cname, cvalue, exdays) {
        var d = new Date();
        d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
        var expires = 'expires=' + d.toUTCString();
        document.cookie = cname + '=' + cvalue + ';' + expires + ';path=/';
    }

    api.onRegister = function (scope) {
        status = this.external.status;
        api.appBar.push(new AppBar(scope.$scope));
    };

    Cog.registerComponent({
        name: 'appBar',
        api: api,
        selector: '.appAdoptionBar',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));

/**
 * Article List
 */
/* global Modernizr */
/* jshint maxlen: 500 */

/**
 * Box
 */

 (function ($) {
    'use strict';

    var api = {
        elements: []
    },
        status;

    /**
     * Elem class
     * @param $el hero wrapper
     * @constructor
     */
    function Elem($el) {
        this.$el = $el;

        if (status.isAuthor() || !this.$el.find('.image-hero').length) {
            return;
        }

        //this.setBackground();
        this.attachEvents();
    }

    /**
     * Sets background on hero wrapper
     */

    Elem.prototype.setBackground = function () {
        var $imageHero = this.$el.find('.image-hero'),
            source = '.image-hero source',
            imageSource,
            imageRendition = this.$el.find(source);

        _.forEach(imageRendition, function (el) {
            var $element = $(el);
            if (this.checkRendition($element)) {
                imageSource = $element.attr('srcset') || $imageHero.find('img').attr('src');
            }
        }.bind(this));

        if (imageSource !== this.previousSource && !$($imageHero).hasClass('illustration-hero-image')) {
            this.previousSource = imageSource; 

            this.$el.css({
                backgroundImage: 'url(' + imageSource + ')'
            });

            this.$el.waitForImages().done(function () {
                $imageHero.addClass('is-hidden');
            });
        }
    };

    Elem.prototype.moveImage = function () {
        this.$el.find('.illustration-hero-image').appendTo('.richText-hero-text-layout-parsys');
    };

    Elem.prototype.checkRendition = function ($element) {
        return window.Modernizr.mq($element.attr('media'));
    };

    Elem.prototype.attachEvents = function () {
        var $mboxDefault = this.$el.find('.mboxDefault'),
            targetPolyfill,
            self = this,
            MutationObserver = window.MutationObserver || window.WebKitMutationObserver;

        _.delay(
            function () {
                $(window).on('resize', _.debounce(this.setBackground.bind(this), 500));
            }.bind(this), 1
        );

        if(this.$el.find('.image-hero').hasClass('illustration-hero-image')) {
            this.$el.addClass('white-background');
            this.moveImage();
        }

        if (Modernizr.geolocation && $mboxDefault.length) {
            if (MutationObserver) {
                var observer = new MutationObserver(function () {
                    this.setBackground.bind(this)();
                }.bind(this));

                var $elementToObserve = $('.mboxDefault');
                var elementToObserveEl = null;

                $elementToObserve.each(function () {
                    var $this = $(this);
                    if ($this.find('picture').length) {
                        elementToObserveEl = this;
                    }
                });

                if (elementToObserveEl) {
                    observer.observe(elementToObserveEl, {
                        subtree: true,
                        attributes: true
                    });
                }
            } else {

                targetPolyfill = setInterval(function () {
                    if (!$('.mboxDefault').find('picture').length) {
                        clearInterval(targetPolyfill);
                        self.setBackground.bind(self)();
                    }
                }, 200);
            }
        } else {
            this.setBackground.bind(this)();
        }
    };

    api.onRegister = function (scope) {
        var $boxes = scope.$scope;
        status = this.external.status;

        _.forEach($boxes, function (box) {
            var $box = $(box);
            api.elements.push(new Elem($box));
        });
    };

    Cog.registerComponent({
        name: 'heroWrapper',
        api: api,
        selector: '.hero-wrapper, .box-background-cover, .box-advertising-wrapper',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})(Cog.jQuery());

/**
 * This module sets background color on html based on class on element
 *
 * Page has to got page-error-handler to work.
 */
(function ($) {
    'use strict';

    var api = {};

    /**
     * Set background-color on html
     */

    function setBackground($scope) {
        var bgColor = $scope.find('[class*=\'background-color-\']').eq(0).css('background-color'),
            $html = $('html');

        $html.css({
            'height': '100%',
            'background-color': bgColor
        });
    }

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        setBackground($el);
    };

    Cog.registerComponent({
        name: 'pageErrorHandler',
        api: api,
        selector: '.page-error-handler'
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {};

    /**
     * Set background-color on header
     */

    function setBackground($scope) {
        var bgColor = $scope.css('background-color'),
            $header = $('#header');

        $header.css('background-color', bgColor).addClass('header-dark');
    }

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        setBackground($el);
    };

    Cog.registerComponent({
        name: 'hero-wrapper',
        api: api,
        selector: '.hero-wrapper[class*=\'background-color-\']'
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {
        element: []
    },
        isAuthor,
        $htmlBody = $('html, body');

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function SvgImage($image) {
        var url = $image.attr('src'),
            key = url.replace(/\.\.\//g, ''),
            restored = this.restore(key);

        if (restored) {
            $image.after($(restored));
            $image.remove();
        }
        else {
            $.ajax({
                url: url
            }).success(function (response, type, data) {
                var svgData;

                if (data && data.responseText) {
                    svgData = data.responseText;
                    $image.after($(data.responseText));
                    $image.remove();
                    this.store(key, svgData);
                }
            }.bind(this));
        }
    }

    SvgImage.prototype.restore = function (key) {
        var result = false;
        if (Modernizr.sessionstorage) {
            result = window.sessionStorage.getItem('_absa-icon-' + key);
        }
        return result;
    };

    SvgImage.prototype.store = function (key, value) {
        if (Modernizr.sessionstorage) {
            return window.sessionStorage.setItem('_absa-icon-' + key, value);
        }
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function BoxFooter($el) {
        this.$el = $el;
        this.$columns = this.$el.find('.box-footer');
        this.$paragraphs = this.$columns.find('p');
        this.$linkSections = this.$columns.find('.box');
        this.$lookingForSection = this.$el.find('.box-looking-for-footer');
        this.$lookingForSectionHeading = this.$lookingForSection.find('h2.box-heading');
        this.$lookingForTabs = this.$lookingForSection.find('.tabs');

        this.$lookingForSectionHeading.attr('tabindex', 0);
        this.handleSVGImages();

        this.bindUIEvents();

        if (!isAuthor) {
            this.addLinkClass();
            this.setEqualHeights();
        }
    }

    BoxFooter.prototype.isEnterKey = function (e) {
        return e.which === 13 ? true : false;
    };

    BoxFooter.prototype.handleSVGImages = function () {
        var $images = this.$el.find('img[src*=\'.svg\']');

        _.forEach($images, function (image) {
            new SvgImage($(image));
        });
    };

    BoxFooter.prototype.handleHeadingClick = function (e) {
        var $heading = $(e.target),
            $parent = $heading.closest('.box'),
            isLookingFor = $heading.closest('.box-looking-for-footer').length;

        if ($parent.hasClass('is-active')) {
            this.hide($parent);
        } else {
            this.show($parent);
            this.scrollToActiveElement($parent);
        }

        if (isLookingFor) {
            $parent.find('.tabs').toggleClass('closed');
        }
    };

    BoxFooter.prototype.resizeItems = function ($items) {
        function resize() {
            _.each($items, function (item) {
                var $item = $(item),
                    height = $item[0].scrollHeight;

                $item.css({
                    'transition': '',
                    'max-height': height
                });
            });
        }

        _.defer(resize);
    };

    BoxFooter.prototype.hide = function ($slide) {
        var $content = $slide.find('> .component-content > .content');

        $content.css({
            'transition': 'none',
            'max-height': 0
        });

        $slide.removeClass('is-active');
    };

    BoxFooter.prototype.scrollToActiveElement = function ($slide) {
        var offset = $slide.offset().top - 57;

        $htmlBody.animate({scrollTop: offset}, 250);
    };

    BoxFooter.prototype.show = function ($slide) {
        var $inactivateSlide = this.$columns.find('.box.is-active').not($slide),
            $showContent = $slide.find('> .component-content > .content');

        if ($slide.length === 0) {
            return null;
        }

        if (Modernizr.csstransitions) {
            $showContent.off('transitionend');
        }

        this.hide($inactivateSlide);

        $slide.addClass('is-active');
        this.resizeItems($showContent);
    };

    BoxFooter.prototype.setEqualHeights = function () {
        var heights = [];

        this.$columns.css('height', 'auto');

        _.forEach(this.$columns, function (el) {
            heights.push($(el).outerHeight());
        });

        this.$columns.css('height', Math.max.apply(Math, heights) + 'px');
    };

    BoxFooter.prototype.addLinkClass = function () {
        _.forEach(this.$paragraphs, function (el) {
            var $el = $(el);

            if (!$el.children('a').length) {
                $el.addClass('not-link');
            }
        });
    };

    BoxFooter.prototype.bindUIEvents = function () {
        this.$el.on('click', '.box-footer .box .box-heading',
                    this.handleHeadingClick.bind(this));

        this.$el.on('click', '.box-footer-redesign .box .box-heading',
                    this.handleHeadingClick.bind(this));

        this.$lookingForSectionHeading.on('keyup', function (e) {
            if (this.isEnterKey(e)) {
                this.handleHeadingFooterClick();
            }
        }.bind(this));

        $(window).on('resize', _.debounce(function () {
            this.setEqualHeights();
            this.show(this.$columns.find('.box.is-active'));

        }, 300).bind(this));
    };

    api.onRegister = function (scope) {
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch');
        api.element.push(new BoxFooter(scope.$scope));
    };

    Cog.registerComponent({
        name: 'boxFooter',
        api: api,
        selector: '.reference-snippet-footer, .footer-snippet, .snippet-footer-redesign'
    });
})(Cog.jQuery());

/**
 * Sub navigation
 *
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function SubNavigation($el) {
        this.$el = $el;
        this.$navigationBarTrigger = $('.richText-navigation-bar-trigger');

        this.createCloseButton();
        this.bindUIEvents();
    }

    SubNavigation.prototype.createCloseButton = function () {
        this.$el.append('<span class=\'close\'></span>');
    };

    SubNavigation.prototype.bindUIEvents = function () {
        this.$navigationBarTrigger.on('click', this.onTriggerClick.bind(this));
        this.$el.find('.close').on('click', this.onTriggerClick.bind(this));
    };

    SubNavigation.prototype.onTriggerClick = function () {
        this.$el.toggleClass('is-active');
    };

    api.onRegister = function (scope) {
        api.element.push(new SubNavigation(scope.$scope));
    };

    Cog.registerComponent({
        name: 'SubNavigation',
        api: api,
        selector: '.box-navigation'
    });
})(Cog.jQuery());

/**
 * Sitemap
 *
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    },
        $htmlBody = $('html, body');

    /**
     * Element class
     * @param $el sitemap wrapper
     * @constructor
     */

    function BoxSitemap($el) {
        this.$sitemap = $el;
        this.$header = this.$sitemap.find('.box-heading');
        this.$content = this.$header.siblings('.content');
        this.contentHeight = this.$content[0].scrollHeight;

        this.bindUIEvents();
    }

    BoxSitemap.prototype.toggleActiveElement = function () {
        var $activeHeader;

        if (this.$activeElement.hasClass('is-active')) {
            this.$activeElement.removeClass('is-active');
            this.$content.css({'transition': 'none', 'max-height': 0}).removeClass('is-open');
        } else {
            $activeHeader = this.$sitemap.siblings().find('.is-active').not(this.$activeElement);
            $activeHeader.removeClass('is-active')
                .siblings('.content').css({
                'transition': 'none',
                'max-height': 0
            }).removeClass('is-open');

            this.$activeElement.addClass('is-active');
            this.$content.css({
                'transition': '',
                'max-height': this.contentHeight
            }).addClass('is-open');
        }
    };

    BoxSitemap.prototype.bindUIEvents = function () {
        this.$header.on('click', function (e) {
            this.$activeElement = $(e.currentTarget);
            this.toggleActiveElement();
            this.scrollToActiveElement();
        }.bind(this));

        $(window).on('resize', _.debounce(function () {
            this.setContentHeight();
        }.bind(this), 300));
    };

    BoxSitemap.prototype.scrollToActiveElement = function () {
        var offset = this.$activeElement.offset().top,
            isActive = this.$content.hasClass('is-open');

        if (isActive) {
            $htmlBody.animate({scrollTop: offset}, 250);
        }
    };

    BoxSitemap.prototype.setContentHeight = function () {
        var tempHeight = this.$content[0].scrollHeight;
        if (this.contentHeight !== tempHeight) {
            this.contentHeight = tempHeight;

            if (this.$header.hasClass('is-active')) {
                this.$content.css('max-height', this.contentHeight);
            }
        }
    };

    api.onRegister = function (scope) {
        api.element.push(new BoxSitemap(scope.$scope));
    };

    Cog.registerComponent({
        name: 'BoxSitemap',
        api: api,
        selector: '.box-sitemap, .box-sitemap-horizontal'
    });
})(Cog.jQuery());

/**
 * Header login
 *
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function Login($el) {
        this.$login = $el;
        this.$body = $('body');
        this.$html = $('html');
        this.$loginBarTrigger = $('.richText-login-bar-trigger');
        this.$loginBoxTrigger = $('.richText-login-button');
        this.isLoginOpen = false;
        this.close();
        this.$loginBarTrigger.attr('tabindex', 0);
        this.createCloseButton();
        this.bindUIEvents();
        this.close();
    }

    Login.prototype.isEnterKey = function (e) {
        return e.which === 13 ? true : false;
    };

    Login.prototype.createCloseButton = function () {
        this.$close = $('<a href=\'#close\' class=\'close\'>X</a>');
        this.$login.append(this.$close);
    };

    Login.prototype.bindUIEvents = function () {

        this.$loginBarTrigger.on('click', this.onTriggerClick.bind(this));
        this.$loginBoxTrigger.on('click', this.onTriggerClick.bind(this));
        this.$loginBarTrigger.on('keyup', function (e) {
            if (this.isEnterKey(e)) {
                this.onTriggerClick(e);
            }
        }.bind(this));

        this.$close.on('click', this.onTriggerClick.bind(this));

        Cog.addListener('boxMenu', 'open', function () {
            this.close();
        }.bind(this));

        Cog.addListener('search', 'open', function () {
            this.close();
        }.bind(this));
    };

    Login.prototype.onMaxHeightEnd = function ($el, callback) {
        if (Modernizr.csstransitions) {
            $el.off('transitionend').on('transitionend', _.debounce(function (e) {
                if (e.originalEvent && e.originalEvent.propertyName === 'max-height') {
                    callback();
                }
            }, 1));
        } else {
            callback();
        }
    };

    Login.prototype.close = function () {
        this.isLoginOpen = false;
        this.$login.removeClass('is-active is-open');
        if (this.$login.hasClass('is-active')) {
            this.$login.removeClass('is-active');
        } else {
            this.$login.css('display', 'none');
        }
        this.onMaxHeightEnd(this.$login, function () {
            this.$login.css('display', 'none');
        }.bind(this));
        this.$body.removeClass('is-loginBox-active');
        this.$html.removeClass('no-scroll');
        Cog.fireEvent('header', 'overlayClose');
    };

    Login.prototype.open = function () {
        this.$overlayTrigger = $('.overlayBg');
        this.$login.css('display', 'block');
        _.defer(function () {
            this.isLoginOpen = true;
            this.$login.addClass('is-active');
            this.onMaxHeightEnd(this.$login, function () {
                this.$login.css('display', 'block');
                this.$login.addClass('is-open');
                Cog.fireEvent('header', 'overlayOpen');
            }.bind(this));

            this.$body.addClass('is-loginBox-active');
            this.$html.addClass('no-scroll');
            this.$overlayTrigger.on('click', this.onTriggerOverlayBg.bind(this));
        }.bind(this));

        Cog.fireEvent('login', 'open');
        Cog.fireEvent('header', 'overlayOpen');
    };

    Login.prototype.onTriggerOverlayBg = function (e) {
        e.preventDefault();

        if (this.isLoginOpen) {
            this.close();
        } else {
            this.close();
        }
        Cog.fireEvent('login', 'changedLoginStatus', {isOpen: this.isLoginOpen});
    };

    Login.prototype.onTriggerClick = function (e) {
        e.preventDefault();
        if (this.isLoginOpen) {
            this.close();
        } else {
            this.open();
        }

        Cog.fireEvent('login', 'changedLoginStatus', {isOpen: this.isLoginOpen});
    };

    api.onRegister = function (scope) {
        api.element.push(new Login(scope.$scope));
    };

    Cog.registerComponent({
        name: 'login',
        api: api,
        selector: '.box-login'
    });
})(Cog.jQuery());

/**
 * Comparison Table Wrapper
 *
 */

(function ($) {
    'use strict';

    var api = {
            element: []
        },
        status,
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch');

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */

    function ComparisonTable($el) {
        this.$el = $el;
        this.$columns = this.$el.find('.box-comparison-table-column');
        this.$mobileTable = this.$el.find('.component-content .left + .box .table');
        this.$icons = this.$el.find('.component-content .left img');
        this.$iconRows = this.$columns.eq(0).find('tr');

        if (!isAuthor) {
            this.bindUIEvents();
            this.cloneHeaderImages();

            if(!status.isMobile()){
                this.setColumnsWidth(); // For transitioning from explore to compare page
            }

            _.defer(function () {
                this.$el.waitForImages().done(function () {
                    this.setEqualHeights();
                }.bind(this));
            }.bind(this), 1);
        }
    }

    ComparisonTable.prototype.cloneHeaderImages = function () {

        _.forEach(this.$columns, function (el) {

            var $el = $(el),
                $image = $el.find('.image'),
                $table = $el.find('.table');

            if ($image.length) {

                var $clonedImg = $image.find('img').parent(),
                    $tableData = $table.find('tr:first-child td'),
                    $clonedNode = null;

                if ($clonedImg.is('picture')) {

                    if($clonedImg.parent().is('a')) {
                        $clonedNode = $clonedImg.parent().parent().clone();
                        $tableData.prepend($clonedNode);
                    }
                    else {
                        $clonedNode = $clonedImg.parent().clone();
                        $tableData.prepend($clonedNode);
                    }
                }
                else {
                    if ($clonedImg.is('a')) {
                        $clonedNode = $clonedImg.clone();
                        $tableData.prepend($clonedNode);
                    }
                    else {
                        $clonedNode = $image.find('img').clone();
                        $tableData.prepend($clonedNode);
                    }
                }
            }
        });
    };

    ComparisonTable.prototype.setEqualHeights = function () {

        var heights = [],
            currentWidth = $(window).width(),
            $tableHeaderItem = this.$el.find('.table-header-item');
        var tablerowsLen = $('table > tbody > tr').length;

        this.$columns.find('.table:not(.clone) tr').height('auto');

        _.forEach(this.$columns, function (column) {
            var $column = $(column),
                arr = [];

            _.forEach($column.find('.table:not(.clone) tr'), function (tr) {
                var $tr = $(tr);

                arr.push($tr.height());
            });

            heights.push(arr);
        });

        for (var i = 0; i <= tablerowsLen; i++) {
            var rowHeights = [];

            _.forEach(heights, function (arr) {
                rowHeights.push(arr[i]);
            });

            this.$columns.find('tr:nth-child(' + (i + 1) + ')').height(Math.max.apply(Math, rowHeights));
        }


        // set equal header items height
        heights = [];
        $tableHeaderItem.height('auto');

        _.forEach($tableHeaderItem, function (item) {
            heights.push($(item).height());
        });

        $tableHeaderItem.height(Math.max.apply(Math, heights));

        this.prevWidth = currentWidth;

        Cog.fireEvent('comparisonTable', 'heightChanged');
    };

    ComparisonTable.prototype.setColumnsWidth = function () {
        this.$columns.css('width', (100 / this.$columns.length) + '%');
    };

    ComparisonTable.prototype.bindUIEvents = function () {

        $(window).on('resize', _.debounce(function () {
            this.setEqualHeights();
            if(!status.isMobile()){
                this.setColumnsWidth();
            }
        }.bind(this), 300));

        Cog.addListener('accordion', 'openSlide', function () {
            this.setEqualHeights();
        }.bind(this));

        Cog.addListener('tab', 'change', function () {
            _.defer(this.setEqualHeights.bind(this));
        }.bind(this));
    };

    api.onRegister = function (scope) {
        status = this.external.status;
        api.element.push(new ComparisonTable(scope.$scope));
    };

    Cog.registerComponent({
        name: 'comparisonTable',
        api: api,
        selector: '.box-comparison-table-wrapper',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})(Cog.jQuery());

/**
 * Children with equal height
 *
 */

(function ($) {
    'use strict';

    var api = {
            element: []
        },
        isAuthor,
        isTablet = checkTablet();

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */

    function checkTablet() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    function HandleEqualHeight($el) {
        this.$container = $el;
        this.hasSpecificItems = this.$container.find('.js-equal-height-item').length > 0;
        this.$children = this.getEqualHeightChildren();
        this.$showcaseRichText = this.$container.find('.richText-big-icon-showcase.js-equal-height-item');
        this.$setHeightTarget = this.hasSpecificItems ? this.$children : this.$children.find('> .component-content');

        if(isAuthor) { return false; }

        this.attachEvents();
        this.setEqualHeights();

    }

    HandleEqualHeight.prototype.getEqualHeightChildren = function () {
        var $element;

        if (this.hasSpecificItems) {
            $element = this.$container.find('.js-equal-height-item > .component-content > div');
        } else {
            $element = this.$container.find('> .component-content > .content > .component');
        }

        return $element;
    };

    HandleEqualHeight.prototype.attachEvents = function () {
        $(window).on('resize orientationchange', _.debounce(function () {
            isTablet = checkTablet();
            this.setEqualHeights();
        }.bind(this), 300));

        Cog.addListener('tab', 'change', this.setEqualHeights.bind(this));
    };

    HandleEqualHeight.prototype.setEqualHeights = function () {
        var heights = [],
            $button;

        this.$setHeightTarget.css('height', '');
        this.$showcaseRichTextHeadings = this.$showcaseRichText.find('h6');

        if (!isTablet) {
            if (this.$showcaseRichText.length) {
                this.$showcaseRichTextHeadings.css('height', '');

                _.forEach(this.$showcaseRichTextHeadings, function (item) {
                    var $heading = $(item);

                    heights.push($heading.outerHeight());
                }.bind(this));

                this.$showcaseRichTextHeadings.css('height', Math.max.apply(Math, heights) + 'px');
                heights = [];
            }

            var buttonHeights = [],
                currentTopLowestHeight = 0;

            if ( !this.equalHeightSet ) {

                _.forEach(this.$children, function (item) {
                    var $item = $(item),
                        itemHeight,
                        itemButtonsHeights = 0;

                    if (this.hasSpecificItems && $item.find('> p > [class*=\'btn-action\'], ' +
                                                                '.read-more, ' +
                                                                '.link-action-bottom').length) {

                        $button = $item.find('> p > [class*=\'action\'], ' +
                                            '.read-more, ' +
                                            '.link-action-bottom').parent();

                        for (var i = 0; i < $button.length; i++) {
                            // Collapse margins logic
                            if (i === 0) {
                                itemButtonsHeights += parseInt(($($button[i])).css('margin-top'));
                            } else if (i === $button.length - 1) {
                                itemButtonsHeights += parseInt(($($button[i])).css('margin-bottom'));
                            }

                            if (i !== 0) {
                                itemButtonsHeights += ($($button[i])).offset().top -
                                                        ($($button[i - 1])).offset().top -
                                                        ($($button[i - 1])).height();
                            }

                            itemButtonsHeights += ($($button[i])).height();
                        }

                        buttonHeights.push(itemButtonsHeights);

                        itemHeight = $item.outerHeight() - itemButtonsHeights;

                        heights.push(itemHeight);

                        if (itemHeight === Math.max.apply(Math, heights) && $button.length > 0) {
                            currentTopLowestHeight = ($($button[0])).offset().top;
                        }

                    } else {
                        buttonHeights.push(itemButtonsHeights);
                        itemHeight = $item.outerHeight() - itemButtonsHeights;
                        heights.push(itemHeight);
                    }
                }.bind(this));

                _.forEach(this.$children, function (item) {
                    var $item = $(item);

                    if (currentTopLowestHeight &&
                        this.hasSpecificItems &&
                        $item.find('> p > [class*=\'btn-action\'],'+
                                    ' .read-more, '+
                                    '.link-action-bottom').length) {

                            $button = $item.find('> p > [class*=\'action\'], .read-more, .link-action-bottom').parent();

                            if ($button.length > 0) {
                                ($($button[0])).css('margin-top', (currentTopLowestHeight -
                                        ($($button[0])).offset().top +
                                        parseInt(($($button[0])).css('margin-top'))) + 'px');
                            }
                    }
                }.bind(this));

                this.$setHeightTarget.css('height', (Math.max.apply(Math, heights) + Math.max.apply(Math, buttonHeights)) + 'px');
                this.equalHeightSet = true;

            } else {
                this.$showcaseRichTextHeadings.css('height', '');
            }
        } else {
            // 1. Determine size of child item with greatest height from the children
            // 2. Set height of all children in same group to this height// 3. Determine the height of the richText-content div of the child with greatest height
            // 3. Iterate through each child to determine the height of the richText component
            // 4. Identify to top/first link of the richText-content
            // 5. Set margin-top property of top/first link to (difference of greatest richText height - height of current richText-content)

            if (!this.equalHeightSet) {
                var childHeights = [],
                    maxChildHeight = 0;

                _.forEach(this.$children, function (item) {
                    var $child = $(item);
                    childHeights.push($child.outerHeight());
                }.bind(this));

                maxChildHeight = Math.max.apply(Math, childHeights);

                _.forEach(this.$children, function (item) {
                    var $child = $(item),
                        childHeight = $child.outerHeight(),
                        marginTop = 0,
                        $firstTopLinkToSetToBottom;

                    if( maxChildHeight > childHeight ){
                        marginTop = maxChildHeight - childHeight;
                    }

                    $firstTopLinkToSetToBottom = $($child.find('> p > [class*=\'action\']:first,' +
                                                                ' .read-more:first, ' +
                                                                '.link-action-bottom:first').parent());

                    $child.css('height', maxChildHeight + 'px');
                    $firstTopLinkToSetToBottom.css('margin-top', marginTop + 'px');
                    this.equalHeightSet = true;

                }.bind(this));
            }
        }
    };

    api.onRegister = function (scope) {
        isAuthor = $('body').hasClass('cq-wcm-edit-touch');
        api.element.push(new HandleEqualHeight(scope.$scope));
    };

    Cog.registerComponent({
        name: 'childrenEqualHeight',
        api: api,
        selector: '.js-children-have-equal-height'
    });
})(Cog.jQuery());

/**
 * AJAX mechanism for loading pages
 *
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    },
        status,
        handleHistory,
        boxSelector = '.js-dynamic-load-content',
        request,
        isHistorySupported = !!(window.history && history.pushState),
        isTransitionSupported = Modernizr.csstransitions,
        isSessionStorageSupported = Modernizr.sessionstorage,
        $body, $window,
        initialized = false,
        currentStep,
        previousStep,
        windowHeight = 0;

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */

    function DynamicContentBox($el) {
        this.bindDOM($el);
        this.isButtonEnabled = true;

        if (!initialized) {
            this.bindUIEvents();
            this.fixExternalLinks($el);
            this.determineCurrentStep();
            this.setStepClass();
            this.setInitialHeight();

            if (isSessionStorageSupported) {
                this.prepareSessionStorage();
            }
        }

        initialized = true;
    }

    DynamicContentBox.prototype.setInitialHeight = function () {
        this.$box.addClass('no-transition');
        this.$box.css('height', 'auto');
        this.setBoxHeight(this.$box.outerHeight());

        if (status.isMobile()) {
            this.setBackgroundSizeForMobile();
        }

        _.defer(function () {
            this.$box.removeClass('no-transition');
        }.bind(this));
    };

    DynamicContentBox.prototype.bindDOM = function ($el) {
        $body = $('body');
        $window = $(window);
        this.$el = $el;
        this.$box = this.$el.find('.box-home-page-navigation');
    };

    DynamicContentBox.prototype.getStep = function ($scope) {
        $scope = $scope || this.$el;

        var isNavToSecondStepPresent = $scope.find('.navigation-step-2').length,
            isNavToThirdStepPresent = $scope.find('.navigation-step-3').length,
            isNavBackToFirstStepPresent = $scope.find('a.go-back').length,
            step;

        if (isNavToSecondStepPresent || (isNavToThirdStepPresent && !isNavBackToFirstStepPresent)) {
            step = 1;
        } else if ((isNavToThirdStepPresent && isNavBackToFirstStepPresent) || (isNavBackToFirstStepPresent && !isNavToThirdStepPresent && !isNavToSecondStepPresent)) {
            step = 2;
        } else {
            step = 3;
        }

        return step;
    };

    DynamicContentBox.prototype.determineCurrentStep = function () {
        currentStep = this.getStep();
        previousStep = Math.max(currentStep - 1, 1);
    };

    DynamicContentBox.prototype.setStep = function (step) {
        previousStep = currentStep;
        currentStep = step;
    };

    DynamicContentBox.prototype.setStepClass = function () {
        this.$el.removeClass('step1 step2 step3 from-step2').addClass('step' + currentStep);
        if (previousStep === 2) {
            this.$el.addClass('from-step2');
        }
    };

    DynamicContentBox.prototype.getUrl = function ($el) {
        return ($el.is(':not(a)') ? $el.find('a').attr('href') : $el.attr('href'));
    };

    DynamicContentBox.prototype.onClick = function (e) {
        var $currentTarget = $(e.currentTarget),
            url = this.getUrl($currentTarget);

        if (!this.isButtonEnabled) {
            return false;
        }

        this.isButtonEnabled = false;

        if (!status.isAuthor() && isHistorySupported) {
            e.preventDefault();
            this.getPage(url);
        } else {
            window.location.href = $currentTarget.find('a').attr('href');
        }
    };

    DynamicContentBox.prototype.onResize = function () {
        var currentWindowHeight = $window.height(),
            delta = Math.abs(windowHeight - currentWindowHeight);
        windowHeight = currentWindowHeight;

        if (status.isMobile() && delta >= 40) {
            this.setInitialHeight();
        } else if (!status.isMobile()) {
            this.unsetBackgroundSizeForMobile();
        }
    };

    DynamicContentBox.prototype.bindUIEvents = function () {
        $body.on('click', '.internal, .navigation-internal li', this.onClick.bind(this));
        handleHistory.onpopstate(function (e) {
            // fix for iPad firing popstate on page load
            if (!e.originalEvent.state || (e.originalEvent.state && !e.originalEvent.state.dynamicContent)) {
                return;
            }

            if (this.isSkippingToProduct()) {
                window.location.reload();
            } else {
                this.getPage(window.location.href, true);
            }

        }.bind(this));

        $window.on('resize', _.throttle(this.onResize.bind(this), 300));
    };

    DynamicContentBox.prototype.restoreData = function (url) {
        var obj = {},
            keys = [
                'hero', 'header', 'breadcrumbs', 'box', 'content', 'step', 'title', 'dataLayerScript'
            ];

        _.forEach(keys, function (key) {
            obj[key] = this.getFromStorage(key, url);
        }.bind(this));

        if (obj.step) {
            obj.step = window.parseInt(obj.step);
        }

        return obj;
    };

    DynamicContentBox.prototype.storeMarkup = function (markup, url) {
        for (var key in markup) {
            if (markup.hasOwnProperty(key)) {
                this.setToStorage(key + '|' + url, markup[key]);
            }
        }
    };

    DynamicContentBox.prototype.onRequestSuccess = function (data, url) {
        var obj = this.prepareMarkup(data);
        this.storeMarkup(obj, url);

        if (obj.content) {
            this.updateMarkup(obj);
        } else {
            Cog.fireEvent('loader', 'change', 1);
        }
    };

    DynamicContentBox.prototype.requestPage = function (url) {
        return $.ajax({
            method: 'GET',
            url: url,
            beforeSend: function () {
                Cog.fireEvent('loader', 'change', 0.5);
            }.bind(this),
            success: function (response) {
                this.onRequestSuccess(response, url);
            }.bind(this)
        });
    };

    DynamicContentBox.prototype.getPage = function (url, isUsingHistoryBack) {
        var isRequestInProgress = request && request.readystate !== 4,
            isNoStorage = !isSessionStorageSupported || this.getFromStorage('content', url) === null;

        if (isRequestInProgress) {
            request.abort();
        }

        if (!isUsingHistoryBack) {
            history.pushState({
                url: url,
                dynamicContent: true
            }, null, url);
        }

        if (isNoStorage) {
            request = this.requestPage(url);
        } else {
            this.updateMarkup(this.restoreData(url));
        }
    };

    DynamicContentBox.prototype.updateBreadcrumbs = function (breadcrumbs) {
        var $breadcrumbs = $('#header .breadcrumbs');
        $breadcrumbs.html(breadcrumbs);

        if (currentStep > 1) {
            $breadcrumbs.removeClass('step1');
            _.defer(function () {
                $breadcrumbs.removeClass('step2 step3')
                    .addClass('step' + currentStep);
            });
        }
        else {
            $breadcrumbs.removeClass('step2 step3');
            _.delay(function () {
                $breadcrumbs.addClass('step' + currentStep);
            }, 300);
        }
    };

    DynamicContentBox.prototype.updateMarkup = function (obj) {
        this.setStep(obj.step);
        this.injectContent(obj);
        this.updateTitle(obj);
        this.resetDataLayer(obj);
        this.setStepClass();
    };

    DynamicContentBox.prototype.updateTitle = function (obj) {
        document.title = obj.title;
    };

    DynamicContentBox.prototype.resetDataLayer = function (obj) {
        Cog.fireEvent('dataLayer', 'reset', {
            dataLayerScript: obj.dataLayerScript
        });
    };

    DynamicContentBox.prototype.fixExternalLinks = function (elements) {
        _.forEach(elements, function (element) {
            $(element).find('a.go-back').removeClass('external').addClass('internal');
        });
    };

    DynamicContentBox.prototype.removePictures = function ($element) {
        var $pictures = $element.find('picture');

        if (!status.isAuthor()) {
            _.forEach($pictures, function (picture) {
                var $picture = $(picture),
                    $before = $picture.prev();

                $before.data('picture-after', $picture).addClass('has-picture-after');
                $picture.remove();
            });
        }

        return $element;
    };

    DynamicContentBox.prototype.restorePictures = function ($element) {
        if (!status.isAuthor()) {
            _.forEach($element.find('.has-picture-after'), function (el) {
                var $el = $(el);

                $el.after($el.data('picture-after'));
            });
        }

        return $element;
    };

    DynamicContentBox.prototype.isGoingToPreviousStep = function () {
        return currentStep < previousStep;
    };

    DynamicContentBox.prototype.injectProductPageContent = function ($container, $new, obj) {
        var $newHeader = $(obj.header);
        $('#header').remove();
        $container.after($newHeader);
        $newHeader.after($new);
    };

    DynamicContentBox.prototype.injectJourneyStepContent = function ($container, $new, $newBox) {
        var isDynamicNavigationInDOM = $body.find(boxSelector).length > 0;
        $('.header').html('');

        if (isDynamicNavigationInDOM) {
            if (this.isGoingToPreviousStep()) {
                this.$box.prepend($newBox);
            } else {
                this.$box.append($newBox);
            }
        } else {
            $container.append($new);
            this.$el = $body.find(boxSelector);
        }
    };

    DynamicContentBox.prototype.onImagesReady = function (obj, $new, $newBox, $container) {
        Cog.fireEvent('loader', 'change', 1); 

        if (obj.step === 3) {
            this.injectProductPageContent($container, $new, obj);
            _.delay(function () {
                Cog.fireEvent('dynamicContent', 'loaded');
            }, 1000);
        } else {
            this.injectJourneyStepContent($container, $new, $newBox, obj);
        }

        Cog.init();
        this.animateContent();

        _.defer(function () {
            this.isButtonEnabled = true;
            this.updateBreadcrumbs(obj.breadcrumbs);
        }.bind(this));
    };

    DynamicContentBox.prototype.whatToWaitFor = function (obj, $el) {
        var $waitFor = null;
        if (obj.hero !== 'undefined' && $(obj.hero).find('img, picture').length) {
            $waitFor = $(obj.hero);
        } else if ($el.find('.hero-wrapper img, .image-hero img, .hero-wrapper picture, .image-hero picture').length) {
            $waitFor = $el.find('.hero-wrapper, .image-hero');
        }

        return $waitFor;
    };

    DynamicContentBox.prototype.injectContent = function (obj) {
        var $container = $('.box-home-page-navigation > .component-content'),
            $new = $(obj.content),
            $newBox = $(obj.box),
            $imageContainer,
            $containerForFadingContent = $('<div class=\'js-dynamic-load-content-old\' />');

        this.fixExternalLinks([$new, $newBox]);

        if (obj.step === 3) {
            $container = $body.find('#content');
        }

        $container.after($containerForFadingContent);
        $containerForFadingContent.append($container);

        $imageContainer = this.whatToWaitFor(obj, $new);

        if ($imageContainer) {
            $imageContainer = this.removePictures($imageContainer);
            $imageContainer.waitForImages({
                waitForAll: true
            }).done(function () {
                this.onImagesReady(obj, $new, $newBox, $containerForFadingContent);
                this.restorePictures($imageContainer);
            }.bind(this));
        } else {
            this.onImagesReady(obj, $new, $newBox, $containerForFadingContent);
        }

    };

    DynamicContentBox.prototype.onAnimationEnd = function ($old, $new) {
        $new.show();
        $old.remove();
        $('.is-transformed').css('transform', 'none').removeClass('is-transformed');
        this.setStepClass();
        if (this.isSkippingToProduct()) {
            $('#content.main').addClass('js-dynamic-load-fade-in');
            $('body').removeClass('header-home-template');
        }
    };

    DynamicContentBox.prototype.waitForAnimation = function ($old, $new) {
        // ontransitionend removed due to additional complexity
        _.delay(function () {
            this.onAnimationEnd($old, $new);
        }.bind(this), 770);
    };

    DynamicContentBox.prototype.setTransform = function ($el, value, next, isAnimated) {
        var stringValue = Modernizr.csstransforms3d ? 'translate3d(0, %%%px, 0)' : 'translate(0, %%%px)',
            $next = $();

        if (next > 0) {
            $next = $el.next().is('.main') ? $el.next().find('.hero-wrapper') : $el.next();
        } else if (next < 0) {
            $next = $el.prev().is('.main') ? $el.prev().find('.hero-wrapper') : $el.prev();
        }

        if (isAnimated === false) {
            $el.addClass('no-transition');
            $next.addClass('no-transition');
        } else {
            $el.removeClass('no-transition');
            $next.removeClass('no-transition');
        }

        $el.css({
            transform: stringValue.replace('%%%', value)
        }).addClass('is-transformed');

        $next.css({
            transform: stringValue.replace('%%%', value)
        }).addClass('is-transformed');
    };

    DynamicContentBox.prototype.isSkippingToProduct = function () {
        return currentStep === 3;
    };

    DynamicContentBox.prototype.animateContent = function () {
        var $old = $body.find('.js-dynamic-load-content-old'),
            oldContentHeight = $old.outerHeight(),
            $newContent = this.$box.find('> .component-content'),
            newContentHeight = $newContent.outerHeight();

        if (this.isGoingToPreviousStep()) {
            this.setTransform($old, -newContentHeight, -1, false);
            this.setBoxHeight(newContentHeight);
            _.defer(function () {
                this.setTransform($old, 0, -1, true);
            }.bind(this));
        } else {
            if (!this.isSkippingToProduct()) {
                this.setBoxHeight(newContentHeight);
            }
            _.defer(function () {
                this.setTransform($old, -oldContentHeight, 1);
            }.bind(this));
        }

        if (!isTransitionSupported) {
            this.onAnimationEnd($old, $newContent);
        }
        else {
            this.waitForAnimation($old, $newContent);
        }
    };

    DynamicContentBox.prototype.prepareSessionStorage = function () {
        var obj = this.prepareMarkup($('html').prop('outerHTML')),
            url = window.location.href;

        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                this.setToStorage(key + '|' + url, obj[key]);
            }
        }

        // fix for iPad so it won't care about initial popstate but still can go back
        if (isHistorySupported) {
            handleHistory.replace({dynamicContent: true}, window.location.href);
        }
    };

    DynamicContentBox.prototype.setBackgroundSizeForMobile = function () {
        var $box = this.$el.find('.box-background-cover');
        $box.css('background-size', 'auto ' + ($box.outerHeight() + 250) + 'px');
    };

    DynamicContentBox.prototype.unsetBackgroundSizeForMobile = function () {
        this.$el.find('.box-background-cover').css('background-size', '');
    };

    DynamicContentBox.prototype.prepareMarkup = function (markup) {
        var $markup = $($.trim(markup)),
            $box = $markup.find('.box-home-page-navigation'),
            $hero = $markup.find('.hero-wrapper'),
            $header = $markup.find('#header'),
            $breadcrumbs = $markup.find('.breadcrumbs'),
            $content = $markup.find('#content'),
            step = this.getStep($content);

        $box.find('.mboxDefault + script').remove();
        $content.find('.mboxDefault + script').remove();

        return {
            box: $box.html(),
            hero: $hero.prop('outerHTML'),
            header: $header.prop('outerHTML'),
            breadcrumbs: $breadcrumbs.html(),
            content: $('<div />').append($content.clone()).html(),
            step: step,
            title: $markup.filter('title').text(),
            dataLayerScript: $markup.filter('#dataLayerScript').text()
        };
    };

    DynamicContentBox.prototype.getFromStorage = function (key, url) {
        return isSessionStorageSupported ? sessionStorage.getItem(key + '|' + url) : null;
    };

    DynamicContentBox.prototype.setToStorage = function (key, val) {
        if (isSessionStorageSupported) {
            sessionStorage.setItem(key, val);
        }
    };

    DynamicContentBox.prototype.setBoxHeight = function (height) {
        var currentHeight = this.$box.outerHeight(),
            minDelta = status.isMobile() ? 50 : 100,
            isChangeNeeded = status.isMobile() || (!this.$box.data('height-defined') || Math.abs(height - currentHeight) > minDelta);


        if (isChangeNeeded) {
            this.$box.css({
                'height': height,
                overflow: 'hidden'
            });
            this.$box.data('height-defined', true);
        }
    };

    api.onRegister = function (scope) {
        status = this.external.status;
        handleHistory = this.external.handleHistory;
        api.element.push(new DynamicContentBox(scope.$scope));
    };

    Cog.registerComponent({
        name: 'dynamicContentBox',
        api: api,
        selector: '.js-dynamic-load-content',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }, {
                name: 'utils.history',
                apiId: 'handleHistory'
            }
        ]
    });
})(Cog.jQuery());

/**
 * Box Menu
 */

(function ($) {
    'use strict';

    var api = {
        boxmenus: []
    },
        isMobile = checkMobile(),
        containerMaxHeight;

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    function BoxMenu($el) {
        this.$box = $el;
        this.$boxChild = this.$box.find('> div');
        this.$navigationBarTrigger = $('.richText-navigation-bar-trigger');
        this.$navBarTrigger = $('.richText-meganav-button');
        this.$menuFakeLink = this.$navigationBarTrigger.find('p');
        this.$body = $('body');
        this.$html = $('html');
        this.boxMenuIsActive = false;
        this.boxMenuHeight = this.$box[0].scrollHeight;
        this.boxMenuMaxHeight = this.boxMenuHeight;
        this.$menuFakeLink.attr('tabindex', 0);
        this.createCloseButton();
        this.handleMaxHeight();
        this.attachEvents();
        this.close();
    }

    BoxMenu.prototype.toggleTabButtonNavigation = function () {
        if (this.boxMenuIsActive) {
            this.$boxChild.show();
        } else {
            this.$boxChild.hide();
        }
    };

    BoxMenu.prototype.createCloseButton = function () {
        this.$close = this.$close || $('<a href=\'#close\' class=\'close\'>X</a>');
        this.$box.append(this.$close);
    };

    BoxMenu.prototype.attachEvents = function () {
        Cog.addListener('login', 'open', function () {
            this.close();
        }.bind(this));

        Cog.addListener('search', 'open', function () {
            this.close();
        }.bind(this));

        this.$navigationBarTrigger.on('click', this.onTriggerClick.bind(this));
        this.$navBarTrigger.on('click', this.onTriggerClick.bind(this));
        this.$close.on('click', this.onTriggerClick.bind(this));
        //close box-menu when link in accordion is clicked
        this.$box.on('click', '.accordion-content-wrapper a', this.onTriggerClickLink.bind(this));
        $(window).on('resize', _.debounce(this.onResize.bind(this), 100));
        Cog.addListener('accordionMenuSlide', 'toogleSlide', _.debounce(this.handleMaxHeight.bind(this), 350));
    };

    BoxMenu.prototype.onResize = function () {
        isMobile = checkMobile();
        this.handleMaxHeight();
    };

    BoxMenu.prototype.onMaxHeightEnd = function ($el, callback) {
        if (Modernizr.csstransitions) {
            $el.off('transitionend').on('transitionend', _.debounce(function (e) {
                if (e.originalEvent && e.originalEvent.propertyName === 'max-height') {
                    callback();
                }
            }, 1));
        } else {
            callback();
        }
    };

    BoxMenu.prototype.offMaxHeightEnd = function ($el) {
        $el.off('transitionend');
    };

    BoxMenu.prototype.open = function () {
        this.$overlayTrigger = $('.overlayBg');
        this.boxMenuIsActive = true;
        this.toggleTabButtonNavigation();

        _.defer(function () {
            this.handleMaxHeight();
            this.$body.addClass('box-menu-is-active');
            this.$box.addClass('is-active');
            Cog.fireEvent('boxMenu', 'changedBoxMenuStatus', {
                isOpen: true
            });
            this.setMaxHeight();

            this.onMaxHeightEnd(this.$box, function () {
                this.$box.addClass('is-active');
            }.bind(this));
            this.$body.addClass('is-menuBox-active');
            this.$overlayTrigger.on('click', this.onTriggerOverlay.bind(this));
        }.bind(this));

        Cog.fireEvent('boxMenu', 'open');
        Cog.fireEvent('header', 'overlayOpen');
    };

    BoxMenu.prototype.close = function () {
        this.boxMenuIsActive = false;
        this.$body.removeClass('box-menu-is-active');
        Cog.fireEvent('boxMenu', 'changedBoxMenuStatus', {
            isOpen: false
        });
        this.setMaxHeight(0);

        if (this.$box.hasClass('is-active')) {
            this.$box.removeClass('is-active');
        }

        this.offMaxHeightEnd(this.$box);
        this.$body.removeClass('is-menuBox-active');
        Cog.fireEvent('header', 'overlayClose');
        this.onMaxHeightEnd(this.$box, this.toggleTabButtonNavigation.bind(this));
    };

    BoxMenu.prototype.onTriggerOverlay = function (e) {
        e.preventDefault();
        if (this.boxMenuIsActive) {
            this.close();
        }
    };

    BoxMenu.prototype.onTriggerClick = function (e) {
        e.preventDefault();
        if (this.boxMenuIsActive) {
            this.close();
        } else {
            this.open();
        }
    };

    BoxMenu.prototype.onTriggerClickLink = function () {
        if (this.boxMenuIsActive) {
            this.close();
        } else {
            this.open();
        }
    };

    BoxMenu.prototype.handleMaxHeight = function () {
        var maxHeightChanged = false;

        this.boxMenuHeight = this.$box[0].scrollHeight;

        if (!isMobile && containerMaxHeight && containerMaxHeight < this.boxMenuHeight) {
            if (containerMaxHeight !== this.boxMenuMaxHeight) {
                this.boxMenuMaxHeight = containerMaxHeight;
                maxHeightChanged = true;
            }
        } else if (this.boxMenuHeight !== this.boxMenuMaxHeight) {
            this.boxMenuMaxHeight = this.boxMenuHeight;
            maxHeightChanged = true;
        }

        if (this.boxMenuIsActive && maxHeightChanged) {
            this.setMaxHeight();
        }
    };

    BoxMenu.prototype.setMaxHeight = function (customValue) {
        if (customValue !== undefined) {
            this.$box.css('max-height', customValue);
            this.$boxChild.css('min-height', customValue / 2);
        } else {
            if (isMobile) {
                this.$box.css('max-height', $(window).height());
            } else {
                this.$box.css('max-height', this.boxMenuMaxHeight);
                this.$boxChild.css('min-height', this.boxMenuMaxHeight / 2);
            }
        }
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        api.boxmenus.push(new BoxMenu($el));

        Cog.addListener('boxMenu', 'changeContainerMaxHeight', function (e) {
            if (e.eventData && e.eventData.maxHeight > 0) {
                containerMaxHeight = e.eventData.maxHeight;
                _.forEach(api.boxmenus, function (item) {
                    item.handleMaxHeight();
                });
            }
        });
    };

    Cog.registerComponent({
        name: 'boxMenu',
        api: api,
        selector: '.box-menu',
        requires: [
            {
                name: 'tabsMenu',
                apiId: 'tabsMenu'
            }
        ]
    });
})(Cog.jQuery());

/**
 * Home page icon navigation
 *
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el home page icons navigation wrapper
     * @constructor
     */

    function HomePageIconsNav($el) {
        this.$el = $el;
        this.$content = this.$el.find('> .component-content > .content');
        this.$navItems = this.$el.find('.navigation-item');
        this.$startButton = this.$el.find('.richText a');
        this.$startButtonClone = this.$startButton.clone(false);
        //BAR-1250
        //this.navigation();
        //this.attachEvents();
    }

    HomePageIconsNav.prototype.navigation = function () {
        var $iconMobileNavigationList = $('<ul/>');

        this.$iconMobileNavigation = $('<div class=\'iconMobileNavigation\'/>');
        this.$currentItem = $('<div class=\'currentItem\'/>');

        _.forEach(this.$navItems, function (item, index) {
            var $item = $(item),
                $itemClone = $item.clone(false),
                itemCloneHtml = $itemClone.html(),
                itemUrl = $item.find('a').attr('href');

            $iconMobileNavigationList.append($itemClone);

            if (index === 0) {
                this.$currentItem.append(itemCloneHtml);
                this.$startButtonClone.attr('href', itemUrl);
            } else {
                this.$iconMobileNavigation.append(this.$currentItem).append($iconMobileNavigationList);
                this.$iconMobileNavigation.append(this.$startButtonClone);
            }
        }.bind(this));

        this.$iconMobileNavigation.find('li').removeAttr('class');
        this.$content.append(this.$iconMobileNavigation);
        $iconMobileNavigationList.find('li:first').addClass('hide');
    };

    HomePageIconsNav.prototype.attachEvents = function () {
        this.$iconMobileNavigation.on('click', 'li > a', function (e) {
            var url = $(e.currentTarget).attr('href'),
                itemContent = $(e.currentTarget).parent().html();

            e.preventDefault();

            this.$startButtonClone.attr('href', url);
            this.$currentItem.empty().append(itemContent).removeClass('clicked');
            this.$iconMobileNavigation.find('li').removeClass('hide');
            $(e.currentTarget).parent('li').addClass('hide');
        }.bind(this));

        this.$currentItem.on('click', 'a', function (e) {
            e.preventDefault();
            $(this).parent().toggleClass('clicked');
        });
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new HomePageIconsNav($el));
    };

    Cog.registerComponent({
        name: 'HomePageIconsNav',
        api: api,
        selector: '.box-home-page-icons'
    });
})(Cog.jQuery());

/**
 *Box Extended
 *
 */

(function ($) {
    'use strict';

    /**
     *Public API 
     *
     */

    var api = {};

    api.boxExtended = [];

    function BoxExtended($el) {
        this.$el = $el;
        $el.addClass('box');
    }

    api.onRegister = function (scope) {
        var $boxes = scope.$scope;
        _.forEach($boxes, function (box) {
            var $box = $(box);
            api.boxExtended.push(new BoxExtended($box));
        });
    };

    Cog.registerComponent({
        name: 'boxExtended',
        api: api,
        selector: '.boxExtended'
    });
})(Cog.jQuery());

/**
 *Box Product card button same width
 *
 */

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {};

    api.boxProductCard = [];

    function BoxProductCard($el) {
        var $allButtons = $el.find('[class*=\'btn-\']'),
        maxButtonWidth = 0;

        $allButtons.each(function(i, e) {
            if($(e).outerWidth() > maxButtonWidth) {
                maxButtonWidth = $(e).outerWidth();
            }
        });

        $allButtons.css('min-width', maxButtonWidth);
    }

    api.onRegister = function (scope) {
        var $boxProductCard = scope.$scope;
        _.forEach($boxProductCard, function (boxProduct) {
            var $boxProduct = $(boxProduct);
            api.boxProductCard.push(new BoxProductCard($boxProduct));
        });
    };

    Cog.registerComponent({
        name: 'boxProductCard',
        api: api,
        selector: '.box-product-card'
    });
})(Cog.jQuery());

/**
 *Table button same width
 *
 */

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {};

    api.boxComparisonTableWrapper = [];

    function BoxComparisonTableWrapper($el) {
        var $allButtons = $el.find('[class*=\'btn-\']'),
            maxButtonWidth = 0;

        $allButtons.each(function(i, e) {
            if($(e).outerWidth() > maxButtonWidth) {
                maxButtonWidth = $(e).outerWidth();
            }
        });

        $allButtons.css('min-width', maxButtonWidth);
    }

    api.onRegister = function (scope) {
        var $boxComparisonTableWrapper = scope.$scope;
        _.forEach($boxComparisonTableWrapper, function (boxWrapper) {
            var $boxWrapper = $(boxWrapper);
            api.boxComparisonTableWrapper.push(new BoxComparisonTableWrapper($boxWrapper));
        });
    };

    Cog.registerComponent({
        name: 'boxComparisonTableWrapper',
        api: api,
        selector: '.box-comparison-table-column'
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {};

    api.swipeAction = [];

    function SwipeAction($el) {
        var $container = $el,
        $innerComponent = $container.find('.component-content'),
        $innerContent = $innerComponent.find('.content'),
        $maxScrollWidth =  $innerContent.width() - $innerComponent.width(),
        $swipe = '<div class=\'scroller-text\'>Swipe to see more</div>';
        $container.prepend($swipe);
        $swipe = $container.find('.scroller-text');

        $swipe.on('click touch', function() {
            $innerComponent.animate({scrollLeft: $maxScrollWidth}, 800);
            return false;
        });
    }

    api.onRegister = function (scope) {
        var $swipeAction = scope.$scope,
        status = this.external.status;

        if(status.isTablet()) {
            _.forEach($swipeAction, function (swipeContainer) {
                var $swipeContainer = $(swipeContainer);
                api.swipeAction.push(new SwipeAction($swipeContainer));
            });
        }
    };

    Cog.registerComponent({
        name: 'swipeAction',
        api: api,
        selector: '.show-to-scroll',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})(Cog.jQuery());

/**
 *Box Menu Redesign JS
 *
 */

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {};

    api.menuRedesigned = [];

    function RedesignedMenu($el) {
        this.$el = $el;
        this.menuTrigger = $('.richText-meganav-button');
        this.$body = $('body');
        this.$html = $('html');
        this.isMenuActive = false;
        this.attachEvents();
    }

    RedesignedMenu.prototype.attachEvents = function () {
        this.menuTrigger.on('click', this.onButtonClick.bind(this));
    };

    RedesignedMenu.prototype.onButtonClick = function () {
        if(this.isMenuActive) {
            this.closeMenu();
        } else {
            this.openMenu();
        }
    };

    RedesignedMenu.prototype.openMenu = function () {
        $(this.$el).addClass('is-active');
        this.isMenuActive = true;
        $(this.$body).addClass('box-menu-is-active');
        $(this.$html).addClass('no-scroll');
        Cog.fireEvent('boxMenu', 'open');
    };

    RedesignedMenu.prototype.closeMenu = function () {
        $(this.$el).removeClass('is-active');
        this.isMenuActive = false;
        $(this.$body).removeClass('box-menu-is-active');
        $(this.$html).removeClass('no-scroll');
    };

    api.onRegister = function (scope) {
        var $menus = scope.$scope;
        _.forEach($menus, function (menu) {
            var $menu = $(menu);
            api.menuRedesigned.push(new RedesignedMenu($menu));
        });
    };

    Cog.registerComponent({
        name: 'menuRedesigned',
        api: api,
        selector: '.box-menu-redesigned'
    });
})(Cog.jQuery());

/**
 *Box Scroll to me
 */

(function ($) {
    'use strict';

    /**
     *Public API
     */

    var api = {};

    api.scrollToMe = [];

    function ScrollToMe() {
        this.manageScroll();
    }

    ScrollToMe.prototype.manageScroll = function () {
        var sPageURL = window.location.search.substring(1);
        var sURLVariables = sPageURL.split('&');
        for (var i = 0; i < sURLVariables.length; i++) {
            var sParameterName = sURLVariables[i].split('=');
            if (sParameterName[0] == 'scrolltome') {
                $('.scroll-to-me').each(function () {
                    $(this).attr('id', $(this).find('.box-heading').text().replace(/\s/g, ''));
                });
                setTimeout(function () {
                    if ($('#' + sParameterName[1]).closest('.tabs').length > 0) {
                        $('#' + sParameterName[1]).closest('.tabs-content').removeClass('is-hidden')
                                    .siblings('.tabs-content').addClass('is-hidden');
                        var tabContentID = $('#' + sParameterName[1]).closest('.tabs-content').attr('id');
                        tabContentID = tabContentID.split('-');
                        tabContentID = tabContentID[2];
                        $('#' + sParameterName[1]).closest('.tabs-content').closest('.component-content')
                                    .find('.tabs-nav-list').children('li').eq(tabContentID)
                                    .addClass('is-active').siblings('li').removeClass('is-active');
                    }

                    if ($('#' + sParameterName[1]).closest('.accordion-slide').length > 0) {
                        $('#' + sParameterName[1]).closest('.accordion-slide')
                                    .addClass('is-active').closest('.accordion-slide')
                                    .find('.accordion-content-wrapper').css('max-height', '10000px');
                    }

                    var scrollTo = $('#' + sParameterName[1]).offset().top - Math.floor(window.innerHeight / 2);
                    $('html').animate({
                        scrollTop: scrollTo
                    }, 1000);
                }, 100);
            }
        }
    };

    api.onRegister = function () {
        api.scrollToMe.push(new ScrollToMe());
    };

    Cog.registerComponent({
        name: 'scrollToMe',
        api: api,
        selector: '.scroll-to-me'
    });
})(Cog.jQuery());

/**
 * Box button group is meant to group buttons in a parent variant so that  
 * we to perform some activity on the child items (each marked with some variant).
 */

 (function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.boxButtonGroup = [];

    function BoxButtonGroup($el) {
        this.$container = $el;
        this.hasSetWidthItems = this.$container.find('.richText-btn-equal-width').length > 1;
        this.$children = this.getEqualWidthChildren();
        this.btnWidths = this.getBtnWidths();
        
        this.attachEvents();
    }

    function isPhone(){
        return window.Modernizr.mq('only screen and (max-width: 480px)');
    }

    BoxButtonGroup.prototype.getEqualWidthChildren = function () {
        var $elements;

        if (this.hasSetWidthItems) {
            $elements = this.$container.find('[class*=\'btn-action\']');
        }
        return $elements;
    };

    BoxButtonGroup.prototype.getBtnWidths = function () {
        var btnWidths = [];

        _.forEach(this.$children, function (item) {
            var $child = $(item);
            btnWidths.push($child.width());
        });

        return btnWidths;
        
    };

    BoxButtonGroup.prototype.setBtnWidest = function () {
        var btnMaxWidth;

        this.btnWidths.sort(function(a, b){ return b-a; }); // Sort to place widest item first 

        btnMaxWidth = this.btnWidths[0];
        
        _.forEach(this.$children, function (item) {
            var $child = $(item);
            $child.width(btnMaxWidth);
        });

    };
    
    BoxButtonGroup.prototype.setMobileBtns = function () {

        _.forEach(this.$children, function (item) {
            var $child = $(item);
            $child.width('auto');
        });

    };

    BoxButtonGroup.prototype.adjustBtnWidth = function () {

        if( isPhone() ){
            this.setMobileBtns();
        } else {
            this.setBtnWidest();
        }

    };

    BoxButtonGroup.prototype.attachEvents = function () {
        $(window).on('resize orientationchange', _.debounce(function () {  
            this.adjustBtnWidth();
        }.bind(this), 300));
    };

    api.onRegister = function (scope) {
        var $boxes = scope.$scope;
        _.forEach($boxes, function (box) {
            var $box = $(box);
            api.boxButtonGroup.push(new BoxButtonGroup($box));
        });
    };

    Cog.registerComponent({
        name: 'boxButtonGroup',
        api: api,
        selector: '.box-btn-group'
    });

}(Cog.jQuery()));

/**
 * Box Card Cluster
 */

 (function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.boxClusterContainer = [];

    function BoxClusterContainer($el) {
        this.$container = $el;
        this.$inlineContainer = $el.find('.box-cluster-inline-container');
        this.inlineCards = this.$inlineContainer.find('.box-cluster-sgl-small, .box-cluster-dbl-img');
        this.inlineCardsCount = this.inlineCards.length;

        this.setupNavDots();
        this.attachEvents();
    }

    BoxClusterContainer.prototype.attachEvents = function () {
        var container = this.$inlineContainer,
            navDots = this.$inlineContainer.find('.dots');
        
        $(this.$inlineContainer.find('.dots:first-of-type')).addClass('active');

        navDots.on('click', function() {

            var cardsToShiftLeft = $(this).attr('data-index'),
                cardWidth = 280;
            
            container.scrollLeft(cardsToShiftLeft * cardWidth);

            $(this).addClass('active');

        });
        
        container.on('scroll', _.debounce(function(){

            var $navDots = $(this).find('.dots'),
                firstCardScrollXPosition = $(container).find('.box-cluster-sgl-small:first-of-type, .box-cluster-dbl-img:first-of-type').position().left,
                cardMaxWidth = 300,
                dataIndex = -1 * Math.round(firstCardScrollXPosition / cardMaxWidth);

                _.forEach( $navDots, function (navDot) {
                    var $navDot = $(navDot);
                    $navDot.removeClass('active');
                });

                $($($navDots)[dataIndex]).addClass('active');

        }, 300) );
    };

    BoxClusterContainer.prototype.setupNavDots = function () {
        this.createNavDotsMarkup();
    };

    BoxClusterContainer.prototype.createNavDotsMarkup = function () {

        var html = '<div id=\'dot-nav\'>';

        for(var i=0; i<this.inlineCardsCount; i++){
            html += '<div id=\'dot-nav-item_'+ i +' \' ' + ' class=\'dots\' ' + ' data-index=\''+ i +'\' />';
        }

        html += '</div>';

        this.$inlineContainer.find('> .component-content > .content').append(html);

    };

    api.onRegister = function (scope) {
        var $boxes = scope.$scope;
        _.forEach($boxes, function (box) {
            var $box = $(box);
            api.boxClusterContainer.push(new BoxClusterContainer($box));
        });
    };

    Cog.registerComponent({
        name: 'boxClusterContainer',
        api: api,
        selector: '.box-cluster-container'
    });

}(Cog.jQuery()));

/**
 * Breadcrumbs navigation
 */

(function ($) {
    'use strict';

    var api = {
            element: []
        },
        isTablet = checkTablet();

    function checkTablet() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    /**
     * Element class
     * @param $el breadcrumbs wrapper
     * @constructor
     */

    function Breadcrumbs($el) {
        this.$el = $el;
        this.$list = this.$el.find('.breadcrumbs-list');
        this.$listItems = this.$list.find('li');
        this.listWidth = this.$list.outerWidth();
        this.listScrollWidth = this.$list[0].scrollWidth;
        this.listOffset = this.$list.scrollLeft().valueOf();

        this.breadcrumbs();
        this.showLastThree();
        this.attachEvents();
    }

    Breadcrumbs.prototype.breadcrumbs = function () {
        this.listWidth = this.$list.width();
        this.handleBreadcrumbItems();
        if (isTablet) {
            this.$list.scrollLeft(this.listScrollWidth);
            this.$listItems.last().removeClass('is-faded');
        }
    };

    Breadcrumbs.prototype.handleBreadcrumbItems = function () {
        var sum = 0;

        this.$listItems.removeClass('is-faded');

        if (isTablet) {
            _.forEach(this.$listItems, function (item) {
                var $item = $(item),
                    itemWidth = $item.outerWidth(true),
                    itemOffset = $item[0].offsetLeft;

                sum = sum + itemWidth;

                if ((sum - this.listOffset) > this.listWidth || (itemOffset < this.listOffset)) {
                    $item.addClass('is-faded');
                }
            }.bind(this));
        }
    };

    Breadcrumbs.prototype.showLastThree = function () {
        var numListItem = this.$listItems.length,
            index;

        if(numListItem > 3 && !$(this.$el).hasClass('.breadcrumbs-redesign')) {
            $(this.$listItems).hide();
            for(index = 1; index < 4 ; index++ ){
                $(this.$listItems[numListItem - index]).css('display', 'inline-block');
            }
        }
    };

    Breadcrumbs.prototype.attachEvents = function () {
        $(window).on('resize', _.debounce(function () {
            isTablet = checkTablet();
            this.breadcrumbs();
        }.bind(this), 100));

        this.$list.on('scroll', _.debounce(function () {
            this.listOffset = this.$list.scrollLeft().valueOf();
            this.handleBreadcrumbItems();
        }.bind(this), 100));
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new Breadcrumbs($el));
    };

    Cog.registerComponent({
        name: 'breadcrumbs',
        api: api,
        selector: '.breadcrumbs'
    });
})(Cog.jQuery());
(function($) {
    'use strict';

    var api = {
        element: []
    };

    function Captcha(captcha) {
        var $captcha = $(captcha),
            $form = $captcha.closest('form');

        this.fillCaptcha($captcha, $form);
        this.verifyCaptcha($captcha, $form);
    }

    Captcha.prototype.fillCaptcha = function ($captcha, $form) {
        $captcha.load(removeifextradot(document.URL) + 
            '?timestamp=' + new Date().getTime() +
            ' .captcha.component', function() {
                $form.find('button[type=\'submit\']').removeClass('inactive');
        });
    };
    
    Captcha.prototype.verifyCaptcha = function($captcha, $form) {
        $form.submit(function(e) {
            var inputtext = $captcha.find('input[name=\'captchainput\']').val();
            if (inputtext == 'null' || inputtext == 'undefined') {
                e.preventDefault();
                e.stopImmediatePropagation();
                $captcha.css('display', 'inline');
            }
        });
    };

    function removeifextradot(stringURL) {
        var subStringURL = stringURL,
            dotIndex = stringURL.lastIndexOf('.');

        if(dotIndex > 27) {
            subStringURL = stringURL.substring(0, dotIndex);
        }

        return subStringURL;
    }

    api.onRegister = function(scope) {
        var $captchaList = scope.$scope;

        _.forEach($captchaList, function (captcha){
            var $captcha = $(captcha);
            api.element.push(new Captcha($captcha));
        });
    };

    Cog.registerComponent({
        name: 'captcha',
        api: api,
        selector: '.captcha.component'
    });
    
})(Cog.jQuery());

/**
 * Carousel
 */

(function($) {
	'use strict';

	var api = {};

	api.delay = 0;

	api.showSlide = function(nextIndex, context, delay, autoRotate) {
		clearTimeout(context.timerId);

		var current = context.slides.filter('.is-active'),
			currentIndex = current.index();

		nextIndex = (nextIndex < 0) ? (context.slides.length - 1) :
			((nextIndex >= context.slides.length) ? 0 : nextIndex);

		if (Number(nextIndex) !== Number(currentIndex)) {
			context.slides.stop(true, true);

			current.removeClass('is-active').fadeOut(function() {
				$(this).removeClass('is-active');
				context.controls.removeClass('is-active').eq(nextIndex).addClass('is-active');
			});

			context.slides.eq(nextIndex).fadeIn(function() {
				$(this).addClass('is-active');
			});
		}

		if (delay > 0 && autoRotate !== false) {
			context.timerId = setTimeout(function() {
				api.showSlide(nextIndex + 1, context, delay, autoRotate);
			}, delay * 1000);
		}
	};

	api.onRegister = function(scope) { // todo breakdown

		var $carousel = scope.$scope,
			$slideNav = $carousel.find('.carousel-nav'),
			$slideControls = $slideNav.find(
				'li:not(.carousel-nav-prev):not(.carousel-nav-next)'),
			$slidesList = $carousel.find('.carousel-slides'),
			$slides = $slidesList.find('.carousel-slide'),
			$dummy = $carousel.find('.dummy-slide'),
			slidesMaxHeight = $slidesList.outerHeight(),
			delay = 0,
			autoRotate = $slidesList.data('rotate'),

			context = {
				slides: $slides,
				controls: $slideControls
			},
			status = this.external.status,
			resizeView = function() {
				// due to dynamic content in author, disabled auto-hide there
				if (status.isAuthor()) {
					return;
				}
				var maxHeight = 0;
				var height = $dummy.height();
				maxHeight = height > maxHeight ? height : maxHeight;

				if (slidesMaxHeight) {
					if (maxHeight < slidesMaxHeight) {
						maxHeight = slidesMaxHeight;
					}
				}
				$slidesList.css('height', maxHeight + 'px');
			};

		$(window).resize(_.throttle(function() {
			resizeView();
		}, 250));
		resizeView();

		delay = $slidesList.data('delay') || 0;

		$slides.hide().first().show();

		$slideNav.on('click', 'a', function(e) {
			e.preventDefault();
			e.stopPropagation();

			var $parent = $(this).parent(),
				index = $slideControls.index($parent);

			if ($parent.is('.carousel-nav-prev,.carousel-nav-next')) {
				index = $slides.filter('.is-active').index();
				index = $parent.hasClass('carousel-nav-prev') ? index - 1 : index + 1;
			}
			api.showSlide(index, context);
		});


		if (delay > 0 && autoRotate !== false) {
			context.timerId = setTimeout(function() {
				api.showSlide(1, context, delay, autoRotate);
			}, delay * 1000);
		}
	};

	Cog.registerComponent({
		name: 'carousel',
		api: api,
		selector: '.carousel',
		requires: [
			{
				name: 'utils.status',
				apiId: 'status'
			}
		]
	});
})(Cog.jQuery());

/**
 * Category navigation
 */

/* jshint maxlen: 500 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function CategoryNavigation($el) {
        this.$el = $el;
        this.navigation();
    }

    CategoryNavigation.prototype.navigation = function () {
        var $current = this.$el.find('.is-current'),
            $categoryNavigationList = this.$el.find('.categoryNavigationList');
            $categoryNavigationList.find('input').on('click',function (e) {
                changeURL(e.target);
            });

        $current.unbind('click').click(function (e) {
            var $this = $(this),
                $target = $this.next();

            e.preventDefault();

            if ($target.hasClass('active')) {
                $target.removeClass('active').slideUp();
            } else {
                $categoryNavigationList.filter('.active').removeClass('active').slideUp();
                $target.addClass('active').slideDown();
            }
        });



        function changeURL(input) {
            var value = $(input).attr('value');
            var url = window.location.href;
            var type = '&type=';

            if (value === 'all') {
                url = url.substring(0, url.indexOf(type));
            }
            else if (url.search(type) < 0) {
                url += type + value;
            } else {
                var categories = url.substring(url.lastIndexOf(type) + type.length);
                if (categories.search(value) < 0) {
                    url += ',' + value;
                } else {
                    if (categories.lastIndexOf(value) === 0) {

                        if (categories === value) {
                            url = url.substring(0, url.indexOf(type));
                        } else {
                            url = url.substring(0, url.indexOf(value + ',')) + categories.substring(value.length + 1);
                        }
                    } else {
                        url = url.substring(0, url.lastIndexOf(value) - 1) + url.substring(url.lastIndexOf(',' + value)).substring(value.length + 1);
                    }
                }
            }
            window.location.href = url;
            window.reload();
        }

    };


    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new CategoryNavigation($el));
    };

    Cog.registerComponent({
        name: 'categoryNavigation',
        api: api,
        selector: '.categoryNavigation'
    });
})(Cog.jQuery());

/**
 * Divider
 */

/**
 * DropdownSearch
 */

(function() {
	'use strict';

	var api = {
	    element: [],
	    dataFeeds: getOptions(),
	    selectedOptionTicker: ''
	};

    function DropdownSearch(element, index) {
        createOptions(index);
        bindFilterSearch(element, index);
    }

    function bindFilterSearch(elem, index) {
        var input = document.getElementsByClassName('dropdownSearch__input')[index],
            btn = document.getElementsByClassName('dropdownSearch__button')[index];

        input.addEventListener('keyup', function (){
            filterShares(index);
        });

        input.addEventListener('focusout', function () {
            setTimeout(function () {
                showDrawer(false, index);
            }, 200);
        });

        input.addEventListener('focusin', function() {
            showDrawer(true, index);
        });

        btn.addEventListener('click', function() {
            setTickerInURl();
        });
    }

    function filterShares(index) {
        var input = document.getElementsByClassName('dropdownSearch__input')[index],
            filter = input.value.toUpperCase(),
            options = document.getElementsByClassName('dropdownSearch__option'),
            result;

        _.forEach(options, function(option) {
            result = option.textContent || option.innerText;

            if (result.toUpperCase().indexOf(filter) > -1) {
                option.style.display = 'block';
                showDrawer(true, index);
            } else {
                option.style.display = 'none';
            }
        });
    }

    function showDrawer(visible, index) {
        var drawer = document.getElementsByClassName('dropdownSearch__drawer-container')[index];
        var inputWrapper = document.getElementsByClassName('dropdownSearch__input-wrapper')[index];

        if (visible) {
            if (!drawer.classList.contains('dropdownSearch__drawer-container--expanded')) {
                drawer.classList.add('dropdownSearch__drawer-container--expanded');
            }
            if (!inputWrapper.classList.contains('dropdownSearch__input-wrapper--expanded')) {
                inputWrapper.classList.add('dropdownSearch__input-wrapper--expanded');
            }
        } else {
            if (!visible) {
                if (drawer.classList.contains('dropdownSearch__drawer-container--expanded')) {
                    drawer.classList.remove('dropdownSearch__drawer-container--expanded');
                }
                if (inputWrapper.classList.contains('dropdownSearch__input-wrapper--expanded')) {
                    inputWrapper.classList.remove('dropdownSearch__input-wrapper--expanded');
                }
            }
        }
    }

    function getOptions() {
        if(document.getElementsByClassName('dataFeeds shareInformation').length > 0) {
            return JSON.parse(document.getElementsByClassName('dataFeeds shareInformation')[0]
																.getAttribute('shareInformation'));
        }
        return;
    }

    function createOptions(index) {
        if (api.dataFeeds) {
            for(var i = 0; i <= Object.keys(api.dataFeeds).length -1; i++) {
                var feed = api.dataFeeds[Object.keys(api.dataFeeds)[i]],
                    ticker = feed.ticker,
                    companyName = feed.companyName,
                    optionsWrapper = document.getElementsByClassName('dropdownSearch__drawer-wrapper')[index],
                    optionElem = document.createElement('li');

                optionElem.innerHTML = ticker + ' - ' + companyName;
                optionElem.classList.add('dropdownSearch__option');
                bindEventForOptions(optionElem, ticker, index);
                optionsWrapper.appendChild(optionElem);
            }
        }
    }

    function bindEventForOptions(optionElem, ticker, index) {
        optionElem.addEventListener('click', function() {
            selectOption(ticker, index);
        });
    }

    function selectOption(ticker, index) {
        api.selectedOptionTicker = ticker;
        setInputValue(ticker, index);
    }

    function setInputValue(ticker, index) {
        var option = api.dataFeeds[ticker],
            input = document.getElementsByClassName('dropdownSearch__input')[index],
            inputValue = option.ticker + ' - ' + option.companyName;

        input.value = '';
        input.value = inputValue;
    }

    function setTickerInURl() {
        var ticker = api.selectedOptionTicker;
        window.tickerObj.ticker = ticker;
        // send ticker to calculator
    }

	api.onRegister = function(scope) {
        var dropdownSearchElements = scope.$scope;

        _.forEach(dropdownSearchElements, function (dropdownSearchElement, index) {
            api.element.push(new DropdownSearch(dropdownSearchElement, index));
        });
	};

	Cog.registerComponent({
		name: 'dropdownSearch',
		api: api,
		selector: '.dropdownSearch__container'
	});
})(Cog.jQuery());

/**
 * File list
 */
/**
 * Flash
 */

/**
 * Form
 */

/* jshint maxlen: 200 */

(function($) {
    'use strict';
    var api = {},
        status,
        clearForm,
        resetForm,
        manualInputs,
        radioInputs,
        validateField,
        markAsInvalid,
        markAsValid,
        enableSubmit,
        disableSubmit,
        isValidType,
        enableDropdown;

    enableDropdown = function($form) {
        if (document.getElementById('refurl')) {
            document.getElementById('refurl').value = getRefURL();
        }

        var countryElement = document.querySelector('meta[name=\'country\']');
        var country = countryElement && countryElement.getAttribute('content');

        var countryParamElement = $form.context.querySelector('#countryParameter'); // To be used for product segments
        var countrySegmentParam = countryParamElement && countryParamElement.getAttribute('value');

        var productSegmentParamElement = $form.context.querySelector('#productSegmentParameter');
        var productSegmentParam = productSegmentParamElement && productSegmentParamElement.getAttribute('value');

        var regionSelect = $form.find('#region');
        var townSelect = $form.find('#town');
        var branchSelect = $form.find('#branch');
        var branchesSelect = $form.find('#branches');
        var productSelect = $form.find('#product');

        if( branchesSelect.length > 0 ){
            showElementsOnAuthor();
            getDmpId();
  
            if (document.getElementById('sourceurl')) {
                document.getElementById('sourceurl').value = getUrlwithParams();
            }
  
            getBranchesFromService(branchesSelect, country);
            getProductFromService(productSelect, countrySegmentParam, productSegmentParam);
              
        } else if (regionSelect.length > 0){
            var town = $form.find('.town'), 
                branch = $form.find('.branch');

            showElementsOnAuthor();
            getDmpId();

            if (document.getElementById('sourceurl')) {
                document.getElementById('sourceurl').value = getUrlwithParams();
            }

            if (status.isAuthor()) {
                $(town).css('height', '85px');
                $(branch).css('height', '85px');
            }

            getProductFromService(productSelect, countrySegmentParam, productSegmentParam);
            getRegionFromService(regionSelect, country);

            regionSelect.on('change', function() {
                var regionid = this.value;
                if (regionid !== $(this).find('option:first-child').val()) {
                    getTownFromService(townSelect, regionid, country);
                    $(town).css('height', '85px');
                    $(branch).css('height', '0px');
                } else {
                    $(town).css('height', '0px');
                    $(branch).css('height', '0px');
                }
            });

            townSelect.on('change', function() {
                var townid = this.value;
                if (townid != $(this).find('option:first-child').val()) {
                    getBranchFromService(branchSelect, townid, country);
                    $(branch).css('height', '85px');
                } else {
                    $(branch).css('height', '0px');
                }
            });
        }
    };

    function getProductFromService(productSelect, country, productSegment) {
        $.getJSON('/bin/product', {
                'country': country,
                'productSegment': productSegment
            },
            function(data) {
                var productarray = JSON.parse(data.reference);
                var listitems = ' ';
                $.each(productarray, function(i, item) {
                    //populating select if not 404
                    if (item == '404') {
                        return false;
                    } else {
                        listitems += '<option value=' + item.id + '>' + item.product_title + '</option>';
                    }
                });
                $(productSelect).append(listitems);
            });
    }
    
    function getRegionFromService(regionSelect, country) {
        $.getJSON('/bin/region', {
                'country': country
            },
            function(data) {
                var regionarray = JSON.parse(data.reference);
                var listitems = ' ';
                $.each(regionarray, function(i, item) {
                    //populating select
                    listitems += '<option value=' + item.id + '>' + item.region_title + '</option>';
                    //
                });
                $(regionSelect).append(listitems);
            });
    }
    
    function getTownFromService(townSelect, regionid, country) {
        $.getJSON('/bin/town', {
                'country': country,
                'regionid': regionid
            },
            function(data) {
                var townarray = JSON.parse(data.reference);
                var listitems = ' ';
                $(townSelect).find('option').not(':first').remove();
                $.each(townarray, function(i, item) {
                    //populating select
                    listitems += '<option value=' + item.id + '>' + item.town_name + '</option>';
                    //
                });
                $(townSelect).append(listitems);
            });
    }

    function getBranchFromService(branchSelect, townid, country) {
        $.getJSON('/bin/branch', {
                'country': country,
                'townid': townid
            },
            function(data) {
                var townarray = JSON.parse(data.reference);
                var listitems = ' ';
                $(branchSelect).find('option').not(':first').remove();
                $.each(townarray, function(i, item) {
                    //populating select
                    listitems += '<option value=' + item.id + '>' + item.branch_name + '</option>';
                    //
                });
                $(branchSelect).append(listitems);
            });
    }

    function getBranchesFromService(branchesSelect, country) {
        $.getJSON('/bin/branches', {
                'country': country
            },
            function (data) {
                var brancharray = JSON.parse(data.reference);
                var listitems = ' ';
                $(branchesSelect).find('option').not(':first').remove();
                $.each(brancharray, function (i, item) {
                    //populating select
                    if (item == '404') {
                        return false;
                    } else {
                    listitems += '<option value=' + item.id + '>' + item.branch_name + '</option>';
                    }
                });
                $(branchesSelect).append(listitems);
            });
    }

    function getUrlwithParams() {
        return window.location.href;
    }

    function getRefURL() {
        var ref = document.referrer;
        if (ref == '') {
            ref = window.location.href;
        }
        return ref;
    }

    function getDmpId() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                document.getElementById('dmpid').value = this.responseText;
            }
        };
        xhttp.open('GET', '//dsp-aud.eskimi.com/pixelGet', true);
        xhttp.withCredentials = false;
        xhttp.send();
    }

    function showElementsOnAuthor() {
        if (status.isAuthor()) {
            var sourceurl = document.getElementsByClassName('toHideFieldOnPublish');
            if (sourceurl.length > 0) {
                for (var i = 0; i < sourceurl.length; i++) {
                    sourceurl[i].style.display = 'block';
                }
            }
        }
    }

    enableSubmit = function($form) {
        $form.find('button[type=\'submit\']').removeClass('disabled');
    };

    disableSubmit = function($form) {
        $form.find('button[type=\'submit\']').addClass('disabled');
    };

    clearForm = function($form, oldbrowser) {
        $form.find('input:text, input:password, input:file, select, textarea').val('');
        $form.find('input:radio').prop('checked', false);
        $form.find('input:checkbox').prop('checked', false);

        if (oldbrowser) {
            $form.find('input:text, input:password, input:file, select, textarea').blur();
        }
    };

    resetForm = function($form) {
        $form[0].reset();
        $form.find('input, textarea').blur();
    };

    markAsInvalid = function($field) {
        $field.addClass('error').removeClass('success');
    };

    markAsValid = function($field) {
        $field.removeClass('error').addClass('success');
    };

    isValidType = function(type, value) { // @todo: requires ZG improvements
        var result = false;

        if (type === 'email') {
            /*jslint maxlen: 500 */
            result = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(value);
        } else if (type === 'number') {
            result = /^\d*$/.test(value);
        } else if (type === 'phonecall' || type === 'phonesms') {
            //checks for whether it is a telephone number
            result = /\(?([0-9]{3})\)?([ .-]?)([0-9]{3})\2([0-9]{4})/.test(value);
        }

        return result;
    };

    validateField = function($field, $form) {
        var isRequired = false,
            $input = $field.find('input, textarea, select'),
            value = $input.val();

        if ($field.closest('.form-element').find('.required').length) {
            isRequired = true;
        }

        if (isRequired && $input.attr('name') === 'email') {
            if (!value && $input.is(':checked')) {
                markAsInvalid($field);
            } else if (!isValidType($input.attr('name'), value)) {
                markAsInvalid($field);
            } else {
                markAsValid($field);
                enableSubmit($form);
            }
        }

        if (isRequired && $input.attr('name') != 'email') {
            if (value === '') {
                markAsInvalid($field);
                disableSubmit($form);
            } else {
                markAsValid($field);
                enableSubmit($form);
            }
        }

    };

    enableSubmit = function($form) {
        $form.find('button[type=\'submit\']').removeClass('disabled');
    };

    radioInputs = (function() {

        function readEmail($input, $form) {
            var $type = 'email',
                $eStatement = $input.closest('.box').find('input[name=emailstatement]'),
                $eControlGroup = $eStatement.closest('.control-group');

            $($eStatement).on('blur', function() {
                if ($eStatement.val() !== '') {
                    if (isValidType($type, $eStatement.val())) {
                        markAsValid($eControlGroup);
                        enableSubmit($form);
                    } else {
                        markAsInvalid($eControlGroup);
                        disableSubmit($form);
                    }

                } else {
                    markAsInvalid($eControlGroup);
                }
            });
        }

        return function($inputs, $form) {
            $inputs.each(function(i, input) {
                var $input = $(input),
                    $emailStatement = $input.closest('.box').find('input[name=emailstatement]');

                $($input).on('click', function() {
                    if ($input.attr('name') === 'estatement') {

                        if ($input.val() === 'Yes') {

                            if (isValidType('email', $emailStatement.val())) {
                                markAsValid($emailStatement.closest('.control-group'));
                            } else {
                                markAsInvalid($emailStatement.closest('.control-group'));
                            }

                            readEmail($input, $form);

                        } else {
                            $emailStatement.closest('.control-group').removeClass('error').removeClass('success');
                        }
                    }
                });
            });

        };
    })();

    // Inputs are hidden, image in label's background is shown instead
    manualInputs = (function() {
        function applyStyle($input, $label) {
            var $closestParentBox,
                $adjacentBox,
                $textBoxControl,
                $textBoxInput,
                $textBoxInputEl,
                $textBoxInputEmailEl,
                $textBoxInputVal;

            $closestParentBox = $label.closest('.box');
            $adjacentBox = $closestParentBox.next();
            $textBoxControl = $adjacentBox.find('.control-group');
            $textBoxInput = $adjacentBox.find('input[type=\'text\']');
            $textBoxInputEl = $adjacentBox.find('input[name^=\'phone\']');
            $textBoxInputEmailEl = $adjacentBox.find('input[name=\'email\']');

            if ($input.is(':checked')) {
                $label.addClass('checked');

                if ($textBoxControl.length !== 0) {
                    if ($textBoxInput.val().length >= 10) {
                        markAsValid($textBoxControl);
                    } else {
                        markAsInvalid($textBoxControl);
                    }

                    if ($textBoxInput.attr('name') != 'email') {

                        $($textBoxInput).on('blur', function() {

                            $textBoxInputVal = $textBoxInputEl.val();

                            if (isValidType($textBoxInput.attr('name'), $textBoxInputVal)) {
                                markAsValid($textBoxControl);
                            } else {
                                markAsInvalid($textBoxControl);
                            }
                        });

                    } else {

                        if (isValidType($textBoxControl.find('input').attr('name'), $textBoxControl.find('input').val())) {
                            markAsValid($textBoxControl);
                        } else {
                            markAsInvalid($textBoxControl);
                        }

                        $($textBoxInputEmailEl).on('blur', function() {
                            if (isValidType($textBoxControl.find('input').attr('name'), $textBoxControl.find('input').val())) {
                                markAsValid($textBoxControl);
                            } else {
                                markAsInvalid($textBoxControl);
                            }
                        });
                    }
                }

            } else {
                //when the checkbox is unchecked, make the textfield blue again (default)

                if ($textBoxInputEmailEl.length === 1) {
                    $($textBoxInputEmailEl).on('blur', function() {
                        $textBoxControl.removeClass('error');
                        $textBoxControl.removeClass('success');
                    });
                }

                $textBoxInputEmailEl.unbind();
                $($textBoxInputEl).unbind();
                $label.removeClass('checked');
                $textBoxControl.removeClass('error');
                $textBoxControl.removeClass('success');
            }
        }

        return function($inputs) {
            $inputs.each(function(i, input) {
                var $input = $(input),
                    $label = $input.parents('.control-group').first().find('label'),
                    $span = $('<span class=\'checkbox-label-text\' />');

                $label.wrapInner($span);
                $input.prependTo($label);

                $label.on('click', function(ev) {
                    ev.preventDefault();
                    input.checked = !input.checked;
                    $input.trigger('change');
                });

                applyStyle($input, $label);
                $input.on('change', function() {
                    applyStyle($input, $label);
                });
            });
        };
    })();

    function textareaMaxLength(elem) {
        var $textarea = $(elem);

        if (!$textarea.attr('maxlength')) {
            return;
        }

        $textarea.on('change keyup', function() {
            var maxlength = $textarea.attr('maxlength'),
                val = $textarea.val();

            if (val.length > maxlength) {
                $textarea.val(val.substring(0, maxlength));
            }
        });
    }

    function textareaHandleAutoResize(elem) {
        var $textarea = $(elem),
            initialHeight = $textarea.height();

        function autoResize() {
            $textarea.height(initialHeight);

            if ($textarea[0]) {
                $textarea.height($textarea[0].scrollHeight);
            }
        }

        $textarea.on('keydown', function() {
            _.defer(autoResize);
        });
    }

    function handleForm($form, disabledMessage, browser) {

        // Disable validation of HTML5 form to be compatible with old validation
        $form.find('form').attr('novalidate', '');

        var $inputs = $form.find('input:not([type=\'radio\']):not([type=\'checkbox\']), textarea, select');

        enableDropdown($form);

        // Fix for IE <= 8 not supporting :focus styling. Needed for focused field border.
        if (browser.msie && browser.version <= 8) {
            $inputs.on('focus blur', function() {
                $(this).toggleClass('input-focus-border-fix');
            });
        }

        // Fix implementing maxlength behaviour for textareas in browsers that
        // don`t support HTML5`s maxlength attribute.

        (function handleTextarea() {
            var $textareas = $form.find('textarea');

            _.forEach($textareas, function(textarea) {
                textareaMaxLength(textarea);
                textareaHandleAutoResize(textarea);
            });
        })();

        _.forEach($inputs, function(input) {
            var $input = $(input),
                $field = $input.parents('.control-group').first();

            $input.on('change blur', _.debounce(function() {
                validateField($field, $form);
            }, 300));
        });

        //disabling submit button if there are checked elements whose text filled have not been filled.
        disableSubmit($form);

        $form.on('change', function() {
            if ($form.find('div').hasClass('error')) {
                disableSubmit($form);
            } else {
                enableSubmit($form);
            }
        });

        manualInputs($form.find('input[type=checkbox]'));
        radioInputs($form.find('input[type=radio]'), $form);

        $form.find('button.clearButton').on('click', function() {
            clearForm($(this.form));
        });

        if (browser.msie && browser.version < 10) {
            $form.on('click', 'button.clearButton', function() {
                clearForm($(this.form), true);
            });

            $form.find('input.reset').bind('click', function(e) {
                e.preventDefault();
                resetForm($(this.form));
            });

            $form.find('button.editSubmit').bind('click', function(e) {
                if (!$('body').hasClass('cq-wcm-edit')) { // TODO there should be no author snippets here
                    return true;
                }
                e.preventDefault();
                window.alert(disabledMessage);
            });
        } else {
            $form.on('click', 'button.clearButton', function() {
                clearForm($(this.form));
            });

            $form.on('click', 'button[type=\'submit\']', function(e) {
                var $button = $(this);

                if ($button.hasClass('inactive')) {
                    e.preventDefault();
                    return false;
                } else {
                    $button.addClass('inactive');
                }
            });

            $form.find('button.editSubmit').on('click', function(e) {
                if (!$('body').hasClass('cq-wcm-edit')) { // TODO there should be no author snippet here
                    return true;
                }
                e.preventDefault();
                window.alert(disabledMessage);
            });
        }
    }

    api.onRegister = function(scope) {
        var disabledMessage = 'Submit functionality is disabled' +
            ' in Edit mode - switch to Preview mode to use it.',
            browser = this.external.browser;
        status = this.external.status;

        _.forEach(scope.$scope, function(form) {
            handleForm($(form), disabledMessage, browser);
        });

    };

    Cog.registerComponent({
        name: 'form',
        api: api,
        selector: '.form',
        requires: [{
                name: 'utils.browser',
                apiId: 'browser'
            },
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));

(function($) {

    'use strict';

    var api = {
            element: []
        },
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch'),
        countryMetadata = document.querySelector('meta[name=\'country\']'),
        country = countryMetadata && countryMetadata.getAttribute('content');

    function ProductSegmentation($el) {
        this.$el = $el;

        if (!isAuthor) {
            this.fetchProductSegments();
        }
    }

    ProductSegmentation.prototype.fetchProductSegments = function() {
        $.getJSON('/bin/productsegment', {
                'country': country
            },
            function(data) {
                var productarray = JSON.parse(data.reference);
                console.log(productarray);
            });
    };

    api.onRegister = function(scope) {
        api.element.push(new ProductSegmentation(scope.$scope));
    };

    Cog.registerComponent({
        name: 'productSegmentation',
        api: api,
        selector: '.form.segment-products'
    });

})(Cog.jQuery());

(function($) {

    'use strict';

    var api = {
        validateForm: []
    };

    function ValidateForm($el) {
        this.$el = $el;
        this.bindUIevents(this.$el);
    }

    ValidateForm.prototype.bindUIevents = function($form) {
        $form.find('input[type=\'number\']').on('keyup', function() {
            limitText(this, 10);
        });

        $form.find('input[name=\'contactNo\']').on('keyup', function() {
            limitText(this, 10);
        });

        $form.find('input[name=\'firstName\']').on('keyup', function() {
            limitText(this, 40);
        });

        $form.find('input[name=\'lastName\']').on('keyup', function() {
            limitText(this, 40);
        });
    };

    function limitText(field, maxChar) {
        var $field = $(field),
            valNumber = $field.val();

        if (valNumber.length >= maxChar) {
            $field.val(function() {
                return valNumber.substr(0, maxChar);
            });
        }
    }

    api.onRegister = function(scope) {
        api.validateForm.push(new ValidateForm(scope.$scope));
    };

    Cog.registerComponent({
        name: 'validateForm',
        api: api,
        selector: '.form.validate-dialer-form, .form.validate-form'
    });

})(Cog.jQuery());

/**
 * Date picker component
 */

(function($) {

    'use strict';

    var api = {
            validateDate: []
        },
        mos = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        day = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'],
        month = 0,
        year = 0;

    function ValidateDate($el) {
        var dates = new Date();
        year = dates.getFullYear();
        month = dates.getMonth();
        buildPicker($el);
        getDays();
        this.bindUIevents($el);
    }

    // All the events

    ValidateDate.prototype.bindUIevents = function($el) {
        var field = $('input[type=text]');
        $el.find(field).on('click touch', function(e) {
            $('.datepicker').css('display', 'none');
            $(e.target).closest('.component-content').siblings('.datepicker').css('display', 'block');
        });

        $el.find('.picker-close').on('click touch', function() {
            $('.datepicker').css('display', 'none');
        });

        $el.on('click touch', '.day-button', function(e) {
            $(e.target).closest('.component-content').find(field).val(year + '-' + ('0' + (month + 1)).slice(-2) + '-' + ('0' + e.target.value).slice(-2));
            $('.datepicker').css('display', 'none');
        });

        $el.find('.next-month').click(function() {
            if (month < 11) {
                month = month + 1;
                getDays();
            }
        });

        $el.find('.prev-month').click(function() {
            if (month > 0) {
                month = month - 1;
                getDays();
            }
        });

        $el.find('.next-y').click(function() {
            year = year + 1;
            getDays();
        });

        $el.find('.prev-y').click(function() {
            year = year - 1;
            getDays();
        });
    };

    // Basic HTML of the datepicker

    function buildPicker($field) {
        $field.append('<div class=\'datepicker\' style=\'display:none\'>' +
            '<div class=\'picker-close\'></div>' +
            '<div class=\'year-selector\'><span class=\'prev-y\'></span> ' +
            '<span class=\'year\'></span>' +
            '<span class=\'next-y\'></span></div>' +
            '<div class=\'month-selector\'><span class=\'prev-month\'></span>' +
            '<span class=\'month\'></span>' +
            '<span class=\'next-month\'></span></span></div>' +
            '<table class=\'dt-able\' ><td class=\'day_val\'> </td></table>');
    }

    // Populates the days on the date picker 
    // TODO Add previous month's and next month's days.

    function getDays() {
        $('.year').text(year);
        $('.month').text(mos[month]);
        $('.dt-able').empty();

        for (var i = 0; i < 7; i++) {
            $('.dt-able').append('<td class=\'dt-head\'>' + day[i] + '</td>');
        }

        var firstDay = new Date(year, month, 1),
            lastDay = new Date(year, month + 1, 0),
            countDays = new Date(year, month + 1, 0).getDate(),
            offset = firstDay.getDay(),
            dayCount = 1,
            defaultRows = 5;
        if (countDays + offset > 35) {
            defaultRows = 6;
        }
        for (var j = 0; j < defaultRows; j++) {
            $('.dt-able').append('<tr class=row-' + j + '>');
            for (var rw = 0; rw < 7; rw++) {
                if (offset == 0) {
                    $('.' + 'row-' + j).append('<td  class=\'' + 'cell-' + dayCount + '\'>' +
                        '<input type=\'button\' class=\'day-button\' value=\'' + dayCount + '\'></td>'
                    );

                    if (dayCount >= lastDay.getDate()) {
                        break;
                    }

                    dayCount++;
                } else {
                    $('.' + 'row-' + j).append('<td>' + '</td>');
                    offset--;
                }
            }
            $('.dt-able').append('</tr>');
        }
    }

    api.onRegister = function(scope) {
        var $datePickers = scope.$scope;
        _.forEach($datePickers, function(datePicker) {
            var $datePicker = $(datePicker);
            api.validateDate.push(new ValidateDate($datePicker));
        });
    };

    Cog.registerComponent({
        name: 'validateDate',
        api: api,
        selector: '.date-picker'
    });
})(Cog.jQuery());

//Star rating component for ARO use below

(function() {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function StarReting($el) {
        this.$el = $el;
        this.form();
    }

    StarReting.prototype.form = function() {

        var starContainer = $(this.$el).find('.star-rating').find('.control-group');

        starContainer.each(function() {
            var starOptions = $(this).find('option');

            $(this).find('.controls').css('display', 'none');
            $(this).append('<div class=\'inner-star-container\'></div>');
            var innerContainer = $(this).find('.inner-star-container');

            starOptions.each(function(index) {
                var newindex = index + 1;
                innerContainer.append('<div class=\'star\' value=\'' + newindex + '\'>' + newindex + '</div>');
            });

            if ($(this).closest('.star-rating').hasClass('rating-satisfied')) {
                innerContainer.append('<div class=\'star-wording\'><span>Not satisfied at all</span><span>Extremely satisfied</span></div>');
            } else if ($(this).closest('.star-rating').hasClass('rating-agree')) {
                innerContainer.append('<div class=\'star-wording\'><span>Strongly disagree</span><span>Strongly agree</span></div>');
            } else if ($(this).closest('.star-rating').hasClass('rating-likely')) {
                innerContainer.append('<div class=\'star-wording\'><span>Not likely at all</span><span>Extremely likely</span></div>');
            }
        });

        $('.star').hover(
            function() {
                $(this).addClass('active-star');
                $(this).prevAll('.star').addClass('active-star');
                $(this).nextAll('.star').removeClass('active-star');
            },
            function() {
                $(this).removeClass('active-star');
                $(this).prevAll('.star').removeClass('active-star');
                $(this).nextAll('.star').removeClass('active-star');
            }
        ).click(
            function() {
                $(this).addClass('perm-active-star');
                $(this).prevAll('.star').addClass('perm-active-star');
                $(this).nextAll('.star').removeClass('perm-active-star');
                $(this).closest('.star-rating').find('select').val($(this).attr('value'));
            }
        );
    };

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        api.element.push(new StarReting($el));
    };

    Cog.registerComponent({
        name: 'starRating',
        api: api,
        selector: '.form-star-rating'
    });
})(Cog.jQuery());

//Page rating component Help section

(function() {
    'use strict';

    var api = {
        element: []
    };

    function PageRating($el) {
        this.$el = $el;
        $(this.$el).addClass('step-one');
        this.attachEvents();
    }

    PageRating.prototype.attachEvents = function() {
        var checkedBoxes = false;

        $(this.$el).find('.button-yes-option').on('click', function() {
            $(this).closest('.form').addClass('step-three').removeClass('step-one');
        });

        $(this.$el).find('.button-no-option').on('click', function(e) {
            e.preventDefault();
            $(this).closest('.form').addClass('step-two').removeClass('step-one');
        });

        $(this.$el).find('.checkboxField').on('click', function() {
            $('.checkboxField').each(function() {
                if($(this).find('.control-label').hasClass('checked')) {
                    checkedBoxes = true;
                    return false;
                } else {
                    checkedBoxes = false;
                }
            });

            if(checkedBoxes) {
                $(this).siblings('.formButton').find('.button').removeClass('disabled');
            } else {
                $(this).siblings('.formButton').find('.button').addClass('disabled');
            }
        });
 
        $(this.$el).find('form').submit(function(e) {
            e.preventDefault();
            $(this).closest('.form').addClass('step-three').removeClass('step-one').removeClass('step-two');
            $.ajax({
                type: $(this).attr('method'),
                url: $(this).attr('action'),
                data: $(this).serialize(),
                success: function() {
                    $(this).closest('.form').addClass('step-three').removeClass('step-one').removeClass('step-two');
                }
            });
        });
    };

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        api.element.push(new PageRating($el));
    };

    Cog.registerComponent({
        name: 'pageRating',
        api: api,
        selector: '.form-rating-component'
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {};
    var betaBreakpoint = 480;

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        var $els = $el.find('.richText-big-icon-showcase');

        setMaxHeight($els);
        $(window).on('resize', setMaxHeight.bind(null, $els, true));

        Cog.addListener('TabSitemap', 'tabChanged', setMaxHeight.bind(null, $els, true));
    };

    function unifyHeightTwoInRow($cachedNode, $this) {

        if ($cachedNode.outerHeight() > $this.outerHeight()) {
            $this.outerHeight($cachedNode.outerHeight() + 'px');
            $cachedNode.outerHeight($cachedNode.outerHeight() + 'px');
        } else {
            $cachedNode.outerHeight($this.outerHeight() + 'px');
            $this.outerHeight($this.outerHeight() + 'px');
        }
    }

    //fixme refactor - create smaller functions
    function setMaxHeight($els, isResize) {
        var maxHeight = 0;
        var windowWidth = $(window).outerWidth();
        var $cachedNode = null;

        if (isResize) {
            $els.each(function () {
                $(this).css({
                    'height': 'auto'
                });
            });
        }

        $els.each(function (i) {

            var $this = $(this);

            if (windowWidth <= betaBreakpoint) {
                //make it only on not odd number
                if (i % 2 !== 0) {
                    unifyHeightTwoInRow($cachedNode, $this);
                    $cachedNode = null;
                } else {
                    $cachedNode = $this;
                }
            } else {
                if ($this.outerHeight() > maxHeight) {
                    maxHeight = $this.outerHeight();
                }
            }
        });

        if (windowWidth > betaBreakpoint) {
            $els.css('height', maxHeight);
        }
    }


    Cog.registerComponent({
        name: 'contentWrapper',
        api: api,
        selector: '.content-wrapper'
    });
})(Cog.jQuery());

/**
* Detecting Blackberry
*/

if (navigator.userAgent.match(/BlackBerry|BB|PlayBook/i)) {
    document.body.className +=' bb';
}

/**
* Data Feed for BGA
*/
(function ($) {
    'use strict';

    var api = {
        dataFeedBGA: []
    };

    function DataFeedBGA($el) {
        this.sharePrice($el);
    }

    DataFeedBGA.prototype.sharePrice = function ($el) {
        this.$el = $el;
        var $s_bgaSharePrice = this.$el.find('.bga-sharePrice-hidden');
        var s_bgaSharePrice = $s_bgaSharePrice.text();
        var i_bgaSharePrice = window.parseInt(s_bgaSharePrice, 10);
        var d_bgaSharePrice;

        if (!isNaN(i_bgaSharePrice) && /^\s*[0-9+-]/.test(s_bgaSharePrice)) {
            d_bgaSharePrice = (window.parseFloat(i_bgaSharePrice)/100).toFixed(2);
            $('span.bga-sharePrice').text(d_bgaSharePrice);
        }
    };

    api.onRegister = function (element) {
        var $el = element.$scope;
        api.dataFeedBGA.push(new DataFeedBGA($el));
    };

    Cog.registerComponent({
        name: 'dataFeedBGA',
        api: api,
        selector: '.dataFeeds-absaafrica'
    });
})(Cog.jQuery());

/**
* Popup to only display on mobile.
*/
(function ($) {
    'use strict';

    var api = {
        popups:[],
    };

    var hiddenClass = 'is-hidden';

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    function Popup($el) {
        var $close = $el.find('.popup-close');
        var $appstoreLink = $el.find('.popup-appstore-link');
        var $continue = $el.find('#continue');
        var $appstoreButton = $el.find('.popup-appstore-link--appstore');
        var $googleButton = $el.find('.popup-appstore-link--google');
        var device = this.detectDevice();

        $appstoreLink.on('click touchstart', function (e) {
            e.preventDefault();
            window.open(e.target.href, '_blank');
            $el.addClass(hiddenClass);
        });

        $close.on('click touchstart', function (e) {
            e.preventDefault();
            $el.addClass(hiddenClass);
        });

        $appstoreLink.addClass(hiddenClass);

        if(device === 'Android') {
            $googleButton.removeClass(hiddenClass);
        }

        if(device === 'iOS') {
            $appstoreButton.removeClass(hiddenClass);
        }

        if(checkMobile()) {
            $.each($(document).find('.popup-on-mobile'), function(i, btn){
                var $btn = $(btn);
                $btn.on('click touch', function(event){
                    event.preventDefault();
                    $continue.attr('href',event.target.href);
                    $el.removeClass(hiddenClass);
                });
            });
        }
    }

    Popup.prototype.detectDevice = function() {
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;

        // Windows Phone must come first because its UA also contains 'Android'
        if (/windows phone/i.test(userAgent)) {
            return 'Windows Phone';
        }

        if (/android/i.test(userAgent)) {
            return 'Android';
        }

        // iOS detection from: http://stackoverflow.com/a/9039885/177710
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            return 'iOS';
        }

        return 'unknown';
    };

    api.onRegister = function (element) {
        var $el = element.$scope;
        api.popups.push(new Popup($el));
    };

    Cog.registerComponent({
        name: 'Popup',
        api: api,
        selector: '.popup'
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {};

    api.htmlChatButton = [];

    function HtmlChatButton($el) {
        this.bindEvents($el);
    }

    HtmlChatButton.prototype.bindEvents = function($el) {
        var $bubble = $el.find('.bubbleNotification'),
        $chatButton = $el.find('#liveagent_button_online'),
        $closebutton = $el.find('.notificationClose');
        $bubble.addClass('take-behind');

        $chatButton.on('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
        });

        $closebutton.on('click', function () {
            $bubble.addClass('stay-behind');
        });

        $(window).scroll(function () {
            var scroll = $(window).scrollTop();
            if(scroll > 150 && $chatButton.css('display').toLowerCase() != 'none') {
                $bubble.removeClass('take-behind');
                $bubble.addClass('bring-forward');
            } else {
                $bubble.addClass('take-behind');
                $bubble.removeClass('bring-forward');
            }
        });
    };

    api.onRegister = function (scope) {
        var $htmlChatButton = scope.$scope;
        _.forEach($htmlChatButton, function (chatButton) {
            var $chatButton = $(chatButton);
            api.htmlChatButton.push(new HtmlChatButton($chatButton));
        });
    };

    Cog.registerComponent({
        name: 'htmlChatButton',
        api: api,
        selector: '.reference-generic-saleforce-button'
    });
}(Cog.jQuery()));

//Youtube video component with popup

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {};

    api.youtubeVideo = [];

    function YoutubeVideo($el) {
        this.checkConnection($el);
        this.bindEvents($el);

        if ($(window).width() > 767) {
            $($el).find('.video-banner').css('background-image',
                                            'url(' + $($el).find('.video-banner').attr('data-desktop-image') + ')');
        } else {
            $($el).find('.video-banner').css('background-image',
                                            'url(' + $($el).find('.video-banner').attr('data-mobile-image') + ')');
        }
    }

    YoutubeVideo.prototype.checkConnection = function($el) {
        var image = new Image();

        image.onerror = function () {
            $($el).find('.video-modal').addClass('no-connection');
        };

        image.src = 'http://youtube.com/favicon.ico';
    };

    YoutubeVideo.prototype.bindEvents = function($el) {
        $($el).find('.video-banner-play-button').on('click', function() {
            $($el).addClass('show-video');
        });

        $($el).find('.video-modal').on('click', function(e) {
            if (e.target !== this) {
                return;
            }

            $($el).removeClass('show-video');
            $('.youtube-player').each(function () {
                $(this).attr('src', $(this).attr('src'));
            });
        });

        $('.video-modal-close').on('click', function() {
            $($el).removeClass('show-video');
            $('.youtube-player').each(function () {
                $(this).attr('src', $(this).attr('src'));
            });
        });
    };

    api.onRegister = function (scope) {
        var $youtubeVideos = scope.$scope;
        _.forEach($youtubeVideos, function (youtubeVideo) {
            var $youtubeVideo = $(youtubeVideo);
            api.youtubeVideo.push(new YoutubeVideo($youtubeVideo));
        });
    };

    Cog.registerComponent({
        name: 'youtubeVideo',
        api: api,
        selector: '.banner-youtube-video, .tile-youtube-video'
    });
}(Cog.jQuery()));

/**
 * Image Step by Step Icon
 */

(function ($) {
    'use strict';

    var api = {
            element: []
        },
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch');

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */

    function StepByStepIcon($el) {
        this.$el = $el;

        if (!isAuthor) {
            this.bindUIEvents();
            this.setHeights();
        }
    }

    StepByStepIcon.prototype.bindUIEvents = function () {
        $(window).on('resize', _.debounce(function () {
            this.setHeights();
        }.bind(this), 300));
    };

    StepByStepIcon.prototype.setHeights = function () {
        var $wrapper = this.$el.next('.box-step-by-step-instruction-wrapper');

        if ($wrapper.length) {
            this.$el.height($wrapper.outerHeight());
        }
    };

    api.onRegister = function (scope) {
        api.element.push(new StepByStepIcon(scope.$scope));
    };

    Cog.registerComponent({
        name: 'stepByStepIcon',
        api: api,
        selector: '.image-step-by-step-icon'
    });
})(Cog.jQuery());


/**
 * Changed logo URL
 */

(function ($) {
    'use strict';

    var api = {
            element: []
        },
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch');

    function repleaceUrl($scope) {
        var dataBodyUrl = $('body').data('home-url'),
            $logoUrl = $scope.find('a');

        if (!isAuthor && dataBodyUrl) {
            
            var pathArray = window.location.pathname.split('/'),
                urlLangAttr = pathArray[1],
                docLangAttr = $('html').attr('lang'),
                newURL;

            /* This check is for multilingual sites*/
            if( docLangAttr == urlLangAttr ){
                newURL = window.location.origin + '/' + docLangAttr + dataBodyUrl;
                $logoUrl.attr('href', newURL);
            } else {
                $logoUrl.attr('href', dataBodyUrl);
            }

        }
    }

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        repleaceUrl($el);
    };

    Cog.registerComponent({
        name: 'repleaceUrl',
        api: api,
        selector: '.image-main-logo, .image-redesign-logo'
    });
})(Cog.jQuery());

/*
* Adjust height of hero image
*/
(function ($) {
    'use strict';

    var api = {},
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch'),
        status;

    api.imageHeroReduced = [];

    function ImageHeroAdjust($el) {

        if(!isAuthor) {
            this.$imageHero = $el;
            this.$heroWrapper = this.$imageHero.closest('.hero-wrapper');
            this.$heroText = this.$heroWrapper.
                                        find('.richText-hero-text-layout-parsys');
            this.$heroScrollButton = this.$heroWrapper.
                                        find('.richText-hero-scroll-layout-parsys');
            this.$navTop = this.$heroWrapper.
                                        find('.nav-top-layout-parsys');

            this.isTopNavPresent = this.lookForTopNav();

            this.removeHeroScrollButton();

            if ( $el.hasClass('image-hero-reduced') ) {
                this.adjustImageHeight();
                this.adjustHeroTextHeight();
                this.attachEvents();
            } else if ( $el.hasClass('image-hero-removed') ) {
                this.removeImageHero();
            }

        } else {
            return;
        }
    }

    ImageHeroAdjust.prototype.lookForTopNav = function(){
        this.topNavComponent = this.$navTop.find('.navigation.component');
        return ( (this.topNavComponent.length == 1) ? true : false );
    };

    ImageHeroAdjust.prototype.adjustImageHeight = function(){

        this.$heroWrapper.css('min-height', '0');

        if(status.isPhone()){
            this.$heroText.css('height', 'inherit');
        } else if (status.isMobile()) {
            this.$heroText.css('min-height', '220px');
        } else {
            this.$heroText.css('height', '220px');
            if ( this.isTopNavPresent ){
                this.$heroWrapper.css('margin-top', '118px');
                this.$navTop.css('position', 'relative');
                this.$navTop.css('top', '-49px');
            }
        }
    };

    ImageHeroAdjust.prototype.adjustHeroTextHeight = function(){

        if (this.$heroText.find('p').length > 0) {
            this.$heroText.find('p').wrapAll('<div class=\'hero-paragraph-group\' />');
        }

        this.$heroText.css('display', 'flex');
        this.$heroText.css('align-items', 'center');
        this.adjustImageHeight();
        this.$heroText.find('.richText-hero-reduced.richText-hero').css('visibility', 'visible');

    };

    ImageHeroAdjust.prototype.removeHeroScrollButton = function(){
        this.$heroScrollButton.css('display', 'none');
    };

    ImageHeroAdjust.prototype.attachEvents = function(){
        $(window).on('resize', _.debounce(this.adjustImageHeight.bind(this), 100));
    };

    ImageHeroAdjust.prototype.removeImageHero = function(){

        if ( this.isTopNavPresent ) {
            var topNavComponentHeight = Math.ceil(this.topNavComponent.height()) + 'px';
            this.$heroText.css('height', topNavComponentHeight);
        } else {
            this.$heroText.css('height', 0);
        }
        this.$heroWrapper.css('min-height', 0);
    };

    api.onRegister = function (scope) {
        var $adjustedImages = scope.$scope;
            status = this.external.status;

        _.forEach($adjustedImages, function (adjustedImage){
            var $adjustedImage = $(adjustedImage);
            api.imageHeroReduced.push(new ImageHeroAdjust($adjustedImage));
        });
    };

    Cog.registerComponent({
        name: 'imageHeroReduced',
        api: api,
        selector: '.image-hero-reduced, .image-hero-removed',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})(Cog.jQuery());

/**
 * Image Gallery
 */

(function($) {
	"use strict";

	var api = {},
		refs = {
			componentName: "imageGallery",
			thumbnailsContainerSelector: ".imageGallery-thumbnails",
			imageViewOverlaySelector: ".imageGallery-view-overlay",
			imageViewSelector: ".imageGallery-view",
			thumbnailsListContainerSelector: ".imageGallery-list",
			mainArrowsSelector: ".imageGallery-view .imageGallery-arrow",
			thumbnailsArrowsSelector: ".imageGallery-thumbnails .imageGallery-arrow",
			thumbnailsArrowsLeftClass: "imageGallery-arrow-left",
			thumbnailsArrowsRightClass: "imageGallery-arrow-right",
			descriptionSelector: ".imageGallery-description",
			thumbnailsListInner: ".imageGallery-list-inner",
			thumbnailsList: ".imageGallery-list"
		},
		Direction = {
			PREV: -1,
			NEXT: 1
		},
		settings = {
			loop: true,
			playTimeout: 4000
		};

	api.onRegister = function(scope) {
		/*
		 * Show next image
		 * $context - thumbnailsItems
		 */
		function showNext($context) {
			var currentItem = $context.filter(".is-active"),
				$nextItem = currentItem.next();

			if ($nextItem.length) {
				$nextItem.trigger("click");
			} else if (settings.loop) {
				$context.eq(0).trigger("click");
			}
		}

		/*
		 *	Show previous image
		 * $context - thumbnailsItems
		 */
		function showPrev($context) {
			var currentItem = $context.filter(".is-active"),
				$prevItem = currentItem.prev();

			if ($prevItem.length) {
				$prevItem.trigger("click");
			} else if (settings.loop) {
				$context.last().trigger("click");
			}
		}

		function centerActiveThumbnail($context) {
			var activeItem = $context.filter(".is-active"),
				currentItemPosition = activeItem.position();
			scrollThumbnails($context, currentItemPosition.left * -1);
		}

		function scrollThumbnails($context, to) {
			to += $thumbnailsList.parent().width() / 2 - $context.filter(".is-active").width() / 2;
			to = Math.max(to, -1 * $thumbnailsList.width() + $thumbnailsList.parent().width());
			to = Math.min(0, to);

			$thumbnailsList.animate({left: to});
		}

		var $this = scope.$scope,
			$mainImage = $this.find(refs.imageViewSelector + " img"),
			$mainImageContainer = $this.find(refs.imageViewSelector),
			$thumbnailsContainer = $this.find(refs.thumbnailsContainerSelector),
			$thumbnailsListContainer = $thumbnailsContainer.find(
				refs.thumbnailsListContainerSelector),
			$thumbnailsList = $thumbnailsListContainer.find(refs.thumbnailsListInner),
			$thumbnailsItems = $thumbnailsList.find("li"),
			$arrowsMain = $this.find(refs.mainArrowsSelector),
			$arrowsThumbs = $this.find(refs.thumbnailsArrowsSelector),
			$descriptionContainer = $this.find(refs.descriptionSelector),
			$firstItem = $thumbnailsItems.eq(0),
			playingTimer,
			maxImageHeight = $mainImageContainer.data("height");

		//set width od container based of amount of thumbnails

		function setListWidth() {
			var thumbnailWidth = $firstItem.outerWidth(true),
				listOuterWidth = $thumbnailsItems.length * thumbnailWidth;
			$thumbnailsList.css("width", listOuterWidth);
		}

		$mainImageContainer.on("click", function() {
			clearInterval(playingTimer);
			if ($this.hasClass("is-playing")) {
				$this.removeClass("is-playing");
			} else {
				playingTimer = setInterval(function() {
					var $activeItem = $thumbnailsItems.filter(".is-active"),
						$nextItem = $activeItem.next();
					if ($nextItem.length) {
						$nextItem.trigger("click");
					} else {
						$thumbnailsItems.eq(0).trigger("click");
					}
				}, settings.playTimeout);
				$this.addClass("is-playing");
			}
		});

		$thumbnailsItems.on("click", function(ev) {
			ev.preventDefault();
			ev.stopPropagation();
			var $this = $(this),
				$link = $this.find("a"),
				$linkImg = $link.find("img");

			if (!$this.hasClass("is-active")) {
				$thumbnailsItems.removeClass("is-active");
				$this.addClass("is-active");

				$mainImage.on("load", function() {
					$mainImage.fadeIn(200);
					$descriptionContainer.text($link.data("description"));
				});

				if ($linkImg.attr("src") !== $mainImage.attr("src")) {

					var thumbnailsListLeft = $thumbnailsList.parent().offset().left,
						thumbnailsListRight = thumbnailsListLeft +
							$thumbnailsList.parent().width(),

						thumbnailLeft = $this.offset().left,
						thumbnailRight = thumbnailLeft + $this.outerWidth(false);

					if (thumbnailsListLeft > thumbnailLeft) {
						$thumbnailsList.animate(
							{left: "+=" + (thumbnailsListLeft - thumbnailLeft)});
					} else if (thumbnailsListRight < thumbnailRight) {
						$thumbnailsList.animate(
							{left: "-=" + (thumbnailRight - thumbnailsListRight)});
					}

					$mainImage.fadeTo(200, 0, function() {

						var originalHeight = $linkImg.data("height"),
							correctHeight = !maxImageHeight ||
							originalHeight <= maxImageHeight ?
								originalHeight : maxImageHeight,

							originalWidth = $linkImg.data("width"),
							correctWidth = (correctHeight * originalWidth) / originalHeight;

						$mainImage.attr("width", parseInt(correctWidth, 10));
						$mainImage.attr("height", parseInt(correctHeight, 10));
						$mainImage.attr("src", $link.attr("href"));

						$mainImage.fadeTo(200, 1);

					});
				}
			}
		});

		$arrowsThumbs.on("click", function(e) {
			e.preventDefault();
			e.stopPropagation();
			var vector = $(this).hasClass(refs.thumbnailsArrowsLeftClass) ?
					Direction.PREV : Direction.NEXT,
				currentScroll = parseInt($thumbnailsList.css("left"), 10),
				to = currentScroll - vector * $thumbnailsItems.eq(0).width() * 2;

			to -= $thumbnailsList.parent().width() / 2 -
			$thumbnailsItems.filter(".is-active").width() / 2;
			scrollThumbnails($thumbnailsItems, to);
		});

		//scrolling logic
		$arrowsMain.on("click", function(ev) {
			ev.preventDefault();
			ev.stopPropagation();
			//stop previous animation if exists
			$thumbnailsList.stop(false, true);

			var $this = $(this),
				vector = $this.hasClass(refs.thumbnailsArrowsLeftClass) ? Direction.PREV : Direction.NEXT;

			if (vector === Direction.NEXT) {
				showNext($thumbnailsItems);
			} else {
				showPrev($thumbnailsItems);
			}

			centerActiveThumbnail($thumbnailsItems);
			$arrowsMain.removeClass("is-disabled");

		});

		// Resize first
		var originalHeight = $mainImage.attr("height"),
			correctHeight = !maxImageHeight ||
			originalHeight <= maxImageHeight ? originalHeight : maxImageHeight,

			originalWidth = $mainImage.attr("width"),
			correctWidth = (correctHeight * originalWidth) / originalHeight;

		$mainImage.attr("width", parseInt(correctWidth, 10));
		$mainImage.attr("height", parseInt(correctHeight, 10));

		setListWidth();
	};

	Cog.registerComponent({
		name: "imageGallery",
		api: api,
		selector: ".imageGallery"
	});
})(Cog.jQuery());

(function($) {
    'use strict';
    
    var api = {
        element: []
    };
    
    function LanguageMech($el) {
        this.$el = $el;
        this.switchLanguage($el);
        this.toggleView();
    }
    
    LanguageMech.prototype.toggleView = function() {
        $('.lang').click(function() {
            if ($('.dropdown').hasClass('hidden')) {
                $('.dropdown').removeClass('hidden');
                $('.dropdown').css('visibility','visible');
            } else {
                $('.dropdown').addClass('hidden');
                $('.dropdown').css('visibility','hidden');
            }
        });
    };
    
    LanguageMech.prototype.switchLanguage = function() {
        var language = $(document).find('meta[name=language]').attr('content');

        $('.languageMechanism select option').each(function() {
            if(language == $(this).val()){
                this.selected = 'selected';
            }
        });
        
        $('.languageMechanism select').change(function () {
            location.href = $(this).find(':selected').data('label');
        });
    };
        
    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new LanguageMech($el));
    };

    Cog.registerComponent({
        name: 'languageMechanism',
        api: api,
        selector: '.lang-mechanism-style'
    });
})(Cog.jQuery());
/**
 * LoginBox
 */

(function ($) {
    'use strict';

    var api = {
        loginBoxes: []
    };

    function LoginBox($el) {
        this.$loginBox = $el;

        this.pageName = (function () {
            var $select = this.$loginBox.find('select[name="page-name"]'),
                $label = $select.closest('.LoginBox-label'),
                $jsSelect = $label.find('.page-name');

            return {
                $select: $select,
                $selectOptions: $select.find('option'),
                $jsSelect: $jsSelect,
                $jsSelectOptions: $jsSelect.find('li'),
                $label: $label,
                $selectedLabel: $label.find('.selected-label'),
                isSelectOpen: false,
                selectedIndex: 0
            };
        }.bind(this))();

        this.serviceSelects = (function () {
            var $selectPersonal = this.$loginBox.find('select[name="personal-select"]'),
                $selectBusiness = this.$loginBox.find('select[name="business-select"]'),
                $selectCorporate = this.$loginBox.find('select[name="corporate-select"]'),
                $label = $selectPersonal.closest('.LoginBox-label'),
                $jsSelectPersonal = $label.find('.personal-select'),
                $jsSelectBusiness = $label.find('.business-select'),
                $jsSelectCorporate = $label.find('.corporate-select');


            return {
                $selectPersonal: $selectPersonal,
                $selectBusiness: $selectBusiness,
                $selectCorporate: $selectCorporate,
                $selectPersonalOptions: $selectPersonal.find('option'),
                $selectBusinessOptions: $selectBusiness.find('option'),
                $selectCorporateOptions: $selectCorporate.find('option'),
                $label: $label,
                $jsSelectPersonal: $jsSelectPersonal,
                $jsSelectBusiness: $jsSelectBusiness,
                $jsSelectCorporate: $jsSelectCorporate,
                $jsSelectPersonalOptions: $jsSelectPersonal.find('li'),
                $jsSelectBusinessOptions: $jsSelectBusiness.find('li'),
                $jsSelectCorporateOptions: $jsSelectCorporate.find('li'),
                $selectedLabel: $label.find('.selected-label'),
                selected: '',
                selectedIndex: 0,
                personalHeight: ($selectPersonal[0] ? $selectPersonal[0].scrollHeight : 0),
                businessHeight: ($selectBusiness[0] ? $selectBusiness[0].scrollHeight : 0),
                corporateHeight: ($selectCorporate[0] ? $selectCorporate[0].scrollHeight : 0)
            };
        }.bind(this)());

        this.$actionLogin = this.$loginBox.find('.action-login');
        this.$actionLoginLink = this.$actionLogin.find('a');
        this.$actionRegister = this.$loginBox.find('.action-register');
        this.$actionOnline = this.$loginBox.find('.action-online');
        this.$actionOnlineSeparator = this.$loginBox.find('.loginBox-separator');
        this.$actionRegisterLink = this.$actionRegister.find('a');

        this.setInitSelects();
        this.attachEvents();
    }

    LoginBox.prototype.setInitSelects = function () {
        var paths = window.location.pathname.split('/'),
            linkAnchors = [],
            foundPath = '';

        _.forEach(this.pageName.$selectOptions, function (singleOption) {
            linkAnchors.push($(singleOption).val());
        });

        _.forEach(paths, function (path) {
            var foundIndex = _.indexOf(linkAnchors, path);

            if (foundIndex >= 0) {
                foundPath = path;
                return false;
            }
        });

        if (foundPath.length > 0) {
            this.setSelectedPageName(foundPath);
        } else {
            this.setSelectedPageName('personal');
        }
    };

    LoginBox.prototype.openPageNameSelect = function () {
        var isActive = this.pageName.$jsSelect.hasClass('is-active');

        if (isActive) {
            this.pageName.isSelectOpen = false;
            this.closeSelect(this.pageName.$jsSelect);
        } else {
            this.pageName.isSelectOpen = true;
            this.pageName.$jsSelect.addClass('is-active');
        }
    };

    LoginBox.prototype.openServiceSelectsSelect = function () {
        var isActive = this.serviceSelects.$jsSelectChosen.hasClass('is-active');

        if (isActive) {
            this.serviceSelects.isSelectOpen = false;
            this.closeSelect(this.serviceSelects.$jsSelectChosen);
        } else {
            this.serviceSelects.isSelectOpen = true;
            this.serviceSelects.$jsSelectChosen.addClass('is-active');
        }
    };

    LoginBox.prototype.closeSelect = function ($jsSelect) {
        $jsSelect.removeClass('is-active');
        $jsSelect.removeClass('is-active');
    };

    LoginBox.prototype.setSelectedPageName = function (selectedValue) {
        var $jsSelectedOption = this.pageName.$jsSelectOptions.filter('[data-value="' + selectedValue + '"]');

        this.pageName.$select.val(selectedValue);
        this.pageName.$jsSelectOptions.removeClass('is-active');
        $jsSelectedOption.addClass('is-active');

        this.setSelectedLabel(this.pageName.$selectedLabel, $jsSelectedOption.text());

        this.serviceSelects.selected = selectedValue;
        this.setSelectedServiceChosen();
        this.setSelectedService();
    };

    LoginBox.prototype.setSelectedServiceChosen = function () {
        if (this.serviceSelects.$selectChosen) {
            this.serviceSelects.$selectChosen.removeClass('is-active');
        }

        if (this.serviceSelects.selected === 'personal') {
            this.serviceSelects.$jsSelectChosen = this.serviceSelects.$jsSelectPersonal;
            this.serviceSelects.$jsSelectOptionsChosen = this.serviceSelects.$jsSelectPersonalOptions;
            this.serviceSelects.$selectChosen = this.serviceSelects.$selectPersonal;
            this.serviceSelects.$selectOptionsChosen = this.serviceSelects.$selectPersonalOptions;
            this.pageName.selectedIndex = 0;
        } else if (this.serviceSelects.selected === 'business') {
            this.serviceSelects.$jsSelectChosen = this.serviceSelects.$jsSelectBusiness;
            this.serviceSelects.$jsSelectOptionsChosen = this.serviceSelects.$jsSelectBusinessOptions;
            this.serviceSelects.$selectChosen = this.serviceSelects.$selectBusiness;
            this.serviceSelects.$selectOptionsChosen = this.serviceSelects.$selectBusinessOptions;
            this.pageName.selectedIndex = 1;
        } else if (this.serviceSelects.selected === 'corporate') {
            this.serviceSelects.$jsSelectChosen = this.serviceSelects.$jsSelectCorporate;
            this.serviceSelects.$jsSelectOptionsChosen = this.serviceSelects.$jsSelectCorporateOptions;
            this.serviceSelects.$selectChosen = this.serviceSelects.$selectCorporate;
            this.serviceSelects.$selectOptionsChosen = this.serviceSelects.$selectCorporateOptions;
            this.pageName.selectedIndex = 2;
        }

        this.serviceSelects.$selectChosen.addClass('is-active');

    };

    LoginBox.prototype.setSelectedService = function () {

        var $selectedOption = this.serviceSelects.$selectOptionsChosen.filter(':selected'),
            selectedIndex = $selectedOption.index(),
            $jsSelectedOption = this.serviceSelects.$jsSelectOptionsChosen.eq(selectedIndex);

        this.serviceSelects.selectedIndex = selectedIndex;
        this.serviceSelects.$jsSelectOptionsChosen.removeClass('is-active');
        $jsSelectedOption.addClass('is-active');

        this.setSelectedLabel(this.serviceSelects.$selectedLabel, $jsSelectedOption.text());
        this.setLinks($jsSelectedOption.data('login'), $jsSelectedOption.data('register'));
    };
    LoginBox.prototype.setLinks = function (loginHref, registerHref) {
        if (loginHref && loginHref.length) {
            this.$actionLoginLink.attr('href', loginHref);
        }

        if (registerHref && registerHref.length) {
            this.$actionRegisterLink.attr('href', registerHref);
            this.$actionRegister.addClass('is-active');
            this.$actionOnline.addClass('is-active');
            this.$actionOnlineSeparator.addClass('is-active');
        } else {
            this.$actionRegisterLink.attr('href', '');
            this.$actionRegister.removeClass('is-active');
            this.$actionOnline.removeClass('is-active');
            this.$actionOnlineSeparator.removeClass('is-active');
        }
    };

    LoginBox.prototype.setSelectedLabel = function ($label, newValue) {
        $label.text(newValue);
    };

    LoginBox.prototype.onPageNameSelectChange = function () {
        var $selected = this.pageName.$selectOptions.filter(':selected'),
            selectedIndex = $selected.index(),
            selectedVal = $selected.val();

        if (selectedIndex !== this.pageName.selectedIndex) {
            this.pageName.selectedIndex = selectedIndex;
            this.setSelectedPageName(selectedVal);
        }
    };

    LoginBox.prototype.onServiceSelectsChange = function () {
        var $selected = this.serviceSelects.$selectOptionsChosen.filter(':selected'),
            selectedIndex = $selected.index();

        if (selectedIndex !== this.serviceSelects.selectedIndex) {
            this.serviceSelects.selectedIndex = selectedIndex;
            this.setSelectedService();
        }
    };

    LoginBox.prototype.onHtmlClick = function (e) {
        if (this.pageName.isSelectOpen && e.target !== this.pageName.$selectedLabel[0]) {
            this.pageName.isSelectOpen = false;
            this.closeSelect(this.pageName.$jsSelect);
        }
        if (this.serviceSelects.isSelectOpen && e.target !== this.serviceSelects.$selectedLabel[0]) {
            this.serviceSelects.isSelectOpen = false;
            this.closeSelect(this.serviceSelects.$jsSelectChosen);
        }
    };

    LoginBox.prototype.onResize = function () {
        this.closeSelect(this.pageName.$jsSelect);
        this.closeSelect(this.serviceSelects.$jsSelectChosen);
    };

    LoginBox.prototype.attachEvents = function () {
        this.pageName.$selectedLabel.on('click', function () {
            this.openPageNameSelect();
        }.bind(this));

        this.pageName.$jsSelectOptions.on('click', function (e) {
            var $current = $(e.currentTarget),
                index = $current.index();

            this.pageName.$selectOptions.eq(index).prop('selected', true);
            this.pageName.$select.change();
        }.bind(this));

        this.pageName.$select.on('change', this.onPageNameSelectChange.bind(this));

        this.serviceSelects.$selectedLabel.on('click', function () {
            this.openServiceSelectsSelect();
        }.bind(this));

        this.serviceSelects.$label.on('click', 'li', function (e) {
            var $current = $(e.currentTarget),
                index = $current.index();

            this.serviceSelects.$selectOptionsChosen.eq(index).prop('selected', true);
            this.serviceSelects.$selectChosen.change();
        }.bind(this));

        this.serviceSelects.$label.on('change', 'select', this.onServiceSelectsChange.bind(this));

        $('html').on('click', this.onHtmlClick.bind(this));

        $(window).on('resize', _.debounce(this.onResize.bind(this), 100));
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        api.loginBoxes.push(new LoginBox($el));
    };

    Cog.registerComponent({
        name: 'LoginBox',
        api: api,
        selector: '.loginBox'
    });
})(Cog.jQuery());

/**
 * Map
 * https://developers.google.com/maps/documentation/javascript/reference
 */

/* global google */

(function($) {
	"use strict";

	var api = {},
		defaultOptions = {
			height: 250,
			zoom: 14,
			latitude: 51.500134,
			longitude: -0.12623,
			mapType: "ROADMAP",
			markers: []
		};

	function showMarkers(scope) {
		if (!scope.mapOptions.markers.length) {
			return;
		}

		var marker, k, infoWindow, tmarker;

		// Create all giver markers for this map
		for (k in scope.mapOptions.markers) {
			// Create marker only if title is provided
			if (scope.mapOptions.markers.hasOwnProperty(k) &&
				scope.mapOptions.markers[k].title.length) {
				marker = scope.mapOptions.markers[k];
				// Marker object
				tmarker = new google.maps.Marker({
					position: new google.maps.LatLng(marker.latitude, marker.longitude),
					map: scope.gmap,
					title: marker.title
				});

				// Add description window if provided
				if (marker.description.length) {
					infoWindow = new google.maps.InfoWindow({
						content: marker.description
					});

					// Popup window info after clicking marker
					google.maps.event.addListener(
						tmarker,
						"click",
						openInfoWindow(tmarker, infoWindow, scope.gmap)
					);
				}

			}
		}
	}

	function openInfoWindow(tmarker, infoWindow, gMap) {
		return (function(tmarker, infoWindow) {
			return function() {
				infoWindow.open(gMap, tmarker);
			};
		})(tmarker, infoWindow);
	}

	api.onRegister = function(scope) {
		var browser = this.external.browser;
		//serve static map in ie7
		if (browser.msie && browser.version < 8) {
			return false;
		}

		var map = scope.$scope.find(".map-canvas"),
			options = $.extend(defaultOptions, map.data()),
			centerPosition;

		// Set individual height of each map
		map.height(options.height);

		// Set markerPosition object
		centerPosition = new google.maps.LatLng(options.latitude, options.longitude);

		// Set mapOption object to setup map
		scope.mapOptions = {
			zoom: options.zoom,
			center: centerPosition,
			markers: options.markers,
			mapTypeId: google.maps.MapTypeId[options.mapType]
		};

		// Create map
		scope.gmap = new google.maps.Map(map[0], scope.mapOptions);

		showMarkers(scope);

		// Check if map is placed inside tab
		var tabContent = map.parents(".tabs-content");
		if (tabContent.size()) {
			Cog.addListener("tab", "change", function(e) {
				if (tabContent.attr("id") === e.eventData.id) {
					google.maps.event.trigger(scope.gmap, "resize");
				}
			});
		}
	};

	Cog.registerComponent({
		name: "map",
		api: api,
		selector: ".map",
		requires: [
			{
				name: "utils.browser",
				apiId: "browser"
			}
		]
	});
})(Cog.jQuery());

/**
 * Navigation
 */

(function($) {
	"use strict";

	/**
	 * Nav class
	 * @param $nav navigation wrapper
	 * @constructor
	 */
	function Nav($nav) {
		this.$nav = $nav;
		this.bindUIEvents();
	}

	Nav.prototype.bindUIEvents = function() {
		var self = this;

		self.$nav.on("tap click", ".navigation-mobile-menu", function(e) {
			e.preventDefault();
			$(this).next(".navigation-root").toggleClass("is-open");
		});

		if (!self.$nav.is(".navigation-horizontal") ||
			$("html").hasClass("mod-touch")) {
			self.$nav
				.on("tap click", ".has-children > .navigation-item-title >" +
				" .navigation-item-decoration", function(event) {
					event.preventDefault();
					event.stopPropagation();

					var $this = $(this).closest(".has-children"),
						$siblings = $this.siblings(".has-children");

					$siblings.not($this).removeClass("is-open")
						.find(".has-children").removeClass("is-open");
					$this.toggleClass("is-open");
				})
				// Enable opening with enter on SPAN
				.on("keydown", ".has-children > .navigation-item-title >" +
				" .navigation-item-decoration", function(event) {
					if (event.which === 13) {
						event.stopPropagation();
						event.preventDefault();
						$(this).trigger("click");
					}
				});

			self.$nav
				.on("click", ".has-children > .navigation-item-title >" +
				".navigation-item-decoration", function(event) {
					event.preventDefault();
					event.stopPropagation();
				});
		} else {
			self.$nav
				.on("mouseenter focusin", ".has-children", function() {
					var $this = $(this);
					$this.addClass("is-open");
				})
				.on("mouseleave", ".has-children", function() {
					$(this).removeClass("is-open");
				})
				.on("focusout", ".has-children", function() {
					var $this = $(this);
					setTimeout(function() {
						if (!$this.is(":focus") && !$this.find(":focus").size()) {
							$this.removeClass("is-open");
						}
					}, 0);
				});
		}
	};

	/**
	 * Public API
	 */
	var api = {};

	api.navs = [];

	api.onRegister = function(scope) {
		var $nav = scope.$scope;
		api.navs.push(new Nav($nav));
	};

	Cog.registerComponent({
		name: "navigation",
		api: api,
		selector: ".navigation"
	});

	return api;
}(Cog.jQuery()));
(function ($) {
    'use strict';

    /**
     * Public API
     */

    var api = {},
        status,
        $productCardInfoEl,
        $buttons,
        $buttonsCopy,
        $heroWrapper;

    api.productCardInfo = [];

    function ProductCardInfo($el) {
        this.$window = $(window);
        this.$body = $('body');
        this.$headerSection = $('#header');
        this.$headerSnippet = $('.header-snippet');

        $heroWrapper = $('#header .hero-wrapper');

        $productCardInfoEl = $el;

        $buttons = $productCardInfoEl.find('.product-card-info-buttons a');
                                                
        this.handleContentSpacing();
        this.handleButtons($buttons);

        if (!status.isAuthor() && $el.length) {
            handleAccordingToDevice();
            this.attachEvents();
        } else {
            return;
        }

    }

    ProductCardInfo.prototype.handleContentSpacing = function () {
        if( this.$body.find('.multiStackedSubnavigation.component').length == 0){
            this.$body.find('#content').css('padding-top', '0'); // Clear multistack spacing
        }
    };

    ProductCardInfo.prototype.handleButtons = function ($buttons) {
        colorButtons($buttons);
        $buttonsCopy = $productCardInfoEl.find('.product-card-info-buttons')
                            .clone().addClass('mobile-buttons-copy');
        setButtonsToWidest( getWidestButtonWidth($buttons) );
    };

    ProductCardInfo.prototype.attachEvents = function() {
        
        let mobileCriticalPoint = $heroWrapper.height() + $productCardInfoEl.height(),
            stickyScrollPoint = this.$headerSection.outerHeight() - this.$headerSnippet.outerHeight();

        this.$window.on('scroll', function() {

            if( $(window).width() < 481 ) {

                if(this.window.scrollY > mobileCriticalPoint) { 
                    $buttonsCopy.addClass('show-button-copy');
                    $buttonsCopy.css('opacity', 1);
                } else {
                    $buttonsCopy.css('opacity', 0);
                    $buttonsCopy.removeClass('show-button-copy');
                }

            } else { 
                if(this.window.scrollY > stickyScrollPoint) {
                    if( $('.cookiePolicy.collapsed').length > 0 ){
                        $productCardInfoEl.removeClass('with-cookie');
                        $productCardInfoEl.addClass('no-cookie');
                    } else {
                        $productCardInfoEl.removeClass('no-cookie');
                        $productCardInfoEl.addClass('with-cookie');
                    }
                    $productCardInfoEl.addClass('product-card-info-sticky');
                } else {
                    $productCardInfoEl.removeClass('product-card-info-sticky');
                }
            }

        });

        this.$window.on('orientationchange resize', function() {
            handleAccordingToDevice();
        });

    };

    function handleAccordingToDevice() {     
                
        if( $(window).width() < 481 ) {
            $heroWrapper.addClass('hide-hero-image');
            $('.footer-snippet').addClass('footer-spacing');
            
            $('.footer-snippet').after($buttonsCopy);

            $productCardInfoEl.removeClass('product-card-info-sticky');
            $heroWrapper.addClass('hide-hero-image');

            // recalculate width
            $buttons.css('width', '');
            setButtonsToWidest( getWidestButtonWidth($buttons) );
        } else {
            $buttonsCopy.removeClass('show-button-copy');

            // recalculate width
            $buttons.css('width', '');
            setButtonsToWidest( getWidestButtonWidth($buttons) );
        }
    }

    function getWidestButtonWidth(buttons){
        let btnMaxWidth,
            btnWidths = [];

        _.forEach(buttons, function (button) {
            let $button = $(button);
            btnWidths.push($button.width());
        });

        btnWidths.sort(function(a, b){ return b-a; }); // Sort to place widest item first 

        btnMaxWidth = btnWidths[0];

        return btnMaxWidth;
        
    }

    function colorButtons($buttons){
        $buttons.last().addClass('btn-action-green btn-action-primary-solid');
    }

    function setButtonsToWidest(btnMaxWidth){

        _.forEach($buttons, function (button) {
            let $button = $(button);
            $button.width(btnMaxWidth);
        });
        
    }

    api.onRegister = function (scope) {
        let $productCardInfoList = scope.$scope;
        status = this.external.status;

        _.forEach($productCardInfoList, function (productCardInfo) {
            let $productCardInfo = $(productCardInfo);
            api.productCardInfo.push(new ProductCardInfo($productCardInfo));
        });
    };

    Cog.registerComponent({
        name: 'productCardInfo',
        api: api,
        selector: '.productCardInfo.component',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));

/**
 * Rich Text
 */

(function ($) {
    'use strict';

    /**
     * Public API
     */
    var api = {};

    api.messages = [];

    api.backToTop = [];

    /**
     * Nav class
     * @param $message message component
     * @constructor
     */
    function Message($message) {
        this.$message = $message;
        this.createContainer();
        this.append();
        this.moveButton();
        this.bindUIEvents();
    }

    Message.prototype.createContainer = function () {
        this.$container = $('.js-message-container');
        if (this.$container.length === 0) {
            this.$container = $('<div class="js-message-container" />');
            this.$container.appendTo($('body'));
        }
    };

    Message.prototype.moveButton = function () {
        var $content = this.$message.find('.richText-content'),
            $button = this.$message.find('.richText-content a').last();

        if ($button.length) {
            $content.wrapInner('<div class="js-message-content">');
            $button.appendTo($content).addClass('cta');
            this.$message.addClass('has-button');
        }
    };

    Message.prototype.append = function () {
        this.$message.appendTo(this.$container);
    };

    Message.prototype.show = function () {
        this.$message.removeClass('is-hidden');
    };

    Message.prototype.hide = function () {
        this.$message.addClass('is-hidden');
        _.delay(function () {
            this.$message.remove();
        }.bind(this), 500);
    };

    Message.prototype.bindUIEvents = function () {
        if (this.$message.hasClass('success')) {
            _.delay(this.hide.bind(this), 10000);
        }
        else {
            this.$close = $('<a href="#close" class="close"></a>');
            this.$close.appendTo(this.$message.find('.richText-content'));
            this.$close.on('click', function (e) {
                e.preventDefault();
                this.hide();
            }.bind(this));
        }
    };


    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */

    api.onRegister = function (scope) {
        var $richTexts = scope.$scope;

        _.forEach($richTexts, function (richText) {
            var $richText = $(richText);
            api.messages.push(new Message($richText));
        });
    };

    Cog.registerComponent({
        name: 'richText',
        api: api,
        selector: '.richText-message'
    });

}(Cog.jQuery()));

/**
 * Rich Text
 */

(function ($) {
    'use strict';

    /**
     * Public API
     */
    var api = {},
        $window = $(window),
        isMobile = checkMobile();

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 480px)');
    }

    api.messages = [];

    api.backToTop = [];

    function BackToTop($el) {
        this.$el = $el;
        this.$anchor = this.$el.find('a');
        this.$footer = $('#footer');
        this.toggle();
        this.setPosition();
        this.bindUIEvents();
    }


    BackToTop.prototype.toggle = function () {
        if (isMobile && this.isBelowFold() || !isMobile && this.isAtTheBottom()) {
            this.show();
        }
        else {
            this.hide();
        }
    };

    BackToTop.prototype.isHeaderVisible = function () {
        return $('.snippetReference-sticky-header.js-negative-variant').length > 0;
    };

    BackToTop.prototype.setPosition = function () {
        var footerOffset = this.$footer.offset().top,
            windowScroll = $window.scrollTop(),
            top = footerOffset - windowScroll - this.$anchor.outerHeight() - 30;

        if (isMobile) {
            top = 'auto';
        } else if (this.isHeaderVisible() && top < 120) {
            top = 140;
        } else if (top < 10) {
            top = 20;
        }

        this.$anchor.css('top', top);
    };

    BackToTop.prototype.isBelowFold = function () {
        return $window.scrollTop() > 100;
    };

    BackToTop.prototype.isAtTheBottom = function () {
        return $window.scrollTop() + $window.height() >= $(document).height() - this.$footer.outerHeight();
    };

    BackToTop.prototype.hide = function () {
        this.$el.removeClass('visible');
    };

    BackToTop.prototype.show = function () {
        this.$el.addClass('visible');
    };

    BackToTop.prototype.bindUIEvents = function () {

        if (this.isBelowFold() && isMobile) {
            this.show();
        }

        $window.on('scroll resize', _.debounce(this.toggle.bind(this), 150));
        $window.on('scroll resize', this.setPosition.bind(this));
        $window.on('resize', function () {
            isMobile = checkMobile();
        }.bind(this));

        this.$anchor.on('click', function () {
            $('body, html').animate({
                scrollTop: 0
            }, 150);
            return false;
        });
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */

    api.onRegister = function (scope) {
        var $richTexts = scope.$scope;

        _.forEach($richTexts, function (richText) {
            var $richText = $(richText);
            api.backToTop.push(new BackToTop($richText));
        });
    };

    Cog.registerComponent({
        name: 'richText',
        api: api,
        selector: '.richText-back-to-top'
    });

}(Cog.jQuery()));

/**
 * RichText Extended
 *
 */

(function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.richTextExtended = [];

    function RichtextExtended($el) {
        this.$el = $el;
        $el.addClass('richText');
    }

    api.onRegister = function (scope) {
        var $richTexts = scope.$scope;

        _.forEach($richTexts, function (richText) {
            var $richText = $(richText);
            api.richTextExtended.push(new RichtextExtended($richText));
        });
    };

    Cog.registerComponent({
        name: 'richTextExtended',
        api: api,
        selector: '.richtextExtended'
    });
}(Cog.jQuery()));

/**
 * ScrollToDiscover
 *
 */
(function ($) {
    'use strict';

    /**
     * Public API
     */
    var api = {
        element: []
    },
        $window = $(window);

    /**
     * Element class
     * @param $el scroller wrapper
     * @constructor
     */
    function DiscoveryScroller ($el) {
        this.$scroller = $el;
        this.$bodyHtml = $('body,html');
        this.$header = $('.snippetReference-sticky-header');
        $window.on('load',this.onLoad());
        this.attachEvents();
    }

    DiscoveryScroller.prototype.onLoad = function() {
        this.$scroller.delay(3000).fadeTo(1000,1);
    };

    DiscoveryScroller.prototype.onClick = function() {
        var div = document.querySelector('div#content'),
            divOffset = this.setOffset(div);

        this.measureHeader();

        this.$bodyHtml.animate({
            scrollTop: divOffset.top - this.$headerMinus
        }, 1000);
    };

    DiscoveryScroller.prototype.onResize = function() {
        this.measureHeader();
    };

    DiscoveryScroller.prototype.measureHeader = function() {
        this.$headerHeight = this.$header.innerHeight();
        this.$headerMinus = 0;

        if (this.$headerHeight <= 77) {
            this.$headerMinus = 77;
        }
    };

    DiscoveryScroller.prototype.setOffset = function() {
        var rect = document.getElementById('content').getBoundingClientRect(),
            scrollTop = $window.pageYOffset || document.documentElement.scrollTop;
        return { top: rect.top + scrollTop };
    };

    DiscoveryScroller.prototype.attachEvents = function () {
        $window.on('resize', _.debounce(this.onResize.bind(this), 100));
        this.$scroller.on('click', this.onClick.bind(this));
    };

    api.onRegister = function (scope) {
        api.element.push(new DiscoveryScroller(scope.$scope));
    };

    Cog.registerComponent({
        name: 'discoveryScroller',
        api: api,
        selector: '.richText-scroll-to-discover'
    });
}(Cog.jQuery()));

/**
 * Make div clickable
 *
 */

(function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.richTextBranchSplashAppStore = [];

    function RichTextBranchSplashAppStore($el) {
        this.$el = $el;
        this.makeWholeComponentClickable(this.$el);
    }

    RichTextBranchSplashAppStore.prototype.makeWholeComponentClickable = function($el){
        var $clickableEl = $el.find('.component-content');
        $clickableEl.click(function() {
            window.location = $(this).find('a').attr('href');
            return false;
        });
    };

    api.onRegister = function (scope) {
        var $richTexts = scope.$scope;

        _.forEach($richTexts, function (richText) {
            var $richText = $(richText);
            api.richTextBranchSplashAppStore.push(new RichTextBranchSplashAppStore($richText));
        });
    };

    Cog.registerComponent({
        name: 'richTextBranchSplashAppStore',
        api: api,
        selector: '.richText-branch-splash-app-store'
    });
}(Cog.jQuery()));

/*
change image to svg
*/
(function ($) {
    'use strict';

    var api = {};
    api.element = [];

    function ImageToSvg($svgImage) {
        this.convertSvg($svgImage);
    }

    ImageToSvg.prototype.convertSvg = function ($svgImage) {
         var $img = $svgImage.find('img');

         if($img) {
            var imgURL = $img.attr('src');

            if (imgURL && imgURL.length > 0) {
                this.replaceIcon($img, imgURL);
            }
        }
    };

    ImageToSvg.prototype.replaceIcon = function ($originalImg, src) {
        this.getNewIcon(src, function (data) {
            var $svg = $(this.getCleanSvg(data));

            if ($svg.length) {
                $originalImg.replaceWith($svg);
            }

        }.bind(this));
    };

    ImageToSvg.prototype.getNewIcon = function (src, callback) {
        $.ajax({
            method: 'GET',
            url: src,
            success: function (data) {
                callback(data);
            }.bind(this)
        });
    };

    ImageToSvg.prototype.getCleanSvg = function (data) {
        var $document = $(data),
            $svg = $document.find('svg');

        if (!$svg.length) {
            return 0;
        }

        $svg = $svg.removeAttr('xmlns:a');

        if (!$svg.attr('viewBox') && $svg.attr('height') && $svg.attr('width')) {
            $svg.attr('viewBox', '0 0 ' + $svg.attr('height') + ' ' + $svg.attr('width'));
        }

        return $svg.outerHTML();
    };

    $.fn.outerHTML = function (s) {
        return (s) ? this.before(s).remove() : $('<p>').append(this.eq(0).clone()).html();
    };

    api.onRegister = function (scope) {
        var $svgToImages = scope.$scope;

        _.forEach($svgToImages, function (svgToImage) {
            var $svgImage = $(svgToImage);
            api.element.push(new ImageToSvg($svgImage));
        });
     };

    Cog.registerComponent({
        name: 'ImageToSvg',
        api: api,
        selector: '.image-to-svg'
    });
})(Cog.jQuery());

/**
 * Informatory Message RTE
 *
 */

(function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.richTextInformatoryMessage = [];

    function RichTextInformatoryMessage($el) {
        this.$el = $el;
        this.createHeaderSection($el);
        this.bindEvents($el);
    }

    RichTextInformatoryMessage.prototype.createHeaderSection = function($el) {
        $el.find('.component-content').addClass('richText-informatory-message-content-wrapper');
        $el.prepend('<div class=\'richText-informatory-message-heading-section\'>');

        var headerSection = $el.find('.richText-informatory-message-heading-section');
        var picture;

        if($el.find('picture').length > 0) {
            picture = $el.find('picture');
            $el.remove('picture');
        } else {
            picture = $el.find('img');
            $el.remove('img');
        }

        $(headerSection).append(picture);
        $(headerSection).append('<div class=\'cross-wrapper\'>');

        var crossWrapper = $(headerSection.find('.cross-wrapper'));
        $(crossWrapper).append('<span class=\'cross-item\'> | </div>');
        $(crossWrapper).append('<span class=\'cross-item\'> | </div>');
    };

    RichTextInformatoryMessage.prototype.closeMessageWithAnimation = function($el) {
        $el.animate({right: '-260px', opacity: '0'}, '.25s', function() {
            $el.remove();
        });
    };

    RichTextInformatoryMessage.prototype.bindEvents = function($el) {
        var _this = this;
        $el.find('.cross-wrapper').on('click', function() {
            _this.closeMessageWithAnimation($el);
        });
    };

    api.onRegister = function (scope) {
        var $richTexts = scope.$scope;

        _.forEach($richTexts, function (richText) {
            var $richText = $(richText);
            api.richTextInformatoryMessage.push(new RichTextInformatoryMessage($richText));
        });
    };

    Cog.registerComponent({
        name: 'richTextInformatoryMessage',
        api: api,
        selector: '.richText-informatory-message'
    });
})(Cog.jQuery());

/*
* Make whole Element clickable and link off to specified anchor
* This JS is being used for RichText and Box components.
*/
(function ($) {
    'use strict';

    var api = {};

    api.ClickableComponent = [];

    function ClickableComponent($el) {
        this.$el = $el;
        this.attachEvents();
    }

    ClickableComponent.prototype.attachEvents = function(){
        var $link = this.$el.find('> .component-content .richText-content a'),
            $priorityLink = this.$el.find('.priority-link'),
            $clickableEl = $link;

            if ($priorityLink.length == 1) {
                $clickableEl = $priorityLink;
            }

        this.$el.on('click', function() {
            if ($clickableEl.attr('target') == '_blank') {
                window.open($clickableEl.attr('href'), '_blank');
            } else {
                window.open($clickableEl.attr('href'), '_self');
            }
        });

    };

    api.onRegister = function (scope) {
        var $elements = scope.$scope;

        _.forEach($elements, function (element){
            var $element = $(element);
            api.ClickableComponent.push(new ClickableComponent($element));
        });
    };

    Cog.registerComponent({
        name: 'ClickableComponent',
        api: api,
        selector: '.clickable-component'
    });
})(Cog.jQuery());

/**
 * Search Box
 */

/*global Modernizr*/

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    function SearchBox($el) {
        this.$el = $el;
        this.$btn = this.$el.find('button');
        this.$btnFake = this.$el.find('.richText a');
        this.btnClass = this.$btnFake.length ? this.$btnFake[0].className : '';
        this.$searchBoxTrigger = $('.box-search-bar-trigger');
        this.$searchTrigger = $('.richText-search-button');
        this.$formContent = this.$el.find('.searchBox .form-search > div');
        this.suggestionUrl = this.$el.find('.component-content[data-suggestion-uri]').attr('data-suggestion-uri');

        if (this.suggestionUrl) {
            this.initSuggestions();
        }

        this.options = {
            keepSearchBoxOpen: false,
            isSearchResultsPage: false
        };
        this.$body = $('body');
        this.$html = $('html');

        this.handleOptions();
        this.openIfFormIsActive();
        this.handleSearchBoxClose();
        this.bindUIEvents();
        this.$searchBoxTrigger.attr('tabindex', 0);
        this.$formInput.focus();

        if (!Modernizr.input.placeholder) {
            this.addPlaceholder();
        }
    }

    SearchBox.prototype.handleOptions = function () {
        if (this.$body.hasClass('page-global-search-results') || this.$body.hasClass('template-global-search')) {
            this.options.keepSearchBoxOpen = true;
            this.options.isSearchResultsPage = true;
        }
    };

    SearchBox.prototype.openIfFormIsActive = function () {
        if (this.$formContent.is('.is-active')) {
            this.options.keepSearchBoxOpen = true;
            this.open();
        } else {
            this.close();
        }
    };

    SearchBox.prototype.handleSearchBoxClose = function () {
        if (!this.options.keepSearchBoxOpen) {
            this.$el.find('> .component-content').append('<a href="#close" class="close">X</a>');
        }

        this.$body.append('<div class="overlayBg"></div>');
        this.$btn.removeClass('button').addClass(this.btnClass);
    };

    SearchBox.prototype.bindUIEvents = function () {
        this.$overlayBg = $('.overlayBg');
        if (!this.options.keepSearchBoxOpen) {
            Cog.addListener('boxMenu', 'open', function () {
                this.close();
            }.bind(this));

            Cog.addListener('login', 'open', function () {
                this.close();
            }.bind(this));

            this.$searchBoxTrigger.on('click', function (e) {
                this.onTriggerClick(e);
                this.$formInput.val(this.$formInput.val());
                this.$formInput.focus();
            }.bind(this));

            this.$searchTrigger.on('click', function (e) {
                this.onTriggerClick(e);
                this.$formInput.val(this.$formInput.val());
                this.$formInput.focus();
            }.bind(this));

            this.$searchBoxTrigger.on('keyup', function (e) {
                if (this.isEnterKey(e)) {
                    this.onTriggerClick(e);
                }
            }.bind(this));

            this.$overlayBg.on('click', function(e) {
                this.onTriggerBody(e);
            }.bind(this));

        } else {
            this.$searchBoxTrigger.on('click', function () {
                Cog.fireEvent('search', 'open');
                this.$formInput.val(this.$formInput.val());
                this.$formInput.focus();
            }.bind(this));
        }

        this.$el.find('.close').on('click', function (e) {
            e.preventDefault();
            this.close();
        }.bind(this));

        this.isFocus();
    };

    SearchBox.prototype.isEnterKey = function (e) {
        return e.which === 13 ? true : false;
    };

    SearchBox.prototype.isFocus = function () {
        this.$btn.attr('disabled', true);
        this.$formInput = this.$el.find('.searchBox .form-search input[type="text"]');

        if (this.$formInput.val() !== '') {
            this.$btn.removeAttr('disabled');
        }

        this.$formInput.on('keyup', function () {
            if (this.$formInput.val() === '') {
                this.$btn.attr('disabled',true);
            } else {
                this.$btn.removeAttr('disabled');
            }
        }.bind(this));
    };

    SearchBox.prototype.onMaxHeightEnd = function ($el, callback) {
        if (Modernizr.csstransitions) {
            $el.off('transitionend').on('transitionend', _.debounce(function () {
                callback();
            }, 1));
        } else {
            callback();
        }
    };

    SearchBox.prototype.close = function () {
        this.isOpen = false;
        this.$el.css('max-height', 0).addClass('js-animation');

        if (this.$el.hasClass('is-active')) {
            this.$el.removeClass('is-active');
            this.$el.css('display', 'none');
        } else {
            this.$el.css('display', 'none');
        }

        this.onMaxHeightEnd(this.$el, function () {
            this.$el.css('display', 'none');
            Cog.fireEvent('searchbox', 'close');
        }.bind(this));
        this.$body.removeClass('is-searchBox-active');
        this.$html.removeClass('no-scroll');
        Cog.fireEvent('header', 'overlayClose');
    };

    SearchBox.prototype.open = function () {
        this.$el.css('display', 'block');
        this.$el.css('max-height', '');
        _.defer(function () {
            this.isOpen = true;
            this.$el.addClass('is-active');

            this.onMaxHeightEnd(this.$el, function () {
                this.$el.css('display', 'block');
                Cog.fireEvent('header', 'overlayOpen');
            }.bind(this));

            this.$body.addClass('is-searchBox-active');

            if(!this.options.isSearchResultsPage){
                this.$html.addClass('no-scroll');
            }
        }.bind(this));
        Cog.fireEvent('search', 'open');
        Cog.fireEvent('header', 'overlayOpen');
    };

    SearchBox.prototype.onTriggerBody = function (e) {
        e.preventDefault();

        if (this.isOpen) {
            this.close();
        }

        Cog.fireEvent('header', 'close');
    };

    SearchBox.prototype.onTriggerClick = function (e) {
        e.preventDefault();

        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
        Cog.fireEvent('header', 'close');
    };


    SearchBox.prototype.onBlur = function () {
        if (this.$formInput.val() !== '') {
            this.$formInput.addClass('is-filled');
        } else {
            this.$formInput.removeClass('is-filled');
        }
    };

    SearchBox.prototype.addPlaceholder = function () {
        var inputPlaceholder = this.$formInput.attr('placeholder');

        if (inputPlaceholder !== '' && inputPlaceholder !== undefined) {
            this.$formInput.after('<span class="search-placeholder">' + inputPlaceholder + '</span>');
        }

        this.$formInput.on('blur', this.onBlur.bind(this));

        this.onBlur();
    };

    SearchBox.prototype.initSuggestions = function () {
        var connector = this.suggestionUrl.indexOf('?') > -1 ? '&' : '?';
        var $input = this.$el.find('.searchBox .form-search input[type="text"]');

        $input.easyAutocomplete({
            url: function(phrase) {
                return this.suggestionUrl + connector + 'q=' + phrase;
            }.bind(this),
            requestDelay: 500,
            list: {
                maxNumberOfElements: 10,
                onShowListEvent: function() {
                    this.$el.find('.easy-autocomplete-container > ul').css('display', 'block');
                }.bind(this)
            }
        });

        this.$formInput = this.$el.find('.searchBox .form-search input[type="text"]');
    };

    api.onRegister = function (scope) {
        api.element.push(new SearchBox(scope.$scope));
    };

    Cog.registerComponent({
        name: 'searchBox',
        api: api,
        selector: '.box-search.component'
    });
})(Cog.jQuery());

/**
* Help Search Box
*/

(function () {
    'use strict';

    var api = {
        element: []
    };

    function HelpSearchBox($el) {
        this.$el = $el;
        this.suggestionUrl = this.$el.find('.component-content[data-suggestion-uri]').attr('data-suggestion-uri');

        if (this.suggestionUrl) {
            this.initSuggestions();
        }

        if (!Modernizr.input.placeholder) {
            this.addPlaceholder();
        }

    }

    HelpSearchBox.prototype.initSuggestions = function () {
        var connector = this.suggestionUrl.indexOf('?') > -1 ? '&' : '?';
        var $input = this.$el.find('.searchBox .form-search input[type=\'text\']');

        $input.easyAutocomplete({
            url: function(phrase) {
                return this.suggestionUrl + connector + 'q=' + phrase;
            }.bind(this),
            requestDelay: 500,
            list: {
                maxNumberOfElements: 10,
                onShowListEvent: function() {
                    this.$el.find('.easy-autocomplete-container > ul').css('display', 'block');
                }.bind(this)
            }
        });

        this.$formInput = this.$el.find('.searchBox .form-search input[type=\'text\']');
    };

    HelpSearchBox.prototype.addPlaceholder = function () {
        var inputPlaceholder = this.$formInput.attr('placeholder');

        if (inputPlaceholder !== '' && inputPlaceholder !== undefined) {
            this.$formInput.after('<span class=\'search-placeholder\'>' + inputPlaceholder + '</span>');
        }

        this.$formInput.on('blur', this.onBlur.bind(this));

        this.onBlur();
    };

    HelpSearchBox.prototype.onBlur = function () {
        if (this.$formInput.val() !== '') {
            this.$formInput.addClass('is-filled');
        } else {
            this.$formInput.removeClass('is-filled');
        }
    };

    api.onRegister = function (scope) {
        api.element.push(new HelpSearchBox(scope.$scope));
    };

    Cog.registerComponent({
        name: 'helpSearchBox',
        api: api,
        selector: '.box-help-files-search.component'
    });
})(Cog.jQuery());

/**
 * Search Results
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    },
        status;

    /**
     * Element class
     * @param $el global search result item image
     * @constructor
     */

    function GlobalSearchResults($el) {
        this.$globalSearchResults = $el;
        this.$searchItems = this.$globalSearchResults.find('.globalSearchResults-item');

        this.handleIconsToChange();
        this.noResults();
        this.navigationHeight();
    }

    GlobalSearchResults.prototype.handleIconsToChange = function () {
        _.forEach(this.$searchItems, function (item) {
            var $searchItem = $(item),
                $originalImg = $searchItem.find('img'),
                src = $originalImg.data('src');

            if (src && src.length > 0) {
                this.replaceIcon($originalImg, src);
            }
        }.bind(this));
    };

    GlobalSearchResults.prototype.replaceIcon = function ($originalImg, src) {
        this.getNewIcon(src, function (data) {
            var $svg = $(this.getCleanSvg(data)),
                colorVariant,
                oldClass;

            if ($svg.length) {
                colorVariant = $originalImg.data('color');


                if (colorVariant) {
                    oldClass = $svg.attr('class');

                    if (oldClass === undefined) {
                        oldClass = '';
                    }

                    $svg.attr('class', oldClass + ' ' + colorVariant);
                }

                $originalImg.before($svg);
                $originalImg.hide();
            }

        }.bind(this));
    };

    GlobalSearchResults.prototype.getNewIcon = function (src, callback) {
        $.ajax({
            method: 'GET',
            url: src,
            success: function (data) {
                callback(data);
            }.bind(this)
        });
    };

    GlobalSearchResults.prototype.noResults = function () {
        if (!this.$searchItems.length) {
            $('body').addClass('global-search-no-results');
        }
    };

    GlobalSearchResults.prototype.getCleanSvg = function (data) {
        var $document = $(data),
            $svg = $document.find('svg');

        if (!$svg.length) {
            return 0;
        }

        $svg = $svg.removeAttr('xmlns:a');
        if (!$svg.attr('viewBox') && $svg.attr('height') && $svg.attr('width')) {
            $svg.attr('viewBox', '0 0 ' + $svg.attr('height') + ' ' + $svg.attr('width'));
        }
        
        return $svg.outerHTML();
    };

    GlobalSearchResults.prototype.navigationHeight = function () {
        var isMobile = status.isMobile(),
            $navigation = this.$globalSearchResults.closest('#content').find('.reference-global-search-navigation'),
            navigationHeight = $navigation.height(),
            resultsHeight = this.$globalSearchResults.outerHeight();

        if (navigationHeight > resultsHeight && !isMobile) {
            this.$globalSearchResults.height(navigationHeight);
        }
    };

    $.fn.outerHTML = function (s) {
        return (s) ? this.before(s).remove() : $('<p>').append(this.eq(0).clone()).html();
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        api.element.push(new GlobalSearchResults($el));
    };

    Cog.registerComponent({
        name: 'globalSearchResults',
        api: api,
        selector: '.globalSearchResults',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }]
    });
})(Cog.jQuery());
/**
 * Share This
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el shareThis component
     * @constructor
     */

    function ShareThis($el) {
        this.$shareThis = $el;
        this.$shareThisItems = this.$shareThis.find('.shareThis-item');

        this.handleIconsToChange();
    }

    ShareThis.prototype.handleIconsToChange = function () {
        _.forEach(this.$shareThisItems, function (item) {
            var $shareThisItem = $(item),
                $originalImg = $shareThisItem.find('img'),
                src = $originalImg.attr('src');

            if (src && src.length > 0) {
                this.replaceIcon($originalImg, src);
            }
        }.bind(this));
    };

    ShareThis.prototype.replaceIcon = function ($originalImg, src) {
        this.getNewIcon(src, function (data) {
            var $svg = $(this.getCleanSvg(data));

            if ($svg.length) {
                $originalImg.replaceWith($svg);
            }

        }.bind(this));
    };

    ShareThis.prototype.getNewIcon = function (src, callback) {
        $.ajax({
            method: 'GET',
            url: src,
            success: function (data) {
                callback(data);
            }.bind(this)
        });
    };

    ShareThis.prototype.getCleanSvg = function (data) {
        var $document = $(data),
            $svg = $document.find('svg');

        if (!$svg.length) {
            return 0;
        }

        $svg = $svg.removeAttr('xmlns:a');
        if (!$svg.attr('viewBox') && $svg.attr('height') && $svg.attr('width')) {
            $svg.attr('viewBox', '0 0 ' + $svg.attr('height') + ' ' + $svg.attr('width'));
        }

        return $svg.outerHTML();
    };

    $.fn.outerHTML = function (s) {
        return (s) ? this.before(s).remove() : $('<p>').append(this.eq(0).clone()).html();
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new ShareThis($el));
    };

    Cog.registerComponent({
        name: 'shareThis',
        api: api,
        selector: '.shareThis'
    });
})(Cog.jQuery());
/**
 * Site Map
 */
/**
 * Smart link
 */

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {
        stockCarousel: []
    };

    function StockbrokerCarousel($el) {
        this.dataFeeds = $el.find('.dataFeeds');
        this.tickGroups = $el.find('.tick-group');
        this.addElements($el);
        this.bindEvents($el); 
    }

	function tickGroupEvents($el, element) {
        element.append('<div class=\'get-quote-button\' data-feed-tick=\'' +
            element.find('.tick-ticker').text() + '\'>Get a quote</div>');
        var tickerLast = element.find('.tick-last').text() / 100,
            tickerClose = element.find('.tick-close').text(),
            tickerPrice = element.find('.tick-last').text(),
            tickerChange = tickerClose - tickerPrice;
        if(tickerChange < 0) {
			tickerChange = tickerChange * -1;
            element.append('<div class=\'tick-price negative\'>R' + tickerLast.toFixed(2) + '</div>');
        } else {
        	element.append('<div class=\'tick-price positive\'>R' + tickerLast.toFixed(2) + '</div>');
        }
    }

    StockbrokerCarousel.prototype.addElements = function($el) {
        $el.append('<span class=\'prev-arrow\'></span><span class=\'next-arrow\'></span>');

        this.tickGroups.each(function () {
            tickGroupEvents($el, $(this));
        });
    };

    StockbrokerCarousel.prototype.bindEvents = function($el) {
        var $innerFeed  = $(this.dataFeeds),
            outerWidth  = $el.width(),
            itemWidth   = this.tickGroups.outerWidth(true),
            innerWidth  = itemWidth * this.tickGroups.length,
            leftWidth   = outerWidth - innerWidth;

        $el.find('.prev-arrow').on('click', function() {
            if($innerFeed.css('left').replace(/[^-\d\.]/g, '') < (itemWidth * -1)) {
            	$innerFeed.css('left', '+=' + itemWidth);
        	} else {
                $innerFeed.css('left', '0');
            }
        });

        $el.find('.next-arrow').on('click', function() {
            if($innerFeed.css('left').replace(/[^-\d\.]/g, '') > leftWidth) {
            	$innerFeed.css('left', '-=' + itemWidth);
        	}
        });

        $el.find('.tick-group').on('click', function() {
            var ticker = $(this).find('.get-quote-button').attr('data-feed-tick');
            window.tickerObj.ticker = ticker;
            var scrollTo =  $('.reference-trade-cost-estimator').offset().top - 70;
            $('body, html').animate({scrollTop: scrollTo}, 500);
        });
    };

    api.onRegister = function (scope) {
        var $stockbrokerCarousels = scope.$scope;
        _.forEach($stockbrokerCarousels, function (stockbrokerCarousel) {
            var $stockbrokerCarousel = $(stockbrokerCarousel);
            api.stockCarousel.push(new StockbrokerCarousel($stockbrokerCarousel));
        });
    };

    Cog.registerComponent({
        name: 'stockCarousel',
        api: api,
        selector: '.stockbrokerShareInformation'
    });
}(Cog.jQuery()));

/**
 * Table
 */
/* jshint maxlen: 500 */
/*global Hammer */

(function ($) {
    'use strict';

    var api = {};

    function openTableWindow(e) {
        var height = $(window).height() / 2,
            width = $(window).width() / 2,
            link = e.target.href;

        window.open(link, '', 'menubar=1,resizable=1,scrollbars=1,width=' + width + ',height=' + height);

        return false;
    }

    api.onRegister = function (scope) {
        var $table = scope.$scope,
            $button;

        $table.find('table tr:even').addClass('even');

        $button = $table.find('.table-button');
        $button.click(openTableWindow);
    };

    Cog.registerComponent({
        name: 'table',
        api: api,
        selector: '.table'
    });
})(Cog.jQuery());

/**
 * Responsive table
 */

(function ($) {
    'use strict';

    var api = {
        tableSwipe: []
    };

    /**
     * TableSwipe class
     * @param $el table swipe
     * @constructor
     */
    function TableSwipe($el) {
        this.$el = $el;
        this.$componentContent = this.$el.find('> .component-content');
        this.tableHeaders = [];
        this.tableData = [];
        this.tableLabelData = [];
        this.isComparisonTable = this.$el.hasClass('box-comparison-table-wrapper');

        if (this.isComparisonTable) {
            this.fillComparisonTableData();
        } else {
            this.wrapSingleCells();
            this.fillTableData();
            this.fillHeader('tbody tr:first-child th');
        }

        this.fillTableContent();
        this.prepareHeaderVisiblity();
        this.bindUIEvents();
    }

    TableSwipe.prototype.wrapSingleCells = function () {
        this.$el.find('td').each(function (i, el) {
            var $el = $(el);

            if (!$el.siblings().length && !$el.children().length) {
                $el.wrapInner('<p>');
            }
        });
    };

    TableSwipe.prototype.fillTableData = function () {
        this.$el.find('tr').each(function (i, el) {
            var $children = $(el).children();
            //omit headers
            if (i > 0) {
                if ($children.length === 1) {
                    this.tableLabelData.push({
                        name: $children.first().html(),
                        merged: true
                    });
                } else {
                    $children.each(function (j, el) {
                        if (j === 0) {
                            this.tableLabelData.push({
                                name: $(el).html()
                            });
                        } else {
                            this.tableData[j - 1] = this.tableData[j - 1] || [];
                            this.tableData[j - 1].push($(el).html());
                        }
                    }.bind(this));
                }
            }
        }.bind(this));
    };

    TableSwipe.prototype.fillComparisonTableData = function () {
        this.$el.find('.box-comparison-table-column').each(function (i, el) {
            var tds = [],
                $el = $(el);

            this.tableHeaders.push($el.find('tr:first-child td').text());

            $el.find('tr:not(:first-child) td').each(function (i, el) {
                tds.push($(el).html());
            }.bind(this));

            this.tableData.push(tds);
        }.bind(this));

        this.tableHeaders.shift();

        _.forEach(this.tableData.shift(), function (el) {
            this.tableLabelData.push({
                'name': el
            });
        }.bind(this));
    };

    TableSwipe.prototype.fillHeader = function (selector) {
        var $headers = this.$el.find(selector).slice(1);

        $headers.each(function (i, el) {
            this.tableHeaders.push($(el).html());
        }.bind(this));
    };

    TableSwipe.prototype.fillTableContent = function () {
        var $container = $('<div />', {
            'class': 'table-content-items'
        });
        var $items = $('<div />', {
            'class': 'table-header-items'
        });
        var $tableHeader = $('<div />', {
            'class': 'table-header'
        });
        var k = 0;
        for (var i = 0; i < this.tableLabelData.length; i++) {
            if (this.tableLabelData[i].merged) {
                $container.append('<div class="table-content-row">' +
                                  this.tableLabelData[i].name +
                                  '</div>');
                k++;
            } else {
                $container.append('<div class="table-content-row">' +
                                  '<div class="table-content-key">' +
                                  this.tableLabelData[i].name +
                                  '</div>' +
                                  '<div class="table-content-value">' +
                                  this.tableData[0][i - k] +
                                  '</div>' +
                                  '</div>');
            }
        }

        for (var j = 0; j < this.tableHeaders.length; j++) {
            $items.append('<div class="table-header-item">' +
                          this.tableHeaders[j] +
                          '</div>');
        }

        $items.children().first().addClass('is-active');

        $items.appendTo($tableHeader);
        $container.appendTo($tableHeader);
        $tableHeader.appendTo(this.$componentContent);
    };

    TableSwipe.prototype.prepareHeaderVisiblity = function () {
        var $items = this.$el.find('.table-header-item');
        var $next = $items.eq(1);
        var $itemsReduce = $items.slice(2);

        if ($next) {
            $next.addClass('is-next');
        }

        $itemsReduce.hide();
    };

    TableSwipe.prototype.bindUIEvents = function () {
        var $tableTop = this.$el.find('.table-header-items'); //fixme after adding to dom elemtn will be visible;

        var hammerForContainer = new Hammer($tableTop[0], {
            recognizers: [
                [Hammer.Pan, {
                    direction: Hammer.DIRECTION_HORIZONTAL
                }],
                [Hammer.Swipe, {
                    direction: Hammer.DIRECTION_HORIZONTAL
                }]
            ]
        });

        hammerForContainer.add(new Hammer.Tap({event: 'tapped', taps: 1}));
        hammerForContainer.get('swipe').recognizeWith('pan');
        hammerForContainer.on('swipeleft', this.moveActiveRight.bind(this));
        hammerForContainer.on('swiperight', this.moveActiveLeft.bind(this));
        hammerForContainer.on('panmove', function (e) {
            $tableTop.css('margin-left', e.deltaX + 'px');
        }.bind(this));
        hammerForContainer.on('panend', function () {
            $tableTop.css('margin-left', '');
        }.bind(this));
    };

    TableSwipe.prototype.updateContent = function (i) {
        var $key = this.$el.find('.table-content-value');

        if (this.tableData[i]) {
            _.remove(this.tableData[i], _.isUndefined);
            for (var j = 0; j < $key.length; j++) {
                $key.eq(j).html(this.tableData[i][j]);
            }
        }
    };

    TableSwipe.prototype.moveActiveRight = function () {
        var $activeItem = this.$el.find('.is-active');
        var $next = $activeItem.next();
        var $afterNext = null;

        if ($next.length) {
            $next.removeClass('left-animation').addClass('right-animation');
            $next.addClass('is-active').removeClass('is-next').nextAll().removeClass('is-next');
            $activeItem.removeClass('is-active').addClass('is-previous left-animation').prevAll().removeClass('is-previous');
            this.updateContent(this.$el.find('.table-header-item').index($next[0]));
            $afterNext = $next.next();
            $afterNext.addClass('is-next');
        }
    };

    TableSwipe.prototype.moveActiveLeft = function () {
        var $activeItem = this.$el.find('.is-active');
        var $prev = $activeItem.prev();
        var $beforePrev = null;

        if ($prev.length) {
            $prev.removeClass('right-animation').addClass('left-animation');
            $prev.addClass('is-active').removeClass('is-previous').prevAll().removeClass('is-previous');
            $activeItem.removeClass('is-active left-animation').addClass('is-next right-animation').nextAll().removeClass('is-next');
            this.updateContent(this.$el.find('.table-header-item').index($prev[0]));
            $beforePrev = $prev.prev();
            if ($beforePrev.length) {
                $beforePrev.addClass('is-previous');
            }
        }
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.tableSwipe.push(new TableSwipe($el));
    };

    Cog.registerComponent({
        name: 'table-swipe',
        api: api,
        selector: '.table-basic, .box-comparison-table-wrapper'
    });
})(Cog.jQuery());

/**
 * Data Feeds Table
 */

(function ($) {
    'use strict';

    var api = {},
        $window = $(window),
        isMobile = checkMobile();

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 992px)');
    }

    api.dataFeeds = [];

    function DataFeeds($el) {
        this.$el = $el;
        this.$columnRows = this.$el.find('table tr > th:first-child, table tr > td:first-child');
        this.$allRows = this.$el.find('td');
        this.$wrapper = this.$el.find('> div');
        this.setWidth();
        this.colorRow();
        this.bindUIEvents();
    }

    DataFeeds.prototype.colorRow = function () {
        _.forEach(this.$allRows, function (row) {
            var $row = $(row),
                val = $row.text(),
                n = window.parseInt(val, 10);

            if (!isNaN(n) && /^\s*[+-]/.test(val)) {
                $row.addClass(val >= 0 ? 'positive' : 'negative');
            }
        });
    };

    DataFeeds.prototype.setWidth = function () {
        var maxWidth = 0,
            maxOuterWidth = 0;

        this.$columnRows.width('auto');

        if (isMobile) {
            _.forEach(this.$columnRows, function (row) {
                var $row = $(row),
                    $rowWidth = $row.width(),
                    $rowOuterWidth = $row.outerWidth();

                if ($rowWidth > maxWidth) {
                    maxWidth = $rowWidth;
                    maxOuterWidth = $rowOuterWidth;
                }
            });

            this.$columnRows.width(maxWidth);
            this.$wrapper.css('margin-left', maxOuterWidth);
        } else {
            this.$wrapper.css('margin-left', 0);
        }
    };

    DataFeeds.prototype.bindUIEvents = function () {
        $window.on('resize', _.debounce(function () {
            isMobile = checkMobile();
            this.setWidth();
        }.bind(this), 150));
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.dataFeeds.push(new DataFeeds($el));
    };

    Cog.registerComponent({
        name: 'dataFeeds',
        api: api,
        selector: '.dataFeeds'
    });
})(Cog.jQuery());

/**
 * Table Wrap on mobile Accordion style
 */

 (function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {},
        status;
    api.tableWrap = [];

    function TableWrap($el) {
        if(status.isMobile()) {
            this.initEvents($el);
        }
    }

    TableWrap.prototype.initEvents = function ($el) {
        var tableRows = $($el).find('tr > td:first-of-type'),
            arrow = '<span class=\'arrow-acc\'></span>';

        tableRows.append(arrow);
        $($el).addClass('js-active');
        this.bindUIEvents(tableRows);
    };

    TableWrap.prototype.bindUIEvents = function (tableRows) {
        $(tableRows).on('click', function() {
            if($(this).parents('tr').hasClass('acc-active')) {
                $(this).parents('tr').removeClass('acc-active');
            } else {
                $(this).parents('table').find('.acc-active').removeClass('acc-active');
                $(this).parents('tr').toggleClass('acc-active');
            }
        });
    };

    api.onRegister = function (scope) {
        var $table = scope.$scope;
        status = this.external.status;
        api.tableWrap.push(new TableWrap($table));
    };

    Cog.registerComponent({
        name: 'tableWrap',
        api: api,
        selector: '.table-mobile-wrap',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})(Cog.jQuery());
/**
 * Tabs component - desktop/js-component/component.tabs.js
 */

/* global Modernizr */

(function ($) {
    'use strict';

    var api = {
        tabs: []
    };

    function Tab($scope) {
        this.$scope = $scope;
        this.init();
        this.bindDOM();
        this.bindEvents();
        this.handleScrollingAndContentHeight();
        this.activateTab(null, this.$tabs.filter('.is-active'));
    }

    Tab.prototype.init = function () {
        var $this = this.$scope;
        this.$contents = $this.find('.tabs-content');
        this.$contents.addClass('is-hidden');
        this.isVertical = $this.hasClass('tabs-vertical');
    };

    Tab.prototype.bindDOM = function () {
        this.$tabs = this.$scope.find('.tabs-nav-item');
    };

    Tab.prototype.activateTab = function (event, $tab) {
        var newPanel;
        $tab = $tab || $(event.currentTarget);
        this.$contents.addClass('is-hidden');
        newPanel = this.$contents.filter($tab.find('a').attr('href'));
        newPanel.removeClass('is-hidden');
        this.$tabs.removeClass('is-active');
        $tab.addClass('is-active');

        if (event) {
            event.preventDefault();
        }

        Cog.fireEvent('TabSitemap', 'tabChanged', {label: $tab.find('a').text()});

        Cog.fireEvent('tab', 'change', {
            id: newPanel.attr('id'),
            container: newPanel
        });
    };

    Tab.prototype.bindEvents = function () {
        this.$tabs.on('click', this.activateTab.bind(this));
        $(window).on('resize', _.debounce(this.handleScrollingAndContentHeight.bind(this)));
    };

    Tab.prototype.handleScrollingAndContentHeight = function () {
        this.navWidth = this.$scope.find('.tabs-nav').width();
        this.listWidth = 0;
        this.listHeight = 0;
        this.$tabs.each(function (index, tab) {
            this.listWidth += $(tab).outerWidth(true);
            this.listHeight += $(tab).outerHeight(true);
        }.bind(this));

        if (!this.isVertical) {
            if (this.navWidth < this.listWidth) {
                if (!this.isActiveScrolling) {
                    this.isActiveScrolling = true;
                    this.initializeScrolling();
                }
            }
            else {
                if (this.isActiveScrolling) {
                    this.isActiveScrolling = false;
                    this.disableScrolling();
                }
            }
        } else {
            this.setContentHeight();
        }
    };

    Tab.prototype.disableScrolling = function () {
        this.$scope.find('.tabs-nav-switcher').addClass('is-hidden');
    };

    Tab.prototype.scroll = function (scrollLeft, carousel, reset, activeElem) {
        var offset = 25;

        if (!reset) {
            if (scrollLeft) {
                if (!this.nextLeft) {
                    this.nextLeft = -1 * (activeElem.width() +
                                    parseInt(activeElem.css('padding-right').replace('px', '')) - offset);
                } else {
                    this.nextLeft = this.nextLeft +
                                    (-1 * (activeElem.width() +
                                        parseInt(activeElem.css('padding-right').replace('px', '')) - offset));
                }
            } else {
                this.nextLeft = this.nextLeft +
                                (activeElem.width() +
                                    parseInt(activeElem.css('padding-right').replace('px', '')) - offset);
            }
        } else {
            this.nextLeft = 0;
        }

        carousel.$list.data('left', this.nextLeft);
        carousel.$list.stop().animate({left: this.nextLeft + 'px'});
    };

    Tab.prototype.handleScrollingActiveTab = function (scrollLeft, carousel) {
        var $oldActiveTab = this.$tabs.filter('.is-active'),
            $newActiveTab,
            activeTabOffset,
            listOffset;

        if (!$oldActiveTab.length || !this.isActiveScrolling) {
            return;
        }

        if (scrollLeft && $oldActiveTab.index() < this.$tabs.length - 1) {
            $newActiveTab = $oldActiveTab.next();
            this.activateTab(null, $newActiveTab);

            activeTabOffset = $newActiveTab.position().left + $newActiveTab.outerWidth();
            listOffset = carousel.$list.data('left') + carousel.$list.width();

            if (activeTabOffset > listOffset) {
                this.scroll(scrollLeft, carousel, false, $oldActiveTab);
            }

            if ($newActiveTab.index() >= this.$tabs.length - 1) {
                carousel.$switcherRight.addClass('is-hidden');
            }

            carousel.$switcherLeft.removeClass('is-hidden');
        } else if (scrollLeft === false && $oldActiveTab.index() > 0) {
            $newActiveTab = $oldActiveTab.prev();
            this.activateTab(null, $newActiveTab);

            activeTabOffset = $newActiveTab.position().left;
            listOffset = carousel.$list.data('left') * -1;

            if (activeTabOffset < listOffset) {
                if($newActiveTab.prev().length === 0) {
                    this.scroll(scrollLeft, carousel, true, $newActiveTab);
                } else {
                    this.scroll(scrollLeft, carousel, false, $newActiveTab);
                }
            }

            if ($newActiveTab.index() === 0) {
                carousel.$switcherLeft.addClass('is-hidden');
            }

            carousel.$switcherRight.removeClass('is-hidden');
        } else if (scrollLeft === null) {
            if ($oldActiveTab.index() >= this.$tabs.length - 1) {
                carousel.$switcherRight.addClass('is-hidden');
            } else {
                carousel.$switcherRight.removeClass('is-hidden');
            }

            if ($oldActiveTab.index() === 0) {
                carousel.$switcherLeft.addClass('is-hidden');
            } else {
                carousel.$switcherLeft.removeClass('is-hidden');
            }
        }
    };

    Tab.prototype.initializeScrolling = function () {

        var carousel = {};

        carousel.$switchers = this.$scope.find('.tabs-nav-switcher');
        carousel.$switcherRight = carousel.$switchers.filter('.tabs-nav-switcher-right');
        carousel.$switcherLeft = carousel.$switchers.filter('.tabs-nav-switcher-left');
        carousel.$list = this.$scope.find('.tabs-nav-list');
        carousel.step = carousel.$list.find('> .tabs-nav-item').eq(0).width();

        carousel.$list.css('left', 0);
        carousel.$list.data('left', 0);

        this.activateTab(null, carousel.$list.find('> .tabs-nav-item').eq(0));
        this.handleScrollingActiveTab(null, carousel);

        carousel.$switcherLeft.off('click').on('click', function () {
            this.handleScrollingActiveTab(false, carousel);
        }.bind(this));

        carousel.$switcherRight.off('click').on('click', function () {
            this.handleScrollingActiveTab(true, carousel);
        }.bind(this));

        this.$tabs.off('.carousel').on('click.carousel', function () {
            this.handleScrollingActiveTab(null, carousel);
        }.bind(this));

        carousel.$switcherRight.removeClass('is-hidden');

        this.$scope.css('overflow', 'hidden');
    };

    Tab.prototype.setContentHeight = function () {
        var self = this;
        this.$contents.each(function () {
            if ($(this).height() < self.listHeight) {
                $(this).css('min-height', self.listHeight + 'px');
            }
        });
    };

    api.onRegister = function (scope) {
        api.tabs.push(new Tab(scope.$scope));
    };

    Cog.registerComponent({
        name: 'tabs',
        api: api,
        selector: '.tabs:not(.tabs-menu), .tabs:not(.tabs-menu-redesign)'
    });
})(Cog.jQuery());

/**
 * Sitemap
 *
 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el sitemap wrapper
     * @constructor
     */

    function TabSitemap($el) {
        this.$tabContainer = $el;
        this.$tabList = this.$tabContainer.find('.tabs-nav-list');
        this.$tabs = this.$tabContainer.find('.tabs-nav-item');
        this.contentHeight = this.$tabList[0].scrollHeight;

        this.buildChoosenMobile();
        this.bindUIEvents();
    }

    TabSitemap.prototype.buildChoosenMobile = function () {
        var $choosenMobile = $('<div class="js-choosen-mobile"/>');

        $choosenMobile.text(this.$tabs.eq(0).find('a').text());
        this.$tabList.before($choosenMobile);
        this.$choosenMobile = $choosenMobile;
    };

    TabSitemap.prototype.bindUIEvents = function () {
        var root = this;

        this.$choosenMobile.on('click', function () {
            var $this = $(this);

            if ($this.hasClass('is-active')) {
                $this.removeClass('is-active');
                root.$tabList.css('max-height', 0);
            } else {
                $this.addClass('is-active');
                root.$tabList.css('max-height', root.contentHeight);
            }
        });

        $('html').on('click', function (e) {
            if (root.$choosenMobile.hasClass('is-active') && e.target !== root.$choosenMobile[0]) {
                root.$choosenMobile.removeClass('is-active');
                root.$tabList.css('max-height', 0);
            }
        });

        $(window).on('resize', _.debounce(function () {
            root.setContentHeight();
        }, 300));

        Cog.addListener('TabSitemap', 'tabChanged', this.changeActiveTab, {scope: root});
    }
    ;

    TabSitemap.prototype.setContentHeight = function () {
        var tempHeight = this.$tabList[0].scrollHeight;
        if (this.contentHeight !== tempHeight) {
            this.contentHeight = tempHeight;

            if (this.$choosenMobile.hasClass('is-active')) {
                this.$tabList.css('max-height', this.contentHeight);
            }
        }
    };

    TabSitemap.prototype.changeActiveTab = function (e) {
        this.$choosenMobile.text(e.eventData.label);
    };

    api.onRegister = function (scope) {
        api.element.push(new TabSitemap(scope.$scope));
    };

    Cog.registerComponent({
        name: 'TabSitemap',
        api: api,
        selector: '.tabs-sitemap'
    });
})
(Cog.jQuery());

/**
 * Menu
 *
 */

(function ($) {
    'use strict';

    var api = {
            element: []
        },
        status,
        isAuthor = $('body').hasClass('cq-wcm-edit') || $('body').hasClass('cq-wcm-edit-touch'),
        defaultDiacriticsRemovalMap = [
            {'base':'O', 'letters':/[\u004F]/g},
            {'base':'o', 'letters':/[\u00F3]/g}
        ];

    /**
     * Element class
     * @param $el menu wrapper
     * @constructor
     */

    function TabsMenu($el) {
        this.$tabsContainer = $el;
        this.$tabsNav = this.$tabsContainer.find('.tabs-nav');
        this.$tabsList = this.$tabsContainer.find('.tabs-nav-list');
        this.$tabsNavItem = this.$tabsContainer.find('.tabs-nav-item');
        this.$tabsNavItemLink = this.$tabsNavItem.find('a');
        this.$tabsContent = this.$tabsContainer.find('.tabs-content');
        this.contentHeight = this.$tabsList[0].scrollHeight;

        this.appendSecondaryTitle();
        this.buildNewNavStructure();
        this.bindUIEvents();

        $(window).resize(); //handle desktop header arrow

        if (status.isAuthor()) {
            Cog.addListener('boxMenu', 'open', function () {
                this.setInitialActiveTabs();
            }.bind(this));
        }
        else {
            this.setInitialActiveTabs();
        }
    }

    TabsMenu.prototype.setInitialActiveTabs = function () {
        var paths = window.location.pathname.split('/'),
            linkAnchors = [],
            foundIndex = -1;

        if (this.isInitialized) {
            return false;
        }

        this.isInitialized = true;

        _.forEach(this.$tabsNavItemLink, function (singleLink) {
            linkAnchors.push(removeDiacritics($.trim($(singleLink).text().toLowerCase())));
        });

        _.forEach(paths, function (path) {
            foundIndex = _.indexOf(linkAnchors, path.replace(/-/g, ' '));

            if (foundIndex >= 0) {
                return false;
            }
        });

        if (foundIndex >= 0) {
            this.onClick(this.$tabsNavItemLink.eq(foundIndex));
        } else {
            this.onClick(this.$tabsNavItemLink.eq(0));
        }
    };

    function removeDiacritics(str) {
        for(var i=0; i<defaultDiacriticsRemovalMap.length; i++) {
            str = str.replace(defaultDiacriticsRemovalMap[i].letters, defaultDiacriticsRemovalMap[i].base);
        }
        return str;
    }

    TabsMenu.prototype.appendSecondaryTitle = function () {
        _.forEach(this.$tabsNavItemLink, function (item) {
            var $item = $(item),
                $textWrapper = $item.find('.text-wrapper');

            if ($textWrapper.length) {
                $item.data('secondary-title', $textWrapper.text());
            } else {
                $item.data('secondary-title', $item.text());
            }
        });
    };

    TabsMenu.prototype.buildNewNavStructure = function () {
        var $tabsNavSelected = $('<div class="js-tabs-nav-selected"/>'),
            $headers = $('.header-for-tabs-menu');

        $tabsNavSelected.text(this.$tabsNavItemLink.eq(0).data('secondary-title'));
        this.$tabsNav.prepend($tabsNavSelected);
        this.$tabsNavSelected = $tabsNavSelected;

        if (this.$tabsNav.find('.header-for-tabs-menu').length === 0) {
            this.$tabsNav.prepend($headers.first().clone());
        }

        if (!isAuthor) {
            $headers.first().css('display', 'none');
        }
    };

    TabsMenu.prototype.changeNavSelected = function (selectedTitle) {
        this.$tabsNavSelected.text(selectedTitle);
    };

    TabsMenu.prototype.setActiveTab = function ($active) {
        this.$tabsContent.removeClass('is-active');
        this.$tabsContent.filter($active.attr('href')).addClass('is-active');

        this.$tabsNavItem.removeClass('is-active');
        $active.parent().addClass('is-active');

        Cog.fireEvent('tabsMenu', 'tabsChanged');
    };

    TabsMenu.prototype.storeSnippet = function (key, value) {
        if (Modernizr.sessionstorage) {
            return window.sessionStorage.setItem('_absa-navigation-' + key, value);
        }
    };

    TabsMenu.prototype.restoreSnippet = function (key) {
        var result = false;
        if (Modernizr.sessionstorage) {
            result = window.sessionStorage.getItem('_absa-navigation-' + key);
        }
        return result;
    };

    TabsMenu.prototype.parseResponse = function (data) {
        if (status.isAuthor()) {
            data = data.replace(/<script/g, '<div class="is-hidden" ')
                .replace(/<\/script>/g, '</div>')
                .replace(/author-only-placeholder/g, 'author-only-placeholder is-hidden');
        }

        return data;
    };

    TabsMenu.prototype.getSnippet = function ($link) {
        var src = $link.attr('data-src'),
            $targetTab = $($link.attr('href'));

        $link.removeAttr('data-src', '');

        if ($targetTab.data('is-loaded')) {
            Cog.fireEvent('tabsMenu', 'tabsChanged');
            return true;
        }
        else if (this.restoreSnippet(src)) {
            $targetTab.html(this.restoreSnippet(src));

            Cog.init({
                $element: $targetTab
            });

            $targetTab.data('is-loaded', true);
            Cog.fireEvent('tabsMenu', 'tabsChanged');
        }
        else {
            $targetTab.fadeOut(0).promise().done(function () {
                $.ajax({
                    url: src,
                    dataFilter: this.parseResponse.bind(this)
                }).done(function (response) {
                    $targetTab.html(response)
                        .data('is-loaded', true);

                    this.storeSnippet(src, response);
                    Cog.fireEvent('tabsMenu', 'tabsChanged');

                    Cog.init({
                        $element: $targetTab
                    });

                    _.delay(function () {
                        $targetTab.fadeIn(1000);
                    }, 500);
                }.bind(this));
            }.bind(this));
        }
    };

    TabsMenu.prototype.showTab = function () {
        this.$tabsNavSelected.addClass('is-active');
        if (!this.$tabsContainer.hasClass('tabs-menu-redesign')) {
            this.$tabsList.css('max-height', this.contentHeight);
        }
    };

    TabsMenu.prototype.hideTab = function () {
        if (!this.$tabsContainer.hasClass('tabs-menu-redesign')) {
            this.$tabsNavSelected.removeClass('is-active');
            this.$tabsList.css('max-height', 0);
        }
    };

    TabsMenu.prototype.bindUIEvents = function () {
        this.$tabsNavItem.find('a').on('focus', function () {
            if (!this.$tabsNavSelected.hasClass('is-active')) {
                this.showTab();
            }
        }.bind(this));

        this.$tabsNavItem.last().find('a').on('blur', function () {
            if (this.$tabsNavSelected.hasClass('is-active')) {
                this.hideTab();
            }
        }.bind(this));

        this.$tabsNavSelected.on('click', function (e) {
            var $this = $(e.currentTarget);

            if ($this.hasClass('is-active')) {
                this.hideTab();
            } else {
                this.showTab();
            }
        }.bind(this));

        if ( this.$tabsContainer.hasClass('tabs-menu-redesign') ) {
            this.$tabsNavItem.find('a').on('click', function (e) {
                var target = $(e.target).closest('a').attr('data-target'),
                    link = $(e.target).closest('a').attr('data-link');

                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();

                window.open(link, target);

            }.bind(this));
        }

        $('html').on('click', function (e) {
            if (this.$tabsNavSelected.hasClass('is-active') && e.target !== this.$tabsNavSelected[0]) {
                this.hideTab();
            }
        }.bind(this));

        $(window).on('resize', _.debounce(function () {
            this.setContentHeight();
        }.bind(this), 300));

        this.$tabsNavItemLink.on('click', function (e) {
            var $link = $(e.currentTarget);

            e.preventDefault();
            this.onClick($link);

        }.bind(this));

    };

    TabsMenu.prototype.onClick = function ($link) {
        if ($link.attr('data-src')) {
            this.getSnippet($link);
        }

        //temporary fix for manage width of navigation
        if ($link.parent().index() === 1) {
            $('.box-menu').addClass('js-expanded-menu-navigation');
        } else {
            $('.box-menu').removeClass('js-expanded-menu-navigation');
        }

        this.setActiveTab($link);
        this.changeNavSelected($link.data('secondary-title'));
    };

    TabsMenu.prototype.setContentHeight = function () {
        var tempHeight = this.$tabsList[0].scrollHeight;
        if (this.contentHeight !== tempHeight) {
            this.contentHeight = tempHeight;

            if (this.$tabsNavSelected.hasClass('is-active')) {
                this.$tabsList.css('max-height', this.contentHeight);
            }
        }
    };

    api.onRegister = function (scope) {
        status = this.external.status;
        api.element.push(new TabsMenu(scope.$scope));

        Cog.addListener('boxMenu', 'open', function () {
            _.forEach(api.element, function (item) {
                item.setContentHeight();
            });

            Cog.fireEvent('tabsMenu', 'tabsChanged');
        });
    };

    Cog.registerComponent({
        name: 'tabsMenu',
        api: api,
        selector: '.tabs-menu-redesign',
        requires: [
            {
                name: 'accordionExtended',
                apiId: 'accordionExtended'
            },
            {
                name: 'accordionMenu',
                apiId: 'accordionMenu'
            },
            {
                name: 'accordion',
                apiId: 'accordion'
            },
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})
(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {
        tabs: []
    };

    function TabsWithArrow($el) {
        this.$tabContainer = $el;
        this.$tabList = this.$tabContainer.find('.tabs-nav-list');
        this.$tabs = this.$tabList.find('.tabs-nav-item');
        this.$tabsText = this.$tabs.find('.text-wrapper');
        this.setEqualHeights();
        this.attachEvents();
    }

    TabsWithArrow.prototype.attachEvents = function () {
        $(window).on('resize', _.debounce(this.setEqualHeights.bind(this), 300));
        Cog.addListener('dynamicContent', 'loaded', this.setEqualHeights.bind(this));
    };

    TabsWithArrow.prototype.setEqualHeights = function () {
        var heights = [];
        this.$tabs.css('height', '');

        _.forEach(this.$tabsText, function (item) {
            heights.push($(item).outerHeight());
        });

        this.$tabsText.css('height', Math.max.apply(Math, heights) + 'px');
    };

    api.onRegister = function (scope) {
        api.tabs.push(new TabsWithArrow(scope.$scope));
    };

    Cog.registerComponent({
        name: 'tabsWithArrow',
        api: api,
        selector: '.tabs-with-arrow'
    });
})
(Cog.jQuery());

/**
 * Tag List
 */

/**
 * TagSearch
 */

 (function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.tagSearchElement = [];

    function TagSearch($el) {
        this.$el = $el;
        this.$tags = this.$el.find('[class^=product-tag]');
        this.$tagsContainer = $(this.$tags).closest('.tags-container');
        this.bindUIEvents();
    }

    TagSearch.prototype.bindUIEvents = function () {
        var elScrollWidth = $(this.$tagsContainer)[0].scrollWidth,
            elWidth = $(this.$tagsContainer).innerWidth(),
            mainElement = $(this.$el);

        this.$tags.on('click', function (e) {
            $(e.target).toggleClass('active');
            filterProducts();
        });

        if (elScrollWidth > elWidth) {
            $(mainElement).addClass('right-arrow');
        }

        $(this.$tagsContainer).on('scroll', function(e) {
            var tagsContainer = $(e.target),
                mainContainer = $(mainElement),
                scrollNr = $(tagsContainer).scrollLeft(),
                maxScroll = elScrollWidth - elWidth;

            if (scrollNr > 5) {
                $(mainContainer).addClass('left-arrow');
            } else {
                $(mainContainer).removeClass('left-arrow');
            }
            
            if(scrollNr > parseInt(maxScroll - 5)) {
                $(mainContainer).removeClass('right-arrow');
            } else {
                $(mainContainer).addClass('right-arrow');
            }
        });
    };

    function filterProducts() {
        var productCards = $('.product-card-redesign'),
            onlyProductCards = $('.product-card-redesign.productCard');
        productCards.addClass('hide-card').removeClass('filtered');
        $(productCards).closest('.content').addClass('display-flex-wrap');

        var filerValues = getActiveTagValues();

        if(filerValues.length > 0) {
            for (var index = 0; index < onlyProductCards.length; index++) {
                var cardTags = $(onlyProductCards[index]).find('.outer-container').data('tags')
                    .toString().toLowerCase().replace(/\s/g, '');
    
                for (var innerIndex = 0; innerIndex < filerValues.length; innerIndex++) {
                    if(cardTags.includes(filerValues[innerIndex])) {
                        $(onlyProductCards[index]).removeClass('hide-card').addClass('filtered');
                    }
                }
            }
        } else {
            productCards.removeClass('hide-card').addClass('filtered');
        }

        moveAdvertCards();
    }

    function moveAdvertCards() {
        var advertCards = $('.advert-card-redesign.product-card-redesign'),
            cardsContainer = $(advertCards)[0].closest('.content');
            
        for (var index = 0; index < advertCards.length; index++) {
            var tempCard = advertCards[index];
            cardsContainer.appendChild(tempCard);
        }

        advertCards.removeClass('hide-card left-card right-card').addClass('filtered');
        var showncards = $('.filtered');
        
        for (var i = 0; i < showncards.length; i++) {
            if (i % 2 == 0) {
                $(showncards[i]).addClass('left-card');
            } else {
                $(showncards[i]).addClass('right-card');
            }
        }
    }

    function getActiveTagValues() {
        var activeTags = $('.tags-container>.active');
        var activeTagValues = [];

        for (var index = 0; index < activeTags.length; index++) {
            var element = activeTags[index],
                trimmedTagValue = $(element).data('value').toString().toLowerCase().replace(/\s/g, '');
            activeTagValues.push(trimmedTagValue);
        }
        
        return activeTagValues;
    }

    api.onRegister = function (scope) {
        var $tooltip = scope.$scope;
        api.tagSearchElement.push(new TagSearch($tooltip));
    };

    Cog.registerComponent({
        name: 'tagSearchElement',
        api: api,
        selector: '.tagSearch'
    });
}(Cog.jQuery()));
/**
 * Title
 */
/**
 * Feed provider
 */

(function($) {
	"use strict";

	var api = {};

	api.preprocess = {
		twitter: function(tweet, settings) {

			function parseDate(date) {
				var values = date.split(" "), parsedDate;
				date = values[1] + " " + values[2] + ", " + values[5] + " " + values[3];
				parsedDate = Date.parse(date);

				return new Date(parsedDate);
			}

			function toDateString(date) {
				return date.getDate() + "-" + (date.getMonth() + 1) + "-" + date.getFullYear();
			}

			var target = settings.blankLinks ? " target=\"_blank\"" : "";
			tweet.text = tweet.text
				.replace(/(^|\s)http:\/\/t.co\/(\w+)/,
				"$1<a href=\"http://t.co/$2\"" + target + ">http://t.co/$2<\/a>")
				.replace(/(^|\s)@(\w+)/g, "$1<a href=\"http:\/\/www.twitter.com\/$2\"" +
				target + ">@<strong>$2</strong><\/a>")
				.replace(/(^|\s)#(\w+)/g,
				"$1<a href=\"http:\/\/twitter.com\/search?q=%23$2&src=hash\"" +
				target + ">#<strong>$2</strong><\/a>");

			var posted = parseDate(tweet.created_at);
			tweet.created_at = toDateString(posted);
			tweet.target = target;

			tweet.retwitted = false;
			if (typeof tweet.retweeted_status !== "undefined") {
				tweet.retwitted = tweet.retweeted_status.user.name;
			}

			return tweet;
		}
	};

	api.onRegister = function(scope) {
		var fp,
			provider,
			content,
			interval,
			getTweets;

		getTweets = function(provider, settings) {
			var self = api;
			$.getJSON(provider, function(data) {
				api.processData.call(self, data, settings, scope);
			});
		};

		api.scope = fp = scope.$scope;
		content = $(fp).find(".component-content");
		provider = content.data("providerPath");
		if (provider) {
			interval = content.data("refresh-interval");
			getTweets.call(fp, provider, content.data());
			if (interval) {
				(function(fp, provider, settings) {
					window.setInterval(function() {
						getTweets.call(fp, provider, settings);
					}, interval * 1000);
				})(fp, provider, content.data());
			}
		}
	};

	api.processData = function(data, settings, scope) {
		// correct JSON validation
		if (typeof data.feedType === "undefined") {
			return false;
		}
		var template = api.getTemplate(data.feedType),
			output = "";

		_.forEach(data.statuses, function(feed) {
			if (typeof api.preprocess[data.feedType] === "function") {
				feed = api.preprocess[data.feedType](feed, settings);
			}
			output += _.template(template, feed);
		});

		$(scope.$scope).find(".feed-provider-feeds").html(output);
		Cog.fireEvent("twitter", "feedsLoaded");
		return true;
	};

	api.getTemplate = function(type) {
		return $("." + type + "-template")[0].innerHTML;
	};

	Cog.registerComponent({
		name: "feedProvider",
		api: api,
		selector: ".twitter.component",
		requires: ["utils.settings"]
	});
})(Cog.jQuery());

/* global mejs */
/*jslint maxlen: 500 */

/**
 * Video
 */

(function ($) {
    'use strict';

    var api = {},
        features = [
            'playpause',
            'progress',
            'current',
            'duration',
            'tracks',
            'volume',
            'fullscreen'
        ];

    function Video ($el) {
        this.$el = $el;
        this.$video = $el.find('video');
        this.$title = $el.find('.video-heading');

        $.getScript('https://www.youtube.com/iframe_api').then(function () {
            this.initialize();
            this.bindEvents();
            this.checkYoutubeRestriction();
        }.bind(this));
    }

    Video.prototype = {
        initialize: function () {

            if (mejs.MediaFeatures.isiPhone || mejs.MediaFeatures.isiPad) {
                this.$el.addClass('is-ios-mobile');
            }

            this.$video.mediaelementplayer({
                features: features,
                enableAutosize: false,
                alwaysShowControls: true,
                plugins: ['flash', 'youtube'],
                pluginPath: api.external.settings.themePath + '/assets/swf/',
                flashName: 'flashmediaelement.swf',
                videoHeight: this.$video.attr('height'),
                success: this.onMejsSuccess.bind(this)
            });
        },

        checkYoutubeRestriction: function () {
            var image = new Image();

            image.onerror = function () {
                this.$video.show();
            }.bind(this);

            image.src = 'https://www.youtube.com/favicon.ico';
        },

        bindEvents: function () {
            Cog.addListener('overlay', 'close', this.onOverlayClose, {scope: this, disposable: true});
        },

        onOverlayClose: function () {
            if (this.$el.parents('.overlay-container').size()) {
                this.mediaElement.stop();
                this.mediaElement.remove();
                Cog.finalize(this.$el);
            }
        },

        onMejsSuccess: function (mediaElement, node, player) {
            var $videoContainer = this.$el.find('.mejs-container'),
                isMobile = $videoContainer.hasClass('mejs-iphone') ||
                    $videoContainer.hasClass('mejs-android') ||
                    $videoContainer.hasClass('mejs-ipad');

            this.mediaElement = mediaElement;

            mediaElement.addEventListener('playing', function () {
                this.$title.remove();
            }.bind(this));

            this.$title.on('click', function () {
                mediaElement.play();
            });

            if (mediaElement.attributes.autoplay) {
                mediaElement.play();
            }

            if (isMobile && mediaElement.pluginType == 'youtube') {
                player.hideControls();
                var onFirstEvent = function () {
                    setTimeout(function () {
                        player.pause();
                        player.showControls();
                        player.play();
                    }, 200);
                    mediaElement.removeEventListener('playing', onFirstEvent);
                };
                mediaElement.addEventListener('playing', onFirstEvent);
            }

            mediaElement.addEventListener('playing', function() {
                this.$el.find('.mejs-controls').addClass('visible');
            }.bind(this));
        }
    };

    api.onRegister = function (scope) {
        new Video(scope.$scope);
    };

    Cog.registerComponent({
        name: 'videoplayer',
        api: api,
        selector: '.video',
        requires: [
            {
                name: 'utils.settings',
                apiId: 'settings'
            }
        ]
    });
}(Cog.jQuery()));
/**
 * Video Gallery
 */

(function($) {
	"use strict";

	var api = {},
		features = [
			"playpause",
			"progress",
			"current",
			"duration",
			"tracks",
			"volume",
			"fullscreen"
		],
		refs = {
			thumbnailsListContainerSelector: ".videoGallery-list",
			thumbnailsArrowsSelector: ".videoGallery-arrow",
			descriptionSelector: ".videoGallery-description",
			titleSelector: ".videoGallery-heading",
			videoWrapper: ".videoGallery-video"
		};

	function provideArrayOfSources(domElement) {
		var data = $(domElement).data(),
			sources = [
				{
					src: data.srcMp4,
					type: "video/mp4"
				},
				{
					src: data.srcOgg,
					type: "video/ogg"
				},
				{
					src: data.srcWebm,
					type: "video/webm"
				}
			];
		return _.filter(sources, "src");
	}

	function VideoGallery($el) {
		this.$el = $el;
		this.$video = $el.find("video");
		this.mediaElement = null;

		this.$thumbnails = this.$el.find(refs.thumbnailsListContainerSelector);
		this.$thumbnailsList = this.$thumbnails.find("ul");
		this.$thumbnailsItems = this.$thumbnails.find("li");

		this.$arrows = this.$el.find(refs.thumbnailsArrowsSelector);
		this.listContainerWidth = this.$thumbnails.width();

		this.thumbnailWidth = this.$thumbnailsItems.eq(0).outerWidth(true);

		this.autoPlayNext = this.$el.find(refs.videoWrapper).data("autoplay-next-video");

		this.initialize();
		this.bindEvents();
	}

	VideoGallery.prototype = {
		initialize: function() {
			var self = this;

			this.$thumbnailsList.css("width", this.thumbnailWidth * this.$thumbnailsItems.length);

			this.$video.mediaelementplayer({
				features: features,
				enableAutosize: true,
				plugins: ["flash"],
				pluginPath: api.external.settings.themePath + "/assets/swf/",
				flashName: "flashmediaelement.swf",
				success: this.onMejsSuccess.bind(this)
			});

			function recalculateListWith() {
				self.listContainerWidth = self.$thumbnails.width();
				self.$thumbnailsList.css({left: 0});
				self.$arrows.filter(".videoGallery-arrow-left").addClass("is-disabled");
				self.$arrows.filter(".videoGallery-arrow-right").removeClass("is-disabled");
			}

			$(window).resize(_.throttle(recalculateListWith, 150));
		},

		bindEvents: function() {
			var self = this;

			Cog.addListener("overlay", "close", this.onOverlayClose, {scope: this, disposable: true});

			this.$thumbnailsItems.on("click", function() {
				var $this = $(this);

				self.reloadVideo({
					src: provideArrayOfSources($this),
					autoplay: true,
					title: $this.data("title"),
					poster: $this.find("img").attr("src"),
					description: $this.data("description")
				});

				self.$thumbnailsItems.removeClass("is-active");
				$this.addClass("is-active");
			});

			this.$arrows.click("click", function() {
				self.$thumbnailsList.stop(false, true);

				var $this = $(this),
					listOuterWidth = self.thumbnailWidth * self.$thumbnailsItems.length,
					left = parseInt(self.$thumbnailsList.css("left"), 10),
					vector = $this.hasClass("videoGallery-arrow-left") ? 1 : -1,
					nextLeft = left + (self.thumbnailWidth * vector),
					maxLeft = listOuterWidth - self.listContainerWidth +
						(self.listContainerWidth % self.thumbnailWidth);

				self.$arrows.removeClass("is-disabled");

				if (nextLeft <= 0 && (-1) * nextLeft <= maxLeft) {
					self.$thumbnailsList.animate({left: nextLeft});
				} else {
					$this.addClass("is-disabled");
				}

				nextLeft += self.thumbnailWidth * vector;
				if (!(nextLeft <= 0 && (-1) * nextLeft <= maxLeft)) {
					$this.addClass("is-disabled");
				}
			});
		},

		reloadVideo: function(data) {
			var mediaElement = this.mediaElement,
				$descriptionContainer = this.$el.find(refs.descriptionSelector),
				$titleContainer = this.$el.find(refs.titleSelector);

			mediaElement.pause();
			mediaElement.setSrc(data.src);
			mediaElement.load();

			if (data.poster) {
				this.$video.attr("poster", data.poster);
				this.$video.parents(".mejs-inner").find(".mejs-poster").css({
					"background-image": "url('" + data.poster + "')",
					"display": "block"
				});
			}

			if (data.autoplay) {
				mediaElement.play();
			}

			$descriptionContainer.text(data.description);
			$titleContainer.text(data.title);
		},

		onOverlayClose: function() {
			if (this.$el.parents(".overlay-container").size()) {
				this.mediaElement.stop();
				this.mediaElement.remove();
				Cog.finalize(this.$el);
			}
		},

		onMejsSuccess: function(mediaElement) {
			var self = this,
				$thumbnailsItems = this.$thumbnailsItems;

			this.mediaElement = mediaElement;

			mediaElement.addEventListener("ended", function() {
				var $nextThumbnail = $thumbnailsItems.filter(".is-active").eq(0).next();

				if ($nextThumbnail.length) {
					self.reloadVideo({
						src: provideArrayOfSources($nextThumbnail),
						autoplay: self.autoPlayNext,
						title: $nextThumbnail.data("title"),
						poster: $nextThumbnail.find("img").attr("src"),
						description: $nextThumbnail.data("description")
					});

					$thumbnailsItems.removeClass("is-active");
					$nextThumbnail.addClass("is-active");
				}
			});
		}
	};

	api.onRegister = function(scope) {
		new VideoGallery(scope.$scope);
	};

	Cog.registerComponent({
		name: "videoGallery",
		api: api,
		selector: ".videoGallery",
		requires: [
			{
				name: "utils.settings",
				apiId: "settings"
			}
		]
	});

}(Cog.jQuery()));

/**
 * Advert piece card style
 *
 */

 (function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {},
        status;

    api.advertPiece = [];

    function AdvertPiece($el) {
        if (window.Modernizr.mq('only screen and (max-width: 767px)')) {
            moveMarkup($el);
        }

        setHeights($el);

        if($($el).hasClass('advert-clickable')) {
            addClickEvent($el);
        }
        
        $(window).resize(_.debounce(function() {
            setHeights($el);
        },500));

    }

    function addClickEvent(advertEl) {
        $(advertEl).on('click', function() {
            var gotoLink = $(advertEl).find('[class^=btn-action]').attr('href');
            window.open(gotoLink, '_self');
        });
    }

    function setHeights(element) {
        var showcases = element.find('span[class*=advertPiece-showcase-]'),
        headingHeights = [],
        subCopyHeights = [];
        element.find('.advertPiece-showcase-head').css('height', 'auto');
        element.find('.advertPiece-showcase-subcopy').css('height', 'auto');
        _.forEach(showcases, function (showcase) {
            var heading = $(showcase).find('.advertPiece-showcase-head'),
            subCopy = $(showcase).find('.advertPiece-showcase-subcopy');
            headingHeights.push(heading.outerHeight());
            subCopyHeights.push(subCopy.outerHeight());
        });

        element.find('.advertPiece-showcase-head').css('height', Math.max.apply(Math, headingHeights) + 'px');
        element.find('.advertPiece-showcase-subcopy').css('height', Math.max.apply(Math, subCopyHeights) + 'px');
    }

    function moveMarkup(element) {
        var button = element.find('[class*=btn-action-]').closest('p');
        button.appendTo(element.find('.advertPiece-text-container'));
        button.find('a').addClass('showButton');
    }

    api.onRegister = function (scope) {
        var $advertPieces = scope.$scope;
        status = this.external.status;
        _.forEach($advertPieces, function (advertPiece) {
            var $advertPiece = $(advertPiece);
            api.advertPiece.push(new AdvertPiece($advertPiece));
        });
    };

    Cog.registerComponent({
        name: 'advertPiece',
        api: api,
        selector: '.advertPiece.component',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));
(function($) {
    'use strict';

    var api = {
        element: []
    };

    function Captcha(captcha) {
        var $captcha = $(captcha),
            $form = $captcha.closest('form');

        this.fillCaptcha($captcha, $form);
        this.verifyCaptcha($captcha, $form);
    }

    Captcha.prototype.fillCaptcha = function ($captcha, $form) {
        $captcha.load(removeifextradot(document.URL) + 
            '?timestamp=' + new Date().getTime() +
            ' .captcha.component', function() {
                $form.find('button[type=\'submit\']').removeClass('inactive');
        });
    };
    
    Captcha.prototype.verifyCaptcha = function($captcha, $form) {
        $form.submit(function(e) {
            var inputtext = $captcha.find('input[name=\'captchainput\']').val();
            if (inputtext == 'null' || inputtext == 'undefined') {
                e.preventDefault();
                e.stopImmediatePropagation();
                $captcha.css('display', 'inline');
            }
        });
    };

    function removeifextradot(stringURL) {
        var subStringURL = stringURL,
            dotIndex = stringURL.lastIndexOf('.');

        if(dotIndex > 27) {
            subStringURL = stringURL.substring(0, dotIndex);
        }

        return subStringURL;
    }

    api.onRegister = function(scope) {
        var $captchaList = scope.$scope;

        _.forEach($captchaList, function (captcha){
            var $captcha = $(captcha);
            api.element.push(new Captcha($captcha));
        });
    };

    Cog.registerComponent({
        name: 'captcha',
        api: api,
        selector: '.captcha.component'
    });
    
})(Cog.jQuery());

/**
 * Category navigation
 */

/* jshint maxlen: 500 */

(function ($) {
    'use strict';

    var api = {
        element: []
    };

    /**
     * Element class
     * @param $el navigation wrapper
     * @constructor
     */
    function CategoryNavigation($el) {
        this.$el = $el;
        this.navigation();
    }

    CategoryNavigation.prototype.navigation = function () {
        var $current = this.$el.find('.is-current'),
            $categoryNavigationList = this.$el.find('.categoryNavigationList');
            $categoryNavigationList.find('input').on('click',function (e) {
                changeURL(e.target);
            });

        $current.unbind('click').click(function (e) {
            var $this = $(this),
                $target = $this.next();

            e.preventDefault();

            if ($target.hasClass('active')) {
                $target.removeClass('active').slideUp();
            } else {
                $categoryNavigationList.filter('.active').removeClass('active').slideUp();
                $target.addClass('active').slideDown();
            }
        });



        function changeURL(input) {
            var value = $(input).attr('value');
            var url = window.location.href;
            var type = '&type=';

            if (value === 'all') {
                url = url.substring(0, url.indexOf(type));
            }
            else if (url.search(type) < 0) {
                url += type + value;
            } else {
                var categories = url.substring(url.lastIndexOf(type) + type.length);
                if (categories.search(value) < 0) {
                    url += ',' + value;
                } else {
                    if (categories.lastIndexOf(value) === 0) {

                        if (categories === value) {
                            url = url.substring(0, url.indexOf(type));
                        } else {
                            url = url.substring(0, url.indexOf(value + ',')) + categories.substring(value.length + 1);
                        }
                    } else {
                        url = url.substring(0, url.lastIndexOf(value) - 1) + url.substring(url.lastIndexOf(',' + value)).substring(value.length + 1);
                    }
                }
            }
            window.location.href = url;
            window.reload();
        }

    };


    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new CategoryNavigation($el));
    };

    Cog.registerComponent({
        name: 'categoryNavigation',
        api: api,
        selector: '.categoryNavigation'
    });
})(Cog.jQuery());

/**
 * LoginBox
 */

(function ($) {
    'use strict';

    var api = {
        loginBoxes: []
    };

    function LoginBox($el) {
        this.$loginBox = $el;

        this.pageName = (function () {
            var $select = this.$loginBox.find('select[name="page-name"]'),
                $label = $select.closest('.LoginBox-label'),
                $jsSelect = $label.find('.page-name');

            return {
                $select: $select,
                $selectOptions: $select.find('option'),
                $jsSelect: $jsSelect,
                $jsSelectOptions: $jsSelect.find('li'),
                $label: $label,
                $selectedLabel: $label.find('.selected-label'),
                isSelectOpen: false,
                selectedIndex: 0
            };
        }.bind(this))();

        this.serviceSelects = (function () {
            var $selectPersonal = this.$loginBox.find('select[name="personal-select"]'),
                $selectBusiness = this.$loginBox.find('select[name="business-select"]'),
                $selectCorporate = this.$loginBox.find('select[name="corporate-select"]'),
                $label = $selectPersonal.closest('.LoginBox-label'),
                $jsSelectPersonal = $label.find('.personal-select'),
                $jsSelectBusiness = $label.find('.business-select'),
                $jsSelectCorporate = $label.find('.corporate-select');


            return {
                $selectPersonal: $selectPersonal,
                $selectBusiness: $selectBusiness,
                $selectCorporate: $selectCorporate,
                $selectPersonalOptions: $selectPersonal.find('option'),
                $selectBusinessOptions: $selectBusiness.find('option'),
                $selectCorporateOptions: $selectCorporate.find('option'),
                $label: $label,
                $jsSelectPersonal: $jsSelectPersonal,
                $jsSelectBusiness: $jsSelectBusiness,
                $jsSelectCorporate: $jsSelectCorporate,
                $jsSelectPersonalOptions: $jsSelectPersonal.find('li'),
                $jsSelectBusinessOptions: $jsSelectBusiness.find('li'),
                $jsSelectCorporateOptions: $jsSelectCorporate.find('li'),
                $selectedLabel: $label.find('.selected-label'),
                selected: '',
                selectedIndex: 0,
                personalHeight: ($selectPersonal[0] ? $selectPersonal[0].scrollHeight : 0),
                businessHeight: ($selectBusiness[0] ? $selectBusiness[0].scrollHeight : 0),
                corporateHeight: ($selectCorporate[0] ? $selectCorporate[0].scrollHeight : 0)
            };
        }.bind(this)());

        this.$actionLogin = this.$loginBox.find('.action-login');
        this.$actionLoginLink = this.$actionLogin.find('a');
        this.$actionRegister = this.$loginBox.find('.action-register');
        this.$actionOnline = this.$loginBox.find('.action-online');
        this.$actionOnlineSeparator = this.$loginBox.find('.loginBox-separator');
        this.$actionRegisterLink = this.$actionRegister.find('a');

        this.setInitSelects();
        this.attachEvents();
    }

    LoginBox.prototype.setInitSelects = function () {
        var paths = window.location.pathname.split('/'),
            linkAnchors = [],
            foundPath = '';

        _.forEach(this.pageName.$selectOptions, function (singleOption) {
            linkAnchors.push($(singleOption).val());
        });

        _.forEach(paths, function (path) {
            var foundIndex = _.indexOf(linkAnchors, path);

            if (foundIndex >= 0) {
                foundPath = path;
                return false;
            }
        });

        if (foundPath.length > 0) {
            this.setSelectedPageName(foundPath);
        } else {
            this.setSelectedPageName('personal');
        }
    };

    LoginBox.prototype.openPageNameSelect = function () {
        var isActive = this.pageName.$jsSelect.hasClass('is-active');

        if (isActive) {
            this.pageName.isSelectOpen = false;
            this.closeSelect(this.pageName.$jsSelect);
        } else {
            this.pageName.isSelectOpen = true;
            this.pageName.$jsSelect.addClass('is-active');
        }
    };

    LoginBox.prototype.openServiceSelectsSelect = function () {
        var isActive = this.serviceSelects.$jsSelectChosen.hasClass('is-active');

        if (isActive) {
            this.serviceSelects.isSelectOpen = false;
            this.closeSelect(this.serviceSelects.$jsSelectChosen);
        } else {
            this.serviceSelects.isSelectOpen = true;
            this.serviceSelects.$jsSelectChosen.addClass('is-active');
        }
    };

    LoginBox.prototype.closeSelect = function ($jsSelect) {
        $jsSelect.removeClass('is-active');
        $jsSelect.removeClass('is-active');
    };

    LoginBox.prototype.setSelectedPageName = function (selectedValue) {
        var $jsSelectedOption = this.pageName.$jsSelectOptions.filter('[data-value="' + selectedValue + '"]');

        this.pageName.$select.val(selectedValue);
        this.pageName.$jsSelectOptions.removeClass('is-active');
        $jsSelectedOption.addClass('is-active');

        this.setSelectedLabel(this.pageName.$selectedLabel, $jsSelectedOption.text());

        this.serviceSelects.selected = selectedValue;
        this.setSelectedServiceChosen();
        this.setSelectedService();
    };

    LoginBox.prototype.setSelectedServiceChosen = function () {
        if (this.serviceSelects.$selectChosen) {
            this.serviceSelects.$selectChosen.removeClass('is-active');
        }

        if (this.serviceSelects.selected === 'personal') {
            this.serviceSelects.$jsSelectChosen = this.serviceSelects.$jsSelectPersonal;
            this.serviceSelects.$jsSelectOptionsChosen = this.serviceSelects.$jsSelectPersonalOptions;
            this.serviceSelects.$selectChosen = this.serviceSelects.$selectPersonal;
            this.serviceSelects.$selectOptionsChosen = this.serviceSelects.$selectPersonalOptions;
            this.pageName.selectedIndex = 0;
        } else if (this.serviceSelects.selected === 'business') {
            this.serviceSelects.$jsSelectChosen = this.serviceSelects.$jsSelectBusiness;
            this.serviceSelects.$jsSelectOptionsChosen = this.serviceSelects.$jsSelectBusinessOptions;
            this.serviceSelects.$selectChosen = this.serviceSelects.$selectBusiness;
            this.serviceSelects.$selectOptionsChosen = this.serviceSelects.$selectBusinessOptions;
            this.pageName.selectedIndex = 1;
        } else if (this.serviceSelects.selected === 'corporate') {
            this.serviceSelects.$jsSelectChosen = this.serviceSelects.$jsSelectCorporate;
            this.serviceSelects.$jsSelectOptionsChosen = this.serviceSelects.$jsSelectCorporateOptions;
            this.serviceSelects.$selectChosen = this.serviceSelects.$selectCorporate;
            this.serviceSelects.$selectOptionsChosen = this.serviceSelects.$selectCorporateOptions;
            this.pageName.selectedIndex = 2;
        }

        this.serviceSelects.$selectChosen.addClass('is-active');

    };

    LoginBox.prototype.setSelectedService = function () {

        var $selectedOption = this.serviceSelects.$selectOptionsChosen.filter(':selected'),
            selectedIndex = $selectedOption.index(),
            $jsSelectedOption = this.serviceSelects.$jsSelectOptionsChosen.eq(selectedIndex);

        this.serviceSelects.selectedIndex = selectedIndex;
        this.serviceSelects.$jsSelectOptionsChosen.removeClass('is-active');
        $jsSelectedOption.addClass('is-active');

        this.setSelectedLabel(this.serviceSelects.$selectedLabel, $jsSelectedOption.text());
        this.setLinks($jsSelectedOption.data('login'), $jsSelectedOption.data('register'));
    };
    LoginBox.prototype.setLinks = function (loginHref, registerHref) {
        if (loginHref && loginHref.length) {
            this.$actionLoginLink.attr('href', loginHref);
        }

        if (registerHref && registerHref.length) {
            this.$actionRegisterLink.attr('href', registerHref);
            this.$actionRegister.addClass('is-active');
            this.$actionOnline.addClass('is-active');
            this.$actionOnlineSeparator.addClass('is-active');
        } else {
            this.$actionRegisterLink.attr('href', '');
            this.$actionRegister.removeClass('is-active');
            this.$actionOnline.removeClass('is-active');
            this.$actionOnlineSeparator.removeClass('is-active');
        }
    };

    LoginBox.prototype.setSelectedLabel = function ($label, newValue) {
        $label.text(newValue);
    };

    LoginBox.prototype.onPageNameSelectChange = function () {
        var $selected = this.pageName.$selectOptions.filter(':selected'),
            selectedIndex = $selected.index(),
            selectedVal = $selected.val();

        if (selectedIndex !== this.pageName.selectedIndex) {
            this.pageName.selectedIndex = selectedIndex;
            this.setSelectedPageName(selectedVal);
        }
    };

    LoginBox.prototype.onServiceSelectsChange = function () {
        var $selected = this.serviceSelects.$selectOptionsChosen.filter(':selected'),
            selectedIndex = $selected.index();

        if (selectedIndex !== this.serviceSelects.selectedIndex) {
            this.serviceSelects.selectedIndex = selectedIndex;
            this.setSelectedService();
        }
    };

    LoginBox.prototype.onHtmlClick = function (e) {
        if (this.pageName.isSelectOpen && e.target !== this.pageName.$selectedLabel[0]) {
            this.pageName.isSelectOpen = false;
            this.closeSelect(this.pageName.$jsSelect);
        }
        if (this.serviceSelects.isSelectOpen && e.target !== this.serviceSelects.$selectedLabel[0]) {
            this.serviceSelects.isSelectOpen = false;
            this.closeSelect(this.serviceSelects.$jsSelectChosen);
        }
    };

    LoginBox.prototype.onResize = function () {
        this.closeSelect(this.pageName.$jsSelect);
        this.closeSelect(this.serviceSelects.$jsSelectChosen);
    };

    LoginBox.prototype.attachEvents = function () {
        this.pageName.$selectedLabel.on('click', function () {
            this.openPageNameSelect();
        }.bind(this));

        this.pageName.$jsSelectOptions.on('click', function (e) {
            var $current = $(e.currentTarget),
                index = $current.index();

            this.pageName.$selectOptions.eq(index).prop('selected', true);
            this.pageName.$select.change();
        }.bind(this));

        this.pageName.$select.on('change', this.onPageNameSelectChange.bind(this));

        this.serviceSelects.$selectedLabel.on('click', function () {
            this.openServiceSelectsSelect();
        }.bind(this));

        this.serviceSelects.$label.on('click', 'li', function (e) {
            var $current = $(e.currentTarget),
                index = $current.index();

            this.serviceSelects.$selectOptionsChosen.eq(index).prop('selected', true);
            this.serviceSelects.$selectChosen.change();
        }.bind(this));

        this.serviceSelects.$label.on('change', 'select', this.onServiceSelectsChange.bind(this));

        $('html').on('click', this.onHtmlClick.bind(this));

        $(window).on('resize', _.debounce(this.onResize.bind(this), 100));
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        api.loginBoxes.push(new LoginBox($el));
    };

    Cog.registerComponent({
        name: 'LoginBox',
        api: api,
        selector: '.loginBox'
    });
})(Cog.jQuery());

/**
 * Custom Map
 * https://developers.google.com/maps/documentation/javascript/reference
 */

/*global google */

(function ($) {
    'use strict';

    var api = {
        mapCustoms: []
    };

    function getCountrySpecificUrl(jsonUrl){
        return jsonUrl.replace('[COUNTRY]', $('meta[name=country]').attr('content'));
    }

    function getCountryApiKey()
    {
        for(var a=document.getElementsByTagName('meta'),b='',c=0;c<a.length;c++){
        if('gm-key'===a[c].getAttribute('name')&&(b=a[c].getAttribute('content'))){
        return b;}
        }
    }
    function MapCustom(scope) {
        var $accordionListTemplate = $('#accordionContactTemplate');

        this.defaultOptions = {
            height: 250,
            heightmobile: 300,
            zoom: 20,
            latitude: 51.500134,
            longitude: -0.12623,
            mapType: 'ROADMAP',
            markers: [],
            apikey: '',
            scrollwheel: false
        };
        this.jsonUrl = '/etc/barclays/contact-info/[COUNTRY]/_jcr_content/locations.json';
        this.$mapContainer = scope.$scope;
        this.activeMarker = null;
        this.contactListTemplate = _.template($accordionListTemplate.html());
        this.$contactListContainer = $accordionListTemplate.parent();
        this.visibleMarkersCurrent = [];
        this.currentRenderedContactList = '';
        this.circle = null;
        this.setInitValues();
        this.loadMarkers(); 
    }

    MapCustom.prototype.iconsHandler = {
        icons: {
            default: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-dark.png'
            },
            atm: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-atm.png'
            },
            branch: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-branch-atm.png'
            },
            postOffice: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-branch-post.png'
            },
            dealer: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-dark.png'
            }
        }
    };

    MapCustom.prototype.loadMarkers = function () {
        this.mapOptions.markers = [];
        $.getJSON(getCountrySpecificUrl(this.jsonUrl), function (data) {
            for (var i = 0; i < data.length; i++) {
                this.mapOptions.markers[i] = {
                    id: data[i].id,
                    title: data[i].title,
                    latitude: data[i].latitude,
                    longitude: data[i].longitude,
                    address: data[i].address,
                    type: data[i].type == 'branch' ? data[i].branchType : data[i].type,
                    telephone: data[i].telephone,
                    weekdayHours: data[i].weekdayHours,
                    weekendHours: data[i].weekendHours,
                    lat: window.parseFloat(data[i].latitude),
                    lng: window.parseFloat(data[i].longitude),
                    fxServices: data[i].fxServices,
                    apikey: getCountryApiKey(),
                    distance: 0,
                    icon: ''
                };
            }
            this.attachEvents();

        }.bind(this));
    };

    MapCustom.prototype.visibleMarkers = function () {
        var bounds = this.circle.getBounds(),
            visible = [];

        for (var i = 0; i < this.mapOptions.markers.length; i++) { // looping through my Markers Collection
            var markerposition = new google.maps.LatLng(this.mapOptions.markers[i].lat, this.mapOptions.markers[i].lng);
            if (bounds.contains(this.mapOptions.markers[i])) {
                this.mapOptions.markers[i].distance = google.maps.geometry.spherical.computeDistanceBetween(
                    markerposition, this.circle.getCenter());
                    this.mapOptions.markers[i].icon = window.location.hostname+
                    this.iconsHandler.icons[this.mapOptions.markers[i].type].icon;                    
                visible.push(this.mapOptions.markers[i]);
            }
        }
        if(visible.length < 3){
            this.circle.setRadius(this.circle.getRadius() + 5000);
            visible = this.visibleMarkers();
        }
        this.circle.setRadius(5000);
        visible.sort(function(a, b){
            return a.distance - b.distance;
        });
        return visible;
    };

    MapCustom.prototype.updateVisibleContactList = function () {
        var newVisibleMarkers = this.visibleMarkers(),
            newRenderedContactList;

        if (this.activeMarker) {
            if (_.findIndex(newVisibleMarkers, this.activeMarker) === -1) { //close active marker if it's not on map
                this.activeMarker = null;
            }
        }

        if (newVisibleMarkers.length >= 1) {
            if (!_.isEqual(newVisibleMarkers, this.visibleMarkersCurrent)) {
                this.visibleMarkersCurrent = newVisibleMarkers;
                newRenderedContactList = this.contactListTemplate({'markers': this.visibleMarkersCurrent});
            }
        }

        if (newRenderedContactList !== this.currentRenderedContactList) {
            this.currentRenderedContactList = newRenderedContactList;
            this.$contactListContainer.html(newRenderedContactList);

            if (this.activeMarker) {
                Cog.fireEvent('mapCustom', 'openMarker', {
                    id: 'marker-' + this.activeMarker.id
                });
            }
        }
    };

    MapCustom.prototype.attachEvents = function () {

        Cog.addListener('mapCustom', 'placeChanged', function (e) {
            this.circle.setCenter(e.eventData.place.geometry.location);
            this.updateVisibleContactList();

        }.bind(this));
    };
    MapCustom.prototype.setInitValues = function () {
        var centerPosition = new google.maps.LatLng(this.defaultOptions.latitude, this.defaultOptions.longitude);

        this.mapOptions = {
            zoom: this.defaultOptions.zoom,
            center: centerPosition,
            mapTypeId: google.maps.MapTypeId[this.defaultOptions.mapType],
            scrollwheel: false
        };

        //new circle
        this.circle = new google.maps.Circle({
            center: centerPosition,
            radius: 5000
        });
    };

    MapCustom.prototype.removeDuplicatesData = function () {
        var country = $('meta[name=country]').attr('content');

        if (country == 'mauritius') {
            this.$infoBoxHeader = $('.customInfoBox h6').text();
                this.newInfoBoxHeader = this.$infoBoxHeader.split(', ',1).filter(function(allItems,i,a){
                    return i==a.indexOf(allItems);
                }).join(', ');
            $('.customInfoBox h6').text(this.newInfoBoxHeader);
        }
    };

    api.onRegister = function (scope) {
        var browser = this.external.browser;

        if (browser.msie && browser.version < 8) {
            return false;
        }

        api.mapCustoms.push(new MapCustom(scope));
    };

    Cog.registerComponent({
        name: 'mapCustom',
        api: api,
        selector: '.findUsDashboard',
        requires: [
            {
                name: 'utils.browser',
                apiId: 'browser'
            }
        ]
    });
})(Cog.jQuery());
/* jshint maxlen: 500 */

/**
 * FindUsDashboard
 */

/*global google */

(function ($) {
    'use strict';

    var api = {
        searchMain: [],
        filters: [],
        countriesMap: {'south-africa': 'ZA', 'kenya': 'KE', 'ghana': 'GH', 'mauritius': 'MU', 'uganda': 'UG', 'mozambique': 'MZ', 'zambia': 'ZM','botswana': 'BW', 'seychelles': 'SC', 'tanzania': 'TZ'}
    };

    function searchGeocode(address) {
        var geocoder = new google.maps.Geocoder();

        geocoder.geocode({'address': address}, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                Cog.fireEvent('mapCustom', 'placeChanged', {place: results[0]});
            }
        });
    }

    function SearchMain($el) {
        if (!google) {
            return;
        }

        this.$searchInput = $el.find('.place-input');
        this.$searchSubmit = $el.find('.search-submit');
        this.autocomplete = null;
        this.attachEvents();
    }

    SearchMain.prototype.attachEvents = function () {
        var countryName = $('meta[name=country]').attr('content'),
            countryCode = api.countriesMap[countryName];

        this.$searchInput.on('keyup', function () {
            var val = this.$searchInput.val();

            if (val.length >= 3) {
                this.autocomplete = new google.maps.places.Autocomplete(this.$searchInput[0], {componentRestrictions: {country: countryCode}});
                google.maps.event.addListener(this.autocomplete, 'place_changed', function () {
                    searchGeocode($('#search-location').val() + ',' + countryCode);
                });
            } else {
                this.destroyAutocomplete();
            }

            if (val.length > 0) {
                this.$searchSubmit.addClass('is-active');
            } else {
                this.$searchSubmit.removeClass('is-active');
            }

        }.bind(this));

        this.$searchSubmit.on('click', function (e) {
            e.preventDefault();

            if (this.$searchSubmit.hasClass('is-active')) {
                searchGeocode(this.$searchInput.val() + ',' + countryCode);
            }

        }.bind(this));
    };

    SearchMain.prototype.destroyAutocomplete = function () {
        if (this.autocomplete) {
            this.autocomplete = null;
        }
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.searchMain.push(new SearchMain($el.find('.search-main')));
    };

    Cog.registerComponent({
        name: 'findUsDashboard',
        api: api,
        selector: '.findUsDashboard'
    });
})(Cog.jQuery());
/**
 * Custom Car Dealer Map
 * https://developers.google.com/maps/documentation/javascript/reference
 */

 
 /*global google */

(function ($) {
    'use strict';

    var api = {
        mapCarDealerCustoms: []
    };

    function getCountrySpecificUrl(jsonUrl){
        return jsonUrl.replace('[COUNTRY]', $('meta[name=country]').attr('content'));
    }

    function getCountryApiKey()
    {
        for(var a=document.getElementsByTagName('meta'),b='',c=0;c<a.length;c++){
        if('gm-key'===a[c].getAttribute('name')&&(b=a[c].getAttribute('content'))){
        return b;}
        }
    }
    function MapCustom(scope) {
        var $accordionListTemplate = $('#accordionContactTemplate');

        this.defaultOptions = {
            height: 250,
            heightmobile: 300,
            zoom: 20,
            latitude: 51.500134,
            longitude: -0.12623,
            mapType: 'ROADMAP',
            markers: [],
            apikey: '',
            scrollwheel: false
        };
        this.jsonUrl = '/etc/barclays/contact-info/[COUNTRY]/_jcr_content/locations.json';
        this.$mapContainer = scope.$scope;
        this.activeMarker = null;
        this.contactListTemplate = _.template($accordionListTemplate.html());
        this.$contactListContainer = $accordionListTemplate.parent();
        this.visibleMarkersCurrent = [];
        this.currentRenderedContactList = '';
        this.circle = null;
        this.setInitValues();
        this.loadMarkers(); 
    }

    MapCustom.prototype.iconsHandler = {
        icons: {
            default: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-dark.png'
            },
            atm: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-atm.png'
            },
            branch: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-branch-atm.png'
            },
            postOffice: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-branch-post.png'
            },
            dealer: {
                icon: '/etc/designs/zg/barclays/desktop/assets/img/marker-dark.png'
            }
        }
    };

    MapCustom.prototype.loadMarkers = function () {
        this.mapOptions.markers = [];
        $.getJSON(getCountrySpecificUrl(this.jsonUrl), function (data) {
            for (var i = 0; i < data.length; i++) {
                    this.mapOptions.markers[i] = {
                        id: data[i].id,
                        title: data[i].title,
                        latitude: data[i].latitude,
                        longitude: data[i].longitude,
                        address: data[i].address,
                        city: data[i].city,
                        town: data[i].suberb,
                        region: data[i].region,
                        type: data[i].type,
                        person: data[i].contactPerson,
                        email: data[i].email,
                        telephone: data[i].telephone,
                        lat: window.parseFloat(data[i].latitude),
                        lng: window.parseFloat(data[i].longitude),
                        apikey: getCountryApiKey(),
                        distance: 0,
                        icon: ''
                    };
            }
            this.attachEvents();

        }.bind(this));
    };

    MapCustom.prototype.visibleMarkers = function () {
        var bounds = this.circle.getBounds(),
            visible = [];

        for (var i = 0; i < this.mapOptions.markers.length; i++) { // looping through my Markers Collection
            var markerposition = new google.maps.LatLng(this.mapOptions.markers[i].lat, this.mapOptions.markers[i].lng);
            if (bounds.contains(this.mapOptions.markers[i])) {
                this.mapOptions.markers[i].distance = google.maps.geometry.spherical.computeDistanceBetween(
                    markerposition, this.circle.getCenter());
                    this.mapOptions.markers[i].icon = window.location.hostname+
                    this.iconsHandler.icons[this.mapOptions.markers[i].type].icon;                    
                visible.push(this.mapOptions.markers[i]);
            }
        }
        this.circle.setRadius(50000);
        visible.sort(function(a, b){
            return a.distance - b.distance;
        });

        return visible;
    };

    MapCustom.prototype.updateVisibleContactList = function () {
        var newVisibleMarkers = this.visibleMarkers(),
            newRenderedContactList;

        if (this.activeMarker) {
            if (_.findIndex(newVisibleMarkers, this.activeMarker) === -1) { //close active marker if it's not on map
                this.activeMarker = null;
            }
        }

        if (newVisibleMarkers.length >= 1) {
            if (!_.isEqual(newVisibleMarkers, this.visibleMarkersCurrent)) {
                this.visibleMarkersCurrent = newVisibleMarkers;
                newRenderedContactList = this.contactListTemplate({'markers': this.visibleMarkersCurrent});
            }
        }

        if (newRenderedContactList !== this.currentRenderedContactList) {
            this.currentRenderedContactList = newRenderedContactList;
            this.$contactListContainer.html(newRenderedContactList);

            if (this.activeMarker) {
                Cog.fireEvent('mapCarDealerCustom', 'openMarker', {
                    id: 'marker-' + this.activeMarker.id
                });
            }
        }
    };

    MapCustom.prototype.attachEvents = function () {

        Cog.addListener('mapCarDealerCustom', 'placeChanged', function (e) {
            this.circle.setCenter(e.eventData.place.geometry.location);
            this.updateVisibleContactList();

        }.bind(this));
    };
    MapCustom.prototype.setInitValues = function () {
        var centerPosition = new google.maps.LatLng(this.defaultOptions.latitude, this.defaultOptions.longitude);

        this.mapOptions = {
            zoom: this.defaultOptions.zoom,
            center: centerPosition,
            mapTypeId: google.maps.MapTypeId[this.defaultOptions.mapType],
            scrollwheel: false
        };

        //new circle
        this.circle = new google.maps.Circle({
            center: centerPosition,
            radius: 50000
        });
    };

    MapCustom.prototype.removeDuplicatesData = function () {
        var country = $('meta[name=country]').attr('content');

        if (country == 'mauritius') {
            this.$infoBoxHeader = $('.customInfoBox h6').text();
                this.newInfoBoxHeader = this.$infoBoxHeader.split(', ',1).filter(function(allItems,i,a){
                    return i==a.indexOf(allItems);
                }).join(', ');
            $('.customInfoBox h6').text(this.newInfoBoxHeader);
        }
    };

    api.onRegister = function (scope) {
        var browser = this.external.browser;

        if (browser.msie && browser.version < 8) {
            return false;
        }

        api.mapCarDealerCustoms.push(new MapCustom(scope));
    };

    Cog.registerComponent({
        name: 'mapCarDealerCustom',
        api: api,
        selector: '.findCarDealerDashboard',
        requires: [
            {
                name: 'utils.browser',
                apiId: 'browser'
            }
        ]
    });
})(Cog.jQuery());
/* jshint maxlen: 500 */

/**
 * Find Car Dealer Dashboard
 */

/*global google */

(function ($) {
    'use strict';

    var api = {
        searchMain: [],
        filters: [],
        countriesMap: {'south-africa': 'ZA', 'kenya': 'KE', 'ghana': 'GH', 'mauritius': 'MU', 'uganda': 'UG', 'mozambique': 'MZ', 'zambia': 'ZM','botswana': 'BW', 'seychelles': 'SC', 'tanzania': 'TZ'}
    };

    function searchGeocode(address) {
        var geocoder = new google.maps.Geocoder();

        geocoder.geocode({'address': address}, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                Cog.fireEvent('mapCarDealerCustom', 'placeChanged', {place: results[0]});
            }
        });
    }

    function SearchMain($el) {
        if (!google) {
            return;
        }

        this.$searchInput = $el.find('.place-input');
        this.$searchSubmit = $el.find('.search-submit');
        this.autocomplete = null;
        this.attachEvents();
    }

    SearchMain.prototype.attachEvents = function () {
        var countryName = $('meta[name=country]').attr('content'),
            countryCode = api.countriesMap[countryName];

        this.$searchInput.on('keyup', function () {
            var val = this.$searchInput.val();

            if (val.length >= 3) {
                this.autocomplete = new google.maps.places.Autocomplete(this.$searchInput[0], {componentRestrictions: {country: countryCode}});
                google.maps.event.addListener(this.autocomplete, 'place_changed', function () {
                    searchGeocode($('#search-location').val() + ',' + countryCode);
                });
            } else {
                this.destroyAutocomplete();
            }

            if (val.length > 0) {
                this.$searchSubmit.addClass('is-active');
            } else {
                this.$searchSubmit.removeClass('is-active');
            }

        }.bind(this));

        this.$searchSubmit.on('click', function (e) {
            e.preventDefault();

            if (this.$searchSubmit.hasClass('is-active')) {
                searchGeocode(this.$searchInput.val() + ',' + countryCode);
            }

        }.bind(this));
    };

    SearchMain.prototype.destroyAutocomplete = function () {
        if (this.autocomplete) {
            this.autocomplete = null;
        }
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.searchMain.push(new SearchMain($el.find('.search-main')));
    };

    Cog.registerComponent({
        name: 'findCarDealerDashboard',
        api: api,
        selector: '.findCarDealerDashboard'
    });
})(Cog.jQuery());
/* jshint maxlen: 500 */

/**
 * MultiStackedSubNavigation
 *
 */

/*global Hammer */

(function ($) {
    'use strict';

    var api = {
        element: []
    },
        $window = $(window),
        status,
        isTablet = checkTablet(),
        isMobile = checkMobile();

    function checkMobile() {
        return window.Modernizr.mq('only screen and (max-width: 480px)');
    }

    function checkTablet() {
        return window.Modernizr.mq('only screen and (max-width: 700px)');
    }

    /**
     * Element class
     * @param $element navigation wrapper
     * @constructor
     */
    function MultiStackedSubnavigation ($element) {

        this.$element = $element;
        this.bindDOM();
        this.activeIndex = this.$items.filter('.is-active').index();
        this.containerWidth = this.$container.width();
        this.itemCount = this.$items.length;
        this.itemsToBeVisible = this.itemCount;
        this.maxItemIndex = this.itemCount - this.itemsToBeVisible;
        this.isSliderActive = null;
        this.isButtonPreviousActive = false;
        this.isButtonNextActive = false;
        this.urls = [];

        _.forEach(this.$itemLinks, function (item) {
            this.urls.push($(item).attr('href'));
        }.bind(this));

        if (this.activeIndex === -1) {
            this.activeIndex = 0;
        }

        if (this.$items.length === 0) {
            return false;
        }

        this.setItemWidth();
        this.handleWithNavigationWidth();
        this.slider = this.slider();

        if (status.isAuthor()) {
            return false;
        }

        this.attachEvents();
    }

    MultiStackedSubnavigation.prototype.bindDOM = function () {
        this.$container = this.$element.find('.multiStackedSubnavigation-container');
        this.$buttonPrevious = this.$element.find('.multiStackedSubnavigation-prev');
        this.$buttonNext = this.$element.find('.multiStackedSubnavigation-next');
        this.$list = this.$element.find('ul');
        this.$items = this.$list.find('li');
        this.$itemLinks = this.$items.find('a');
        this.$container.append(this.$buttonNext);
        this.$container.append(this.$buttonPrevious);
        this.$container.append('<div class=\'current-active\'></div>');
    };

    MultiStackedSubnavigation.prototype.calculateListWidth = function (numberOfItems) {
        var widthSum = 0;
            numberOfItems = numberOfItems || this.$items.length;

        _.forEach(this.$items, function(item, index) {
            if (index <= numberOfItems) {
                widthSum += this.measureItemWidth($(item));
            }
        }.bind(this));

        return widthSum;
    };

    MultiStackedSubnavigation.prototype.measureItemWidth = function (item) {
        item = item || this.$items.first();
        return window.parseInt(item.outerWidth(), 10);
    };

    MultiStackedSubnavigation.prototype.calculateItemWidth = function () {
        return this.containerWidth / this.itemsToBeVisible;
    };

    MultiStackedSubnavigation.prototype.setItemWidth = function () {
        switch (this.itemCount)
        {
            case 1:
                this.itemsToBeVisible = 1;
                this.$container.addClass('contain-one-multiStacked-item');
                this.$items.addClass('one-multiStacked-item');
                break;
            case 2:
                this.itemsToBeVisible = 2;
                this.$container.addClass('contain-two-multiStacked-items');
                this.$items.addClass('two-multiStacked-items');
                break;
            case 3:
                this.itemsToBeVisible = 3;
                this.$container.addClass('contain-three-multiStacked-items');
                this.$items.addClass('three-multiStacked-items');
                break;
            case 4:
                this.itemsToBeVisible = 4;
                this.$container.addClass('contain-four-multiStacked-items');
                this.$items.addClass('four-multiStacked-items');
                break;
            case 5:
                this.itemsToBeVisible = 5;
                break;
            case 6:
                this.itemsToBeVisible = 6;
                break;
            default:
                this.itemsToBeVisible = this.itemCount;
                break;
        }
        this.toggleTabletMobileScreenSizes();

        if(!this.$element.hasClass('multistacked-redesigned')) {
            this.$items.css('width', this.calculateItemWidth() + 'px');
        }

        this.showMultistack();
    };

    MultiStackedSubnavigation.prototype.showMultistack = function () {
        this.$element.css('opacity', '1');
    };

    MultiStackedSubnavigation.prototype.toggleTabletMobileScreenSizes = function () {
        if (isTablet && this.itemsToBeVisible > 3 && !this.$element.hasClass('multistacked-redesigned')) {
            this.itemsToBeVisible = 4;
            this.$container.addClass('contain-four-multiStacked-items');
            this.$items.addClass('four-multiStacked-items');
            this.$items.css('width', this.calculateItemWidth() + 'px');
            this.isSliderActive = true;
            this.$element
                .addClass('js-slider-mode')
                .removeClass('js-no-slider-mode');
        } else if (status.isMobile() && this.itemsToBeVisible >= 6 && !this.$element.hasClass('multistacked-redesigned')) {
            this.itemsToBeVisible = 6;
            this.$container.addClass('contain-six-multiStacked-items');
            this.$items.addClass('six-multiStacked-items');
            this.$items.css('width', this.calculateItemWidth() + 'px');
            this.isSliderActive = true;
            this.$element
                .addClass('js-slider-mode')
                .removeClass('js-no-slider-mode');
        } else {
            this.$element
                .removeClass('js-slider-mode')
                .addClass('js-no-slider-mode');
        }

        $( this.$itemLinks ).each(function( i ) {

            var itemText = $(this).text();
            var charCount = itemText.trim().length;
            this.trimStr = $.trim(itemText).split(' ');
            var multiStack = $('.multiStackedSubnavigation-container').find('ul');
            var multiStackItem =  multiStack.find('li');
            var itemAtIndexObj=  multiStackItem[i];
            var itemAtIndex =  $(itemAtIndexObj);
            var itemAtIndexText =  itemAtIndex.find('a');
            var itemLength = this.trimStr.length;

            switch (true)
            {
                case ((itemLength === 2) && (charCount > 10) && isMobile ) :
                    itemAtIndexText.addClass('line-h4');
                    break;
                case ((itemLength === 2) && isMobile) :
                    itemAtIndexText.addClass('line-h3');
                    break;
                default:
                    itemAtIndexText.removeClass('line-h2');
                    itemAtIndexText.removeClass('line-h3');
                    itemAtIndexText.removeClass('line-h4');
            }
        });
    };

    MultiStackedSubnavigation.prototype.calculateScrollOffset = function() {
        var $item = this.$items.eq(this.activeIndex),
            padding = window.parseInt(this.$container.css('padding-left'), 10),
            $itemToScrollTo = $item,
            numberOfItemsToOffset;

            if(!this.$element.hasClass('multistacked-redesigned')) {
                numberOfItemsToOffset = this.activeIndex - (this.itemsToBeVisible - (this.$items.length - this.activeIndex));

                if (this.$items.length - this.activeIndex < this.itemsToBeVisible) {
                    $itemToScrollTo = this.$items.eq(numberOfItemsToOffset);
                }
            }

        return $itemToScrollTo.position().left + padding;
    };

    MultiStackedSubnavigation.prototype.isScrollNeeded = function() {
        var $item = this.$items.eq(this.activeIndex),
            offset = $item.position().left,
            width = this.measureItemWidth($item),
            containerWidth = Math.min($window.width(), this.$container.width()),
            hasSiblingsThatShouldBeVisible = this.$items.length - this.activeIndex > this.itemsToBeVisible,
            isOutsideViewport = offset + width > containerWidth,
            isOutsideViewportOnLeft = offset < width;

        return hasSiblingsThatShouldBeVisible || isOutsideViewport || isOutsideViewportOnLeft;
    };

    MultiStackedSubnavigation.prototype.setListPosition = function () {
        var offset = 0;

        if (this.activeIndex === 0) {
            this.$list.css('left', 0);
        } else if (this.isScrollNeeded()) {
            offset = this.calculateScrollOffset();
            this.$list.css('left', -offset);
        }
    };

    MultiStackedSubnavigation.prototype.handleWithNavigationWidth = function () {
        this.containerWidth = this.$container.width();
    };

    MultiStackedSubnavigation.prototype.activateByUrl = function (url) {
        var index = this.$itemLinks
        .filter('a[href*="' + url + '"]')
        .parent('li').index();

        this.slider.changeTo(index);
    };

    MultiStackedSubnavigation.prototype.slider = function () {
        this.handleActiveItem(this.activeIndex);
        this.setListPosition();
        this.handleButtons();

        return {
            changeTo: function (index) {
                this.activeIndex = index;
                this.handleActiveItem(index);
                this.setListPosition();
                this.handleButtons();
            }.bind(this),

            changeIndex: function(index) {
                var $link = this.$itemLinks.eq(index);
                this.slider.changeTo(index);

                Cog.fireEvent('multiStackedSubnavigation', 'changedActivePage',
                              { activeHref: $link.attr('href') });
            }.bind(this),

            next: function () {
                if (this.isButtonNextActive) {
                    this.slider.changeIndex(this.activeIndex + 1);
                }
            }.bind(this),

            previous: function () {
                if (this.isButtonPreviousActive) {
                    this.slider.changeIndex(this.activeIndex - 1);
                }
            }.bind(this)
        };
    };

    MultiStackedSubnavigation.prototype.handleButtons = function () {
        if (this.activeIndex === 0) {
            if (this.isButtonPreviousActive) {
                this.isButtonPreviousActive = false;
                this.$buttonPrevious.removeClass('is-active');
            }
        } else {
            if (!this.isButtonPreviousActive) {
                this.isButtonPreviousActive = true;
                this.$buttonPrevious.addClass('is-active');
            }
        }

        if (this.activeIndex === this.$items.length - 1) {
            if (this.isButtonNextActive) {
                this.isButtonNextActive = false;
                this.$buttonNext.removeClass('is-active');
            }
        } else {
            if (!this.isButtonNextActive) {
                this.isButtonNextActive = true;
                this.$buttonNext.addClass('is-active');
            }
        }
    };

    MultiStackedSubnavigation.prototype.handleActiveItem = function (newActiveIndex) {
        var $active = this.$items.eq(newActiveIndex);

        this.$items
            .removeClass('is-active-prev')
            .removeClass('is-active-next')
            .removeClass('is-active');

        $active.addClass('is-active');
        $active.prev().addClass('is-active-prev');
        $active.next().addClass('is-active-next');
        $('.current-active').html('').append($active.find('a').clone());
    };

    MultiStackedSubnavigation.prototype.setupSwipe = function() {
        var hammerForContainer = new Hammer(this.$container[0], {
            recognizers: [
                [Hammer.Swipe, {direction: Hammer.DIRECTION_HORIZONTAL}]
            ]
        });

        hammerForContainer.on('swipeleft', this.slider.next.bind(this));
        hammerForContainer.on('swiperight', this.slider.previous.bind(this));
    };

    MultiStackedSubnavigation.prototype.onResize = function() {
        this.handleWithNavigationWidth();
        this.setItemWidth();
        this.setListPosition();
    };

    MultiStackedSubnavigation.prototype.onInterrupt = function(e) {
        var $page = $('body');
        if ( e.which > 0 || e.type == 'mousedown' || e.type == 'mousewheel'){
            $page.clearQueue().stop(true, false);
        }
    };

    MultiStackedSubnavigation.prototype.onClick = function(e) {
        var $this = $(e.currentTarget),
            index = $this.parent().index();

        e.preventDefault();

        this.slider.changeTo(index);

        $this.parent('.multiStackedSubnavigation-container').removeClass('is-open');

        Cog.fireEvent('multiStackedSubnavigation', 'changedActivePage', {
            activeHref: $this.attr('href')
        });
    };

    MultiStackedSubnavigation.prototype.mobileDropToggle = function (e) {
        e.preventDefault();
        $(this.$container).toggleClass('is-open');
    };

    MultiStackedSubnavigation.prototype.autoPageScroll = function () {
        var page = $('html, body');

        setTimeout(function(){
            var bannerSelector = '.richText-hero.fixed-component';

            if( $('.richText-hero.fixed-component.richText-hero-hide').length == 1) {
                bannerSelector = '.box-hero-group-wrapper';
            }

            this.$height = $(bannerSelector).outerHeight(true);

            page.on('scroll mousedown wheel DOMMouseScroll mousewheel keyup touchmove', function() {
                page.stop();
            });

            page.animate({ scrollTop: this.$height + this.$navigationHeight }, 1100, function() {
                page.off('scroll mousedown wheel DOMMouseScroll mousewheel keyup touchmove');
            });
        }, 1350);
    };

    MultiStackedSubnavigation.prototype.attachEvents = function () {
        this.setupSwipe();
        $(window).on('resize', _.debounce(function () {
            isMobile = checkMobile();
            isTablet = checkTablet();
        }.bind(this), 100));
        $window.on('resize', _.debounce(this.onResize.bind(this), 100));
        this.$itemLinks.on('click', this.onClick.bind(this));
        if(!this.$element.hasClass('multistacked-redesigned')) {
            this.$itemLinks.on('click', this.autoPageScroll.bind(this));
        }
        this.$buttonPrevious.on('click', this.slider.previous.bind(this));
        this.$buttonNext.on('click', this.slider.next.bind(this));
        this.$container.on('click', this.mobileDropToggle.bind(this));

        Cog.addListener('multiStackedLoader', 'urlChange', function (e) {
            var url = e.eventData.url;

            if (url.lastIndexOf('/') == url.length- 1) {
                url = url.substr(0, url.lastIndexOf('/'));
            }

            url = url.substr(url.lastIndexOf('/') + 1);
            this.activateByUrl(url);
        }.bind(this));

        Cog.fireEvent('multiStackedSubnavigation', 'attachedDOM', {
            urls: this.urls
        });
    };

    api.onRegister = function (scope) {
        status = this.external.status;
        api.element.push(new MultiStackedSubnavigation(scope.$scope));
    };

    Cog.registerComponent({
        name: 'multiStackedSubnavigation',
        api: api,
        selector: '.multiStackedSubnavigation',
        requires: [
            {
                name: 'multiStackedLoader',
                apiId: 'multiStackedLoader'
            },
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {
        element: []
    },
        handleHistory,
        url,
        request,
        cache = {},
        $window = $(window),
        isHashManuallyChanged = false;

    function MultiStackedLoader (urls) {
        this.urls = urls;
        this.attachEvents();
    }

    MultiStackedLoader.prototype.isCorrectUrl = function (url) {
        var isCorrect = false;
        _.forEach(this.urls, function (item) {
            if (url.indexOf(item) > -1) {
                isCorrect = true;
            }
        });
        return isCorrect;
    };

    MultiStackedLoader.prototype.attachEvents = function () {
        Cog.addListener('multiStackedSubnavigation', 'changedActivePage', function (data) {
            url = data.eventData.activeHref;
            if (url) {
                this.load(url);
            }
        }.bind(this));

        if (handleHistory.isSupported) {
            handleHistory.onpopstate(function () {
                var url = this.getUrl(),
                    hash = window.location.hash;
                if (this.isCorrectUrl(url)) {
                    this.load(url, true);
                } else if (!hash) {
                    window.location.href = url;
                }
            }.bind(this));
        }
        else {
            $window.on('hashchange', function () {
                var url = this.getUrl();
                if (!isHashManuallyChanged && this.isCorrectUrl(url)) {
                    this.load(url, true);
                }
                isHashManuallyChanged = false;
            }.bind(this));
        }

    };

    MultiStackedLoader.prototype.load = function (url, isGoingBack) {
        if (!url) {
            return false;
        }

        if (request && request.readystate !== 4) {
            request.abort();
        }

        $('#content.main').removeClass('has-loaded');

        if( $('.richText-hero.fixed-component.richText-hero-hide').length == 1) {
            $('.box-hero-group-wrapper').removeClass('has-loaded');
        } else {
            $('.richText-hero.fixed-component').removeClass('has-loaded');
        }

        if (cache[url]) {
            this.onLoad(cache[url]);

            if (!isGoingBack) {
                this.setUrl(url);
            }
        }
        else {
            request = $.ajax({
                method: 'GET',
                url: url,
                beforeSend: function () {
                    Cog.fireEvent('loader', 'change', 0.3);
                }.bind(this),
                success: function (data) {
                    cache[url] = data;
                    this.onLoad(data);
                }.bind(this)
            });
        }
    };

    MultiStackedLoader.prototype.reinitialize = function ($element) {
        Cog.init({
            $element: $element
        });
    };

    MultiStackedLoader.prototype.getDataObject = function (data) {
        return $($.trim(data));
    };

    MultiStackedLoader.prototype.clearScripts = function (html) {
        return html.replace(/(document.write\('<script)(.+?)(?=\))/g, 'Cog.preloadScript(\'<cog$2cog')
            .replace(/<\\\/script>\'cog/g, '</cog>\'');
    };

    /*
     Loads all scripts that supposed to be injected using document.write before appending the new content;
     */
    MultiStackedLoader.prototype.setContentWithScripts = function (html) {
        var $html = $(this.clearScripts(html)),
            $scripts = $html.find('script:not([type*="template"])'),
            isDocumentWriteUsed = false,
            scriptsToPreload = [],
            recurGetScript = function(index, callback) {
                if (scriptsToPreload[index]) {
                    Cog.fireEvent('loader', 'change', index / 10);
                    $.getScript(scriptsToPreload[index], function() {
                        recurGetScript(index + 1, callback);
                    });
                }
                else {
                    callback();
                    _.delay(function() {
                        Cog.fireEvent('loader', 'change', 1);
                    }, 200);
                }
            },
            $content;

        $scripts.detach();

        Cog.preloadScript = function(scriptString) {
            var src = $(scriptString).attr('src');
            scriptsToPreload.push(src);
        };

        $content = $('#content.main');
        $content.html('');

        _.forEach($scripts, function(script) {
            var $script = $(script);

            if ($script.html().indexOf('Cog.preloadScript') > -1) {
                isDocumentWriteUsed = true;
            }
            $script.appendTo($content);
        });

        if (isDocumentWriteUsed) {
            recurGetScript(0, function() {
                $content.append($html);
                this.reinitialize($content);
            }.bind(this));
        }
        else {
            $content.append($html);
            this.reinitialize($content);
        }
    };

    MultiStackedLoader.prototype.setBanner = function(html) {
        _.defer(function () {

            var $banner = $('.richText-hero.fixed-component');

            if( $('.richText-hero.fixed-component.richText-hero-hide').length == 1) {
                $banner = $('.box-hero-group-wrapper');
            }

            $banner.html(html).addClass('has-loaded');
            this.reinitialize($banner);
        }.bind(this));
    };

    MultiStackedLoader.prototype.getBanner = function (dataObject) {
        var banner = '.richText-hero.fixed-component';

        if( $('.richText-hero.fixed-component.richText-hero-hide').length == 1) {
            banner = '.box-hero-group-wrapper';
        }

        return dataObject.find(banner).html() || '';
    };

    MultiStackedLoader.prototype.setContent = function (html) {
        if (html.indexOf('document.write') > -1) {
            return this.setContentWithScripts(html);
        }
        _.defer(function () {

            var $content = $('#content.main');

            $content.html(html).addClass('has-loaded');

            this.reinitialize($content);
        }.bind(this));
    };

    MultiStackedLoader.prototype.getContent = function (dataObject) {
        return dataObject.find('#content.main').html() || '';
    };


    MultiStackedLoader.prototype.setBreadcrumbs = function (html) {
        _.defer(function () {
            var $breadcrumbs = $('.component.breadcrumbs');
            $breadcrumbs.html(html).removeClass('initialized');
            this.reinitialize($breadcrumbs);
        }.bind(this));
    };

    MultiStackedLoader.prototype.getBreadcrumbs = function (dataObject) {
        return dataObject.find('.component.breadcrumbs').html() || '';
    };


    MultiStackedLoader.prototype.setUrl = function (url) {
        if (handleHistory.isSupported) {
            handleHistory.push({url: url}, null, url);
        }
        else {
            isHashManuallyChanged = true;
            window.location.hash = '/url=' + url;
        }
    };

    MultiStackedLoader.prototype.getUrl = function () {
        var url = null;

        if (handleHistory.isSupported) {
            url = window.location.pathname;
        }
        else {
            url = window.location.hash.replace('#/url=', '');
        }

        Cog.fireEvent('multiStackedLoader', 'urlChange', {
            url: url
        });

        return url;
    };

    MultiStackedLoader.prototype.getDataLayerScript = function (dataObject) {
        return dataObject.filter('#dataLayerScript').text() || '';
    };

    MultiStackedLoader.prototype.setDocumentTitle = function (dataObject) {
        document.title = dataObject.filter('title').text();
    };

    MultiStackedLoader.prototype.onLoad = function (data, isGoingBack) {
        var dataObject = this.getDataObject(data);

        var content = this.getContent(dataObject);
        var banner = this.getBanner(dataObject);
        var breadcrumbs = this.getBreadcrumbs(dataObject);
        var dataLayerScript = this.getDataLayerScript(dataObject);

        this.setContent(content);
        this.setDocumentTitle(dataObject);
        this.setBreadcrumbs(breadcrumbs);
        this.setBanner(banner);

        if (!isGoingBack) {
            this.setUrl(url);
        }

        Cog.fireEvent('loader', 'change', 1);
        Cog.fireEvent('dataLayer', 'reset', {
            dataLayerScript: dataLayerScript
        });
    };

    api.init = function () {
        Cog.addListener('multiStackedSubnavigation', 'attachedDOM', function (data) {
            handleHistory = this.external.handleHistory;
            new MultiStackedLoader(data.eventData.urls);
        }.bind(this));
    };

    Cog.registerStatic({
        name: 'multiStackedLoader',
        api: api,
        requires: [
            {
                name: 'utils.history',
                apiId: 'handleHistory'
            }
        ]
    });
})(Cog.jQuery());

/**
 * Temporary js for a cclassname to add space to the top of the wrapper,
 * so that no image or content is behind the header, See line 34 of _snippetReference-header.scss
 */

(function() {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};
    api.redesignHeader = [];

    function RedesignHeader() {
        $('body').addClass('redesigned-header');
    }

    api.onRegister = function() {
        api.redesignHeader.push(new RedesignHeader());
    };

    Cog.registerComponent({
        name: 'redesignHeader',
        api: api,
        selector: '.redesign-header-snippet'
    });
})(Cog.jQuery());


/* jshint maxlen: 500 */

/**
 * egainChat and Cobrowse
 */

(function($) {
  'use strict';

  //BEGIN SECTION FOR ONETAG
  //PROD
  // var EG_ACT_ID = "EG45381618",
  //   EG_ACT_ID_Path = "//analytics.analytics-egain.com/onetag/",
  //   URL = "https://skybranch.absa.co.za/system",
  //   TEMPLATE =
  //   '/templates/chat/sunburst/chat.html?entryPointId=1401&
  //  templateName=sunburst&languageCode=en&countryCode=US&ver=v11&postChatAttributes=';

  //UAT
    /* var TAG_ID = '',
    URL = '',
    TEMPLATE = '';*/

  function EgainChat($el) {
    this.$el = $el;

    // Inputs for all user defined variables
    this.$inputs = {
      server_url: $el.find('[data-hook="input-server_url"]'),
      template_path: $el.find('[data-hook="input-template_path"]'),
      tag_id: $el.find('[data-hook="input-tag_id"]'),
      tag_path: $el.find('[data-hook="input-tag_path"]')
    };

    this.setDefaultInputValues();
    this.loadCobrowseScript();
    this.bindEvents();
  }

  EgainChat.prototype.setDefaultInputValues = function() {

    this.TAG_ID = this.$inputs.tag_id.attr('data-tag-id');
    this.URL = this.$inputs.server_url.attr('data-server-url');
    this.TEMPLATE = this.$inputs.template_path.attr('data-template-path');

  };

  EgainChat.prototype.loadCobrowseScript = function() {

    var EG_ACT_ID = 'EG45381618',
      EG_ACT_ID_Path = '//analytics.analytics-egain.com/onetag/';

    if (this.TAG_ID !== null && this.TAG_ID !== '') {

      EG_ACT_ID = this.TAG_ID;

      var eg = document.createElement('script'),
        s = document.getElementsByTagName('script')[0];
      eg.type = 'text/javascript';
      eg.async = true;
      eg.src = EG_ACT_ID_Path + EG_ACT_ID;
      s.parentNode.insertBefore(eg, s);
    }

  };
  //END SECTION FOR ONETAG

  //BEGIN SECTION FOR CHAT
  //script supplied by LisaS

  var egainChat = {};

  //UAT Config
  // var egainChat = {},
  //   url = "https://skybranch_staging.absa.co.za/system",
  //   template =
  //   "/templates/chat/absa/chat.html?entryPointId=1202&templateName=absa&languageCode=en&
  //  countryCode=US&ver=v11&postChatAttributes=";

  egainChat.egainChatParameters = {};
  //Set to true to enable posting attributes to templates.
  egainChat.postChatAttributes = false;
  egainChat.eglvchathandle = null;
  egainChat.liveServerURL = 'https://skybranch.absa.co.za/system';
  egainChat.template =
        '/templates/chat/sunburst/chat.html?entryPointId=1401&templateName=sunburst&languageCode=en&countryCode=US&ver=v11&postChatAttributes=';

  var api = {
    egainChat: []
  };

  EgainChat.prototype.openHelp = function() {

      if (this.URL != null){
          egainChat.liveServerURL = this.URL;
      }

      if (this.TEMPLATE != null){
          egainChat.template = this.TEMPLATE;
      }

      var domainRegex = /^((?:https?:\/\/)?(?:www\.)?([^\/]+))/i;
      try {
        if (egainChat.eglvchathandle != null && egainChat.eglvchathandle.closed === false) {
          egainChat.eglvchathandle.focus();
          return;
        }
      } catch (err) {}
      var refererName = '';
      refererName = encodeURIComponent(refererName);
      var refererurl = encodeURIComponent(document.location.href);
      var hashIndex = refererurl.lastIndexOf('#');
      if (hashIndex != -1) {
        refererurl = refererurl.substring(0, hashIndex);
      }
      var eglvcaseid = (/eglvcaseid=[0-9]*/gi).exec(window.location.search);
      var vhtIds = '';
      var EGAINCLOUD = EGAINCLOUD;
      if (typeof EGAINCLOUD != 'undefined' && EGAINCLOUD.Account.getAllIds) {
        var ids = EGAINCLOUD.Account.getAllIds();
        vhtIds = '&aId=' + ids.a + '&sId=' + ids.s + '&uId=' + ids.u;
      }
      var EG_CALL_Q = window.EG_CALL_Q || [];
      EG_CALL_Q.push([
        'enableTracker', true
      ]);

      var eGainChatUrl = egainChat.liveServerURL + egainChat.template +
        egainChat.postChatAttributes +
        '&eglvrefname=' + refererName + '&' + eglvcaseid + vhtIds;
      var domain = domainRegex.exec(eGainChatUrl)[0];
      if (window.navigator.userAgent.indexOf('Trident') != -1 && egainChat.postChatAttributes) {
        var win = document.getElementById('egainChatDomainFrame');
        win.contentWindow.postMessage(JSON.stringify(egainChat.egainChatParameters),
          domain);
      }
      if ((eGainChatUrl + refererurl).length <= 2000){
          eGainChatUrl += '&referer=' + refererurl;
      }
      var params = 'height=623,width=419,resizable=yes,scrollbars=yes,toolbar=no';
      egainChat.eglvchathandle = window.open(eGainChatUrl, '', params);
        /*Message posted to the child window every second until it sends a message in return. 
         * This is done as we can not be sure when the mssage listener will be set in the child window.*/
      if (window.navigator.userAgent.indexOf('Trident') == -1 && egainChat.postChatAttributes) {
        var messagePostInterval = setInterval(function() {
          var message = egainChat.egainChatParameters;
          egainChat.eglvchathandle.postMessage(message, domain);
        }, 1000);
        window.addEventListener('message', function(event) {
          if (event.data.chatParametersReceived) {
            clearInterval(messagePostInterval);
          }
        }, false);
      }
  };
    /*To be called by client website. All the parameters specified in eGainLiveConfig must be set here.*/

  egainChat.storeChatParameters = function(attributeName, attributeValue) {
    egainChat.egainChatParameters[attributeName] = attributeValue;
  };
    
  egainChat.writeIframeIfRequired = function() {
    if (egainChat.postChatAttributes && window.navigator.userAgent.indexOf(
        'Trident') != -1) {
      var iframe = document.createElement('iframe');
      iframe.src = egainChat.liveServerURL +
        '/web/view/live/customer/storeparams.html';
      iframe.style.display = 'none';
      iframe.name = 'egainChatDomainFrame';
      iframe.id = 'egainChatDomainFrame';
      document.body.appendChild(iframe);
    }
  };
    
  egainChat.writeIframeIfRequired();
  //END SECTION FOR CHAT

  EgainChat.prototype.bindEvents = function() {
    var eGain = eGain;

    this.$el.find('a').on('click', function(event) {
      event.preventDefault();
      if (this.$el.hasClass('egainChat-chat')) {
          this.openHelp();
          $('.egainChat-cobrowse').removeClass('disabled');
      } else if (this.$el.hasClass('egainChat-cobrowse')) {
        eGain.cobrowse.startCobrowse();
      }
    }.bind(this));
  };

  api.onRegister = function(element) {
    new EgainChat(element.$scope);
  };

  Cog.registerComponent({
    name: 'egainChat',
    api: api,
    selector: '.egainChat'
  });

})(Cog.jQuery());
(function($) {
    'use strict';
    
    var api = {
        element: []
    };
    
    function LanguageMech($el) {
        this.$el = $el;
        this.switchLanguage($el);
        this.toggleView();
    }
    
    LanguageMech.prototype.toggleView = function() {
        $('.lang').click(function() {
            if ($('.dropdown').hasClass('hidden')) {
                $('.dropdown').removeClass('hidden');
                $('.dropdown').css('visibility','visible');
            } else {
                $('.dropdown').addClass('hidden');
                $('.dropdown').css('visibility','hidden');
            }
        });
    };
    
    LanguageMech.prototype.switchLanguage = function() {
        var language = $(document).find('meta[name=language]').attr('content');

        $('.languageMechanism select option').each(function() {
            if(language == $(this).val()){
                this.selected = 'selected';
            }
        });
        
        $('.languageMechanism select').change(function () {
            location.href = $(this).find(':selected').data('label');
        });
    };
        
    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.element.push(new LanguageMech($el));
    };

    Cog.registerComponent({
        name: 'languageMechanism',
        api: api,
        selector: '.lang-mechanism-style'
    });
})(Cog.jQuery());
(function($) {
    'use strict';

    var api = {
        element: []
    };

    function PremiumCallback($el) {
        this.$el = $el;
        this.fillOptions();
        this.sendCallbackData();
        this.nowoption();
        this.filltimeoption(false);
    }

    PremiumCallback.prototype.fillOptions = function() {
        //next seven working days
        var select = document.getElementById('date');
        var date = new Date();
        var days = [];
        for (var i = 0; i < 7; i++) {
            if (date.getDay() + 1 == 7) {
                date.setDate(date.getDate() + 1);
                i = i - 1;
            } else if (date.getDay() + 1 == 6) {
                date.setDate(date.getDate() + 1);
                i = i - 1;
            } else if (date.getHours > 17) {
                date.setDate(date.getDate() + 1);
                i = i - 1;
            } else {
                days[i] = (date.getDate() + '/' + (date.getMonth() + 1) + '/' + date.getFullYear());
                var opt = document.createElement('option');
                opt.value = days[i];
                opt.innerHTML = days[i];
                select.insertBefore(opt, select.childNodes[0]);
                date.setDate(date.getDate() + 1);
            }
        }
        document.getElementById('date').selectedIndex = '0';
        $(select).on('change', function() {
            var currentoption = this.value;
            var today = new Date();
            var todaysdate = today.getDate() + '/' + (today.getMonth() + 1) + '/' + today.getFullYear();
            if (currentoption == todaysdate) {
                PremiumCallback.prototype.filltimeoption(true);
            } else {
                PremiumCallback.prototype.filltimeoption(false);
            }
        });
    };

    PremiumCallback.prototype.filltimeoption = function(todayay) {
        var date = new Date();
        var hours = date.getHours();
        var hoursopts = ' ';
        var timeselect = document.getElementById('time');
        $(timeselect).find('option').remove();
        var lowerhour = 9;
        if (lowerhour < hours && todayay) {
            lowerhour = hours;
        }
        for (var i = lowerhour, j = 0; i < 17; i++, j++) {
            hoursopts += '<option value=' + i + '>' + i + ':00' + '</option>';
        }
        $(timeselect).append(hoursopts);
    };



    PremiumCallback.prototype.nowoption = function() {
        $('#date').on('change', function() {
            if (this.value == 'NOW') {
                var opt = document.createElement('option');
                opt.value = 'NA';
                opt.innerHTML = 'NA';
                var timeselect = document.getElementById('time');
                timeselect.insertBefore(opt, timeselect.childNodes[0]);
                $('#time option[value=NA]').prop('selected', true);
                $('#time').prop('disabled', 'disabled');
            } else {
                $('#time').prop('disabled', false);
                $('#time option[value=NA]').remove();
            }
        });
    };

    function inserterrormessage() {
        $('.alert-error').show();
    }

    PremiumCallback.prototype.sendCallbackData = function() {

        $('.postsubmitbutton').click(function() {
            var dateselected = document.getElementById('date');
            var timeselected = document.getElementById('time');
            var name = document.getElementById('name').value;
            var phoneno = document.getElementById('phoneno').value;
            if (phoneno == '' || phoneno == 'required' || name == '' || name == 'required') {
                document.getElementById('name').value = 'required';
                document.getElementById('phoneno').value = 'required';
            } else if (!phoneno.match(/^(?=.*\d)[\d ]+$/)) {
                inserterrormessage();
            } else {
                var callbackdatetime = '';
                if ($('#date').value == 'NOW') {
                    callbackdatetime = 'NOW';
                } else {
                    var callbackValue = document.getElementById('callbackdatetime').value,
                        timeSelected = timeselected.options[timeselected.selectedIndex].value,
                        dateSelected = dateselected.options[dateselected.selectedIndex].value;

                    callbackdatetime = callbackValue = dateSelected + ' ' + timeSelected;
                }
                var serviceurl = 'https://' + window.location.host +
                    '/bin/callbackservice?name=' +
                    document.getElementById('name').value + '&phoneno=' +
                    document.getElementById('phoneno').value +
                    '&callbackdatetime=' + callbackdatetime;
                $.ajax({
                        method: 'GET',
                        url: serviceurl,
                        dataType: 'json'
                    })
                    .done(function(response) {
                        $('.premiumcallback').html(
                            '<div class=\'content paragraphSystem\'>' +
                            '<div class=\'richText section richText-need-help'+
                                ' vertical-spacing component first odd last\'>' +
                            '<div class=\'component-content\'><div class=\'richText-content\'>' +
                            '<h3 style=\'text-align: center;\'>Request sent successfully. Your reference number is ' +
                            '</h3>' +
                            '<h6 style=\'text-align: center;\'>' +
                            response.responseTypeObject.uniqueRefNo +
                            '<br>' +
                            '</h6>' +
                            '</div></div></div></div>');
                    })
                    .fail(function(msg) {
                        $('.premiumcallback').html = msg;
                    });
            }
        });
    };

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        api.element.push(new PremiumCallback($el));
    };

    Cog.registerComponent({
        name: 'premiumcallback',
        api: api,
        selector: '.premiumcallback'
    });
})(Cog.jQuery());
/**
 * Tooltip
 */

(function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.rteTooltip = [];

    function RteTooltip($el) {
        $($el).wrap('<span class=\'tooltip-icon\'></span>');
        $($el).closest('.tooltip-icon').on('click', function() {
            if($(this).hasClass('active')) {
                $(this).removeClass('active');
            } else {
                $(this).addClass('active');
            }
        });
    }

    api.onRegister = function (scope) {
        var $tooltips = scope.$scope;

        _.forEach($tooltips, function (tooltip) {
            var $tooltip = $(tooltip);
            api.rteTooltip.push(new RteTooltip($tooltip));
        });
    };

    Cog.registerComponent({
        name: 'richTextTooltip',
        api: api,
        selector: '.tooltip-selection'
    });
}(Cog.jQuery()));
/**
 * DropdownSearch
 */

(function() {
	'use strict';

	var api = {
	    element: [],
	    dataFeeds: getOptions(),
	    selectedOptionTicker: ''
	};

    function DropdownSearch(element, index) {
        createOptions(index);
        bindFilterSearch(element, index);
    }

    function bindFilterSearch(elem, index) {
        var input = document.getElementsByClassName('dropdownSearch__input')[index],
            btn = document.getElementsByClassName('dropdownSearch__button')[index];

        input.addEventListener('keyup', function (){
            filterShares(index);
        });

        input.addEventListener('focusout', function () {
            setTimeout(function () {
                showDrawer(false, index);
            }, 200);
        });

        input.addEventListener('focusin', function() {
            showDrawer(true, index);
        });

        btn.addEventListener('click', function() {
            setTickerInURl();
        });
    }

    function filterShares(index) {
        var input = document.getElementsByClassName('dropdownSearch__input')[index],
            filter = input.value.toUpperCase(),
            options = document.getElementsByClassName('dropdownSearch__option'),
            result;

        _.forEach(options, function(option) {
            result = option.textContent || option.innerText;

            if (result.toUpperCase().indexOf(filter) > -1) {
                option.style.display = 'block';
                showDrawer(true, index);
            } else {
                option.style.display = 'none';
            }
        });
    }

    function showDrawer(visible, index) {
        var drawer = document.getElementsByClassName('dropdownSearch__drawer-container')[index];
        var inputWrapper = document.getElementsByClassName('dropdownSearch__input-wrapper')[index];

        if (visible) {
            if (!drawer.classList.contains('dropdownSearch__drawer-container--expanded')) {
                drawer.classList.add('dropdownSearch__drawer-container--expanded');
            }
            if (!inputWrapper.classList.contains('dropdownSearch__input-wrapper--expanded')) {
                inputWrapper.classList.add('dropdownSearch__input-wrapper--expanded');
            }
        } else {
            if (!visible) {
                if (drawer.classList.contains('dropdownSearch__drawer-container--expanded')) {
                    drawer.classList.remove('dropdownSearch__drawer-container--expanded');
                }
                if (inputWrapper.classList.contains('dropdownSearch__input-wrapper--expanded')) {
                    inputWrapper.classList.remove('dropdownSearch__input-wrapper--expanded');
                }
            }
        }
    }

    function getOptions() {
        if(document.getElementsByClassName('dataFeeds shareInformation').length > 0) {
            return JSON.parse(document.getElementsByClassName('dataFeeds shareInformation')[0]
																.getAttribute('shareInformation'));
        }
        return;
    }

    function createOptions(index) {
        if (api.dataFeeds) {
            for(var i = 0; i <= Object.keys(api.dataFeeds).length -1; i++) {
                var feed = api.dataFeeds[Object.keys(api.dataFeeds)[i]],
                    ticker = feed.ticker,
                    companyName = feed.companyName,
                    optionsWrapper = document.getElementsByClassName('dropdownSearch__drawer-wrapper')[index],
                    optionElem = document.createElement('li');

                optionElem.innerHTML = ticker + ' - ' + companyName;
                optionElem.classList.add('dropdownSearch__option');
                bindEventForOptions(optionElem, ticker, index);
                optionsWrapper.appendChild(optionElem);
            }
        }
    }

    function bindEventForOptions(optionElem, ticker, index) {
        optionElem.addEventListener('click', function() {
            selectOption(ticker, index);
        });
    }

    function selectOption(ticker, index) {
        api.selectedOptionTicker = ticker;
        setInputValue(ticker, index);
    }

    function setInputValue(ticker, index) {
        var option = api.dataFeeds[ticker],
            input = document.getElementsByClassName('dropdownSearch__input')[index],
            inputValue = option.ticker + ' - ' + option.companyName;

        input.value = '';
        input.value = inputValue;
    }

    function setTickerInURl() {
        var ticker = api.selectedOptionTicker;
        window.tickerObj.ticker = ticker;
        // send ticker to calculator
    }

	api.onRegister = function(scope) {
        var dropdownSearchElements = scope.$scope;

        _.forEach(dropdownSearchElements, function (dropdownSearchElement, index) {
            api.element.push(new DropdownSearch(dropdownSearchElement, index));
        });
	};

	Cog.registerComponent({
		name: 'dropdownSearch',
		api: api,
		selector: '.dropdownSearch__container'
	});
})(Cog.jQuery());

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {
        stockCarousel: []
    };

    function StockbrokerCarousel($el) {
        this.dataFeeds = $el.find('.dataFeeds');
        this.tickGroups = $el.find('.tick-group');
        this.addElements($el);
        this.bindEvents($el); 
    }

	function tickGroupEvents($el, element) {
        element.append('<div class=\'get-quote-button\' data-feed-tick=\'' +
            element.find('.tick-ticker').text() + '\'>Get a quote</div>');
        var tickerLast = element.find('.tick-last').text() / 100,
            tickerClose = element.find('.tick-close').text(),
            tickerPrice = element.find('.tick-last').text(),
            tickerChange = tickerClose - tickerPrice;
        if(tickerChange < 0) {
			tickerChange = tickerChange * -1;
            element.append('<div class=\'tick-price negative\'>R' + tickerLast.toFixed(2) + '</div>');
        } else {
        	element.append('<div class=\'tick-price positive\'>R' + tickerLast.toFixed(2) + '</div>');
        }
    }

    StockbrokerCarousel.prototype.addElements = function($el) {
        $el.append('<span class=\'prev-arrow\'></span><span class=\'next-arrow\'></span>');

        this.tickGroups.each(function () {
            tickGroupEvents($el, $(this));
        });
    };

    StockbrokerCarousel.prototype.bindEvents = function($el) {
        var $innerFeed  = $(this.dataFeeds),
            outerWidth  = $el.width(),
            itemWidth   = this.tickGroups.outerWidth(true),
            innerWidth  = itemWidth * this.tickGroups.length,
            leftWidth   = outerWidth - innerWidth;

        $el.find('.prev-arrow').on('click', function() {
            if($innerFeed.css('left').replace(/[^-\d\.]/g, '') < (itemWidth * -1)) {
            	$innerFeed.css('left', '+=' + itemWidth);
        	} else {
                $innerFeed.css('left', '0');
            }
        });

        $el.find('.next-arrow').on('click', function() {
            if($innerFeed.css('left').replace(/[^-\d\.]/g, '') > leftWidth) {
            	$innerFeed.css('left', '-=' + itemWidth);
        	}
        });

        $el.find('.tick-group').on('click', function() {
            var ticker = $(this).find('.get-quote-button').attr('data-feed-tick');
            window.tickerObj.ticker = ticker;
            var scrollTo =  $('.reference-trade-cost-estimator').offset().top - 70;
            $('body, html').animate({scrollTop: scrollTo}, 500);
        });
    };

    api.onRegister = function (scope) {
        var $stockbrokerCarousels = scope.$scope;
        _.forEach($stockbrokerCarousels, function (stockbrokerCarousel) {
            var $stockbrokerCarousel = $(stockbrokerCarousel);
            api.stockCarousel.push(new StockbrokerCarousel($stockbrokerCarousel));
        });
    };

    Cog.registerComponent({
        name: 'stockCarousel',
        api: api,
        selector: '.stockbrokerShareInformation'
    });
}(Cog.jQuery()));

/**
 * HowToNavigation
 */

(function() {
    'use strict';

    var api = {
        howToNavigation: []
    };

    function HowToNavigation($el) {
        this.$el = $el;
        this.buildMobileDropdown();
        this.attachEvents();
    }

    HowToNavigation.prototype.buildMobileDropdown = function() {
        var navigationParent = this.$el.find('.cmp-navigation'),
            navigationItems = this.$el.find('.cmp-navigation__item--level-0');

        navigationParent.append('<div class=\'topics-heading\'>Help Topics</div>' +
                                '<ul class=\'cmp-navigation__mobile\'>' +
                                    '<div class=\'mobile-selector\'>Select help topic</div>' +
                                '</ul>');

        $(navigationItems).each(function() {
            $(this).clone().appendTo('.cmp-navigation__mobile');
        });
    };

    HowToNavigation.prototype.attachEvents = function() {
        $(this.$el).find('.mobile-selector').on('click', function() {
            $(this).closest('.cmp-navigation__mobile').toggleClass('is-open');
        });
    };

    api.onRegister = function(scope) {
        var $el = scope.$scope;
        api.howToNavigation.push(new HowToNavigation($el));
    };

    Cog.registerComponent({
        name: 'howToNavigation',
        api: api,
        selector: '.navigation-side-nav',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }]
    });
})(Cog.jQuery());

(function ($) {
    'use strict';

    /**
     * Public API
     */

    var api = {},
        status,
        $productCardInfoEl,
        $buttons,
        $buttonsCopy,
        $heroWrapper;

    api.productCardInfo = [];

    function ProductCardInfo($el) {
        this.$window = $(window);
        this.$body = $('body');
        this.$headerSection = $('#header');
        this.$headerSnippet = $('.header-snippet');

        $heroWrapper = $('#header .hero-wrapper');

        $productCardInfoEl = $el;

        $buttons = $productCardInfoEl.find('.product-card-info-buttons a');
                                                
        this.handleContentSpacing();
        this.handleButtons($buttons);

        if (!status.isAuthor() && $el.length) {
            handleAccordingToDevice();
            this.attachEvents();
        } else {
            return;
        }

    }

    ProductCardInfo.prototype.handleContentSpacing = function () {
        if( this.$body.find('.multiStackedSubnavigation.component').length == 0){
            this.$body.find('#content').css('padding-top', '0'); // Clear multistack spacing
        }
    };

    ProductCardInfo.prototype.handleButtons = function ($buttons) {
        colorButtons($buttons);
        $buttonsCopy = $productCardInfoEl.find('.product-card-info-buttons')
                            .clone().addClass('mobile-buttons-copy');
        setButtonsToWidest( getWidestButtonWidth($buttons) );
    };

    ProductCardInfo.prototype.attachEvents = function() {
        
        let mobileCriticalPoint = $heroWrapper.height() + $productCardInfoEl.height(),
            stickyScrollPoint = this.$headerSection.outerHeight() - this.$headerSnippet.outerHeight();

        this.$window.on('scroll', function() {

            if( $(window).width() < 481 ) {

                if(this.window.scrollY > mobileCriticalPoint) { 
                    $buttonsCopy.addClass('show-button-copy');
                    $buttonsCopy.css('opacity', 1);
                } else {
                    $buttonsCopy.css('opacity', 0);
                    $buttonsCopy.removeClass('show-button-copy');
                }

            } else { 
                if(this.window.scrollY > stickyScrollPoint) {
                    if( $('.cookiePolicy.collapsed').length > 0 ){
                        $productCardInfoEl.removeClass('with-cookie');
                        $productCardInfoEl.addClass('no-cookie');
                    } else {
                        $productCardInfoEl.removeClass('no-cookie');
                        $productCardInfoEl.addClass('with-cookie');
                    }
                    $productCardInfoEl.addClass('product-card-info-sticky');
                } else {
                    $productCardInfoEl.removeClass('product-card-info-sticky');
                }
            }

        });

        this.$window.on('orientationchange resize', function() {
            handleAccordingToDevice();
        });

    };

    function handleAccordingToDevice() {     
                
        if( $(window).width() < 481 ) {
            $heroWrapper.addClass('hide-hero-image');
            $('.footer-snippet').addClass('footer-spacing');
            
            $('.footer-snippet').after($buttonsCopy);

            $productCardInfoEl.removeClass('product-card-info-sticky');
            $heroWrapper.addClass('hide-hero-image');

            // recalculate width
            $buttons.css('width', '');
            setButtonsToWidest( getWidestButtonWidth($buttons) );
        } else {
            $buttonsCopy.removeClass('show-button-copy');

            // recalculate width
            $buttons.css('width', '');
            setButtonsToWidest( getWidestButtonWidth($buttons) );
        }
    }

    function getWidestButtonWidth(buttons){
        let btnMaxWidth,
            btnWidths = [];

        _.forEach(buttons, function (button) {
            let $button = $(button);
            btnWidths.push($button.width());
        });

        btnWidths.sort(function(a, b){ return b-a; }); // Sort to place widest item first 

        btnMaxWidth = btnWidths[0];

        return btnMaxWidth;
        
    }

    function colorButtons($buttons){
        $buttons.last().addClass('btn-action-green btn-action-primary-solid');
    }

    function setButtonsToWidest(btnMaxWidth){

        _.forEach($buttons, function (button) {
            let $button = $(button);
            $button.width(btnMaxWidth);
        });
        
    }

    api.onRegister = function (scope) {
        let $productCardInfoList = scope.$scope;
        status = this.external.status;

        _.forEach($productCardInfoList, function (productCardInfo) {
            let $productCardInfo = $(productCardInfo);
            api.productCardInfo.push(new ProductCardInfo($productCardInfo));
        });
    };

    Cog.registerComponent({
        name: 'productCardInfo',
        api: api,
        selector: '.productCardInfo.component',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));

/* jshint maxlen: 500 */

/**
 * FindUsDashboard
 */

/*global google */

(function ($) {
    'use strict';

    var api = {
        smeHub: [],
        smeLocations: []
    };

    function searchGeocode(address) {
        var geocoder = new google.maps.Geocoder();

        geocoder.geocode({'address': address}, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                Cog.fireEvent('smeHub', 'placeChanged', {place: results[0]});
            }
        });
    }

    function getCountrySpecificUrl(jsonUrl) {
        return jsonUrl.replace('[COUNTRY]', $('meta[name=country]').attr('content'));
    }

    function getCountryApiKey() {
        for(var a=document.getElementsByTagName('meta'),b='',c=0;c<a.length;c++){
            if('gm-key'===a[c].getAttribute('name')&&(b=a[c].getAttribute('content'))){
            return b;}
        }
    }

    function SmeHub($el) {
        if (!google) {
            return;
        }

        this.$searchInput = $el.find('.place-input');
        this.$searchSubmit = $el.find('.search-submit');
        this.autocomplete = null;
        this.attachEvents();
    }

    SmeHub.prototype.attachEvents = function () {
        var countryCode = 'ZA';

        this.$searchInput.on('keyup', function () {
            var val = this.$searchInput.val();

            if (val.length >= 3) {
                this.autocomplete = new google.maps.places.Autocomplete(this.$searchInput[0], {componentRestrictions: {country: countryCode}});
                google.maps.event.addListener(this.autocomplete, 'place_changed', function () {
                    searchGeocode($('#search-location').val() + ',' + countryCode);
                });
            } else {
                this.destroyAutocomplete();
            }

            if (val.length > 0) {
                this.$searchSubmit.addClass('is-active');
            } else {
                this.$searchSubmit.removeClass('is-active');
            }
        }.bind(this));

        this.$searchSubmit.on('click', function (e) {
            e.preventDefault();

            if (this.$searchSubmit.hasClass('is-active')) {
                searchGeocode(this.$searchInput.val() + ',' + countryCode);
            }

        }.bind(this));
    };

    SmeHub.prototype.destroyAutocomplete = function () {
        if (this.autocomplete) {
            this.autocomplete = null;
        }
    };

    function SmeLocations(scope) {
        var $accordionListTemplate = $('#accordionContactTemplate');

        this.defaultOptions = {
            height: 250,
            heightmobile: 300,
            zoom: 20,
            latitude: 51.500134,
            longitude: -0.12623,
            mapType: 'ROADMAP',
            markers: [],
            apikey: '',
            scrollwheel: false
        };

        this.jsonUrl = '/etc/barclays/contact-info/south-africa/_jcr_content/sme-details.json';
        this.$mapContainer = scope.$scope;
        this.$radius = parseFloat($('#radius_selection').val());
        this.activeMarker = null;
        this.contactListTemplate = _.template($accordionListTemplate.html());
        this.$contactListContainer = $accordionListTemplate.parent();
        this.visibleMarkersCurrent = [];
        this.dataElement = document.getElementsByClassName('sme-hub')[0];
        this.currentRenderedContactList = '';
        this.circle = null;
        this.setInitValues();
        this.loadMarkers(); 
        this.attachExternalEvents();
    }

    SmeLocations.prototype.loadMarkers = function () {
        this.mapOptions.markers = [];
        $.getJSON(getCountrySpecificUrl(this.jsonUrl), function (data) {
            for (var i = 0; i < data.length; i++) {
                this.mapOptions.markers[i] = {
                    id: data[i].id,
                    title: data[i].title,
                    latitude: data[i].latitude,
                    longitude: data[i].longitude,
                    address: data[i].address,
                    telephone: data[i].telephone,
                    weekdayHours: data[i].weekdayHours,
                    saturdayHours: data[i].saturdayHours,
                    sundayHours: data[i].sundayHours,
                    publicHolidayHours: data[i].publicHolidayHours,
                    description: data[i].description,
                    websiteUrl: data[i].websiteUrl,
                    facebookUrl: data[i].facebookUrl,
                    instagramUrl: data[i].instagramUrl,
                    category: data[i].category,
                    lat: window.parseFloat(data[i].latitude),
                    lng: window.parseFloat(data[i].longitude),
                    apikey: getCountryApiKey()
                };
            }
            this.attachEvents();

        }.bind(this));
    };

    SmeLocations.prototype.visibleMarkers = function () {
        var bounds = this.circle.getBounds(),
            visible = [];

        for (var i = 0; i < this.mapOptions.markers.length; i++) {
            var markerposition = new google.maps.LatLng(this.mapOptions.markers[i].lat, this.mapOptions.markers[i].lng);
            if (bounds.contains(this.mapOptions.markers[i])) {
                this.mapOptions.markers[i].distance = google.maps.geometry.spherical.computeDistanceBetween(
                    markerposition, this.circle.getCenter());                    
                visible.push(this.mapOptions.markers[i]);
            }
        }

        visible.sort(function(a, b){
            return a.distance - b.distance;
        });
        return visible;
    };

    SmeLocations.prototype.updateVisibleContactList = function () {
        var newVisibleMarkers = this.visibleMarkers(),
            newRenderedContactList;
        if (newVisibleMarkers.length >= 1) {
            if (!_.isEqual(newVisibleMarkers, this.visibleMarkersCurrent)) {
                this.visibleMarkersCurrent = newVisibleMarkers;
                newRenderedContactList = this.contactListTemplate({'markers': this.visibleMarkersCurrent});
            }
        } else if(newVisibleMarkers.length < 1) {
            this.visibleMarkersCurrent = [''][''];
            newRenderedContactList = this.contactListTemplate({'markers': this.visibleMarkersCurrent});
        }

        if (newRenderedContactList !== this.currentRenderedContactList) {
            this.currentRenderedContactList = newRenderedContactList;
            this.$contactListContainer.html(newRenderedContactList);
        }
    };

    SmeLocations.prototype.attachEvents = function () {
        Cog.addListener('smeHub', 'placeChanged', function (e) {
            this.circle.setCenter(e.eventData.place.geometry.location);
            this.updateVisibleContactList();
        }.bind(this));

        var countryCode = 'ZA';
        $('#radius_selection').on('change', function (e) {
            e.preventDefault();
            var val = $('#search-location').val();
            this.$radius = parseFloat(e.target.value);
            this.circle.setRadius(this.$radius);
        
            if(val){
                searchGeocode(val + ',' + countryCode);
            }
        }.bind(this));
    };

    SmeLocations.prototype.attachExternalEvents = function () {
        $('.box-sme-functionality').on('click', '.tabs-nav-item a', function(e) {
            var currentEvent = this;
            e.preventDefault();
            activateTab(currentEvent);
        });

        $('.box-sme-functionality').on('click', '.accordion-head', function(e) {
            var currentEvent = this;
            e.preventDefault();
            activateAccordion(currentEvent);
        });
    };

    function activateTab(event) {
        var container = $(event).parent('.tabs-nav'),
            navItems = $(event).parent('.tabs-nav-item'),
            currentItemID = $(event).attr('href').split('#')[1];

        navItems.addClass('is-active');
        navItems.siblings('.is-active').removeClass('is-active');
        container.siblings('.tabs-content').addClass('is-hidden');
        $('#' + currentItemID).removeClass('is-hidden').siblings('.tabs-content').addClass('is-hidden');
    }

    function activateAccordion(event) {
        $(event).parent('.accordion-slide').toggleClass('is-active is-animated');
    }

    SmeLocations.prototype.setInitValues = function () {
        var centerPosition = new google.maps.LatLng(this.defaultOptions.latitude, this.defaultOptions.longitude);

        this.mapOptions = {
            zoom: this.defaultOptions.zoom,
            center: centerPosition,
            mapTypeId: google.maps.MapTypeId[this.defaultOptions.mapType],
            scrollwheel: false
        };

        this.circle = new google.maps.Circle({
            center: centerPosition,
            radius: parseFloat(this.$radius)
        });
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;
        api.smeHub.push(new SmeHub($el.find('.search-main')));
        api.smeLocations.push(new SmeLocations(scope));
    };

    Cog.registerComponent({
        name: 'smeHub',
        api: api,
        selector: '.sme-hub' 
    });
})(Cog.jQuery());
/**
 *  Absa App Mobile Adoption Bar
 *
 */

(function ($) {
    'use strict';

    /**
     *Public API
     *
     */

    var api = {},
        status;

    api.appBar = [];

    function AppBar($el) {
        var mobileOs = getMobileOperatingSystem(),
            visitAmountLimit = $($el).find('.outer-container').attr('data-visible-limit'),
            cooloffPeriod = $($el).find('.outer-container').attr('data-cooloff-period'),
            visitAmountCookie = getCookie('appAdoptionSeen');
        const appLinks = {
            ios: $($el).find('.adoption-button').attr('data-ios-link'),
            harmony: $($el).find('.adoption-button').attr('data-harmony-link'),
            android: $($el).find('.adoption-button').attr('data-android-link'),
            deepLink: $($el).find('.adoption-button').attr('data-deep-link')
        };

        if (status.isMobile() && visitAmountCookie < visitAmountLimit) {
            if (mobileOs == 'android' || mobileOs == 'ios' || mobileOs == 'harmony') {
                $($el).css('display', 'block');
                toggleBarSpace('add');
            }
        }

        $($el).find('.adoption-close').on('click', function () {
            hideBar($el, visitAmountCookie, cooloffPeriod);
        });

        $($el).find('.adoption-button').on('click', function () {
            hideBar($el, visitAmountCookie, cooloffPeriod);
            openDownloadApp(appLinks[mobileOs], appLinks.deepLink);
        });

        $(window).resize(function() {
            if(!status.isMobile()) {
                hideBar($el, visitAmountCookie - 1, cooloffPeriod);
            }
        });
    }

    function openDownloadApp(appLink, deepLink) {
        var now = new Date().valueOf();
        var app = {
            launchApp: function () {
                window.location.replace(deepLink);
                this.timer = setTimeout(this.openWebAppStore, 800);
            },
            openWebAppStore: function () {
                if (new Date().valueOf() - now > 1000) {
                    return;
                }
                window.location = appLink;
            }
        };
        app.launchApp();
    }


    function hideBar($el, visitAmountCookie, cooloffPeriod) {
        toggleBarSpace('remove');
        $($el).css('display', 'none');
        visitAmountCookie++;
        setCookie('appAdoptionSeen', visitAmountCookie, cooloffPeriod);
    }

    function toggleBarSpace(action) {
        if (action == 'add') {
            $('body').addClass('adoption-space');
        } else {
            $('body').removeClass('adoption-space');
        }
    }

    function getMobileOperatingSystem() {
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        // Test Huawei before android otherwise we will never match it
        if (/huawei/i.test(userAgent)) {
            return 'harmony';
        }
        if (/android/i.test(userAgent)) {
            return 'android';
        }

        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            return 'ios';
        }

        return 'na';
    }

    function getCookie(cname) {
        var name = cname + '=';
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return '';
    }

    function setCookie(cname, cvalue, exdays) {
        var d = new Date();
        d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
        var expires = 'expires=' + d.toUTCString();
        document.cookie = cname + '=' + cvalue + ';' + expires + ';path=/';
    }

    api.onRegister = function (scope) {
        status = this.external.status;
        api.appBar.push(new AppBar(scope.$scope));
    };

    Cog.registerComponent({
        name: 'appBar',
        api: api,
        selector: '.appAdoptionBar',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }
        ]
    });
}(Cog.jQuery()));

/**
 * TagSearch
 */

 (function ($) {
    'use strict';

    /**
     * Public API
     *
     */

    var api = {};

    api.tagSearchElement = [];

    function TagSearch($el) {
        this.$el = $el;
        this.$tags = this.$el.find('[class^=product-tag]');
        this.$tagsContainer = $(this.$tags).closest('.tags-container');
        this.bindUIEvents();
    }

    TagSearch.prototype.bindUIEvents = function () {
        var elScrollWidth = $(this.$tagsContainer)[0].scrollWidth,
            elWidth = $(this.$tagsContainer).innerWidth(),
            mainElement = $(this.$el);

        this.$tags.on('click', function (e) {
            $(e.target).toggleClass('active');
            filterProducts();
        });

        if (elScrollWidth > elWidth) {
            $(mainElement).addClass('right-arrow');
        }

        $(this.$tagsContainer).on('scroll', function(e) {
            var tagsContainer = $(e.target),
                mainContainer = $(mainElement),
                scrollNr = $(tagsContainer).scrollLeft(),
                maxScroll = elScrollWidth - elWidth;

            if (scrollNr > 5) {
                $(mainContainer).addClass('left-arrow');
            } else {
                $(mainContainer).removeClass('left-arrow');
            }
            
            if(scrollNr > parseInt(maxScroll - 5)) {
                $(mainContainer).removeClass('right-arrow');
            } else {
                $(mainContainer).addClass('right-arrow');
            }
        });
    };

    function filterProducts() {
        var productCards = $('.product-card-redesign'),
            onlyProductCards = $('.product-card-redesign.productCard');
        productCards.addClass('hide-card').removeClass('filtered');
        $(productCards).closest('.content').addClass('display-flex-wrap');

        var filerValues = getActiveTagValues();

        if(filerValues.length > 0) {
            for (var index = 0; index < onlyProductCards.length; index++) {
                var cardTags = $(onlyProductCards[index]).find('.outer-container').data('tags')
                    .toString().toLowerCase().replace(/\s/g, '');
    
                for (var innerIndex = 0; innerIndex < filerValues.length; innerIndex++) {
                    if(cardTags.includes(filerValues[innerIndex])) {
                        $(onlyProductCards[index]).removeClass('hide-card').addClass('filtered');
                    }
                }
            }
        } else {
            productCards.removeClass('hide-card').addClass('filtered');
        }

        moveAdvertCards();
    }

    function moveAdvertCards() {
        var advertCards = $('.advert-card-redesign.product-card-redesign'),
            cardsContainer = $(advertCards)[0].closest('.content');
            
        for (var index = 0; index < advertCards.length; index++) {
            var tempCard = advertCards[index];
            cardsContainer.appendChild(tempCard);
        }

        advertCards.removeClass('hide-card left-card right-card').addClass('filtered');
        var showncards = $('.filtered');
        
        for (var i = 0; i < showncards.length; i++) {
            if (i % 2 == 0) {
                $(showncards[i]).addClass('left-card');
            } else {
                $(showncards[i]).addClass('right-card');
            }
        }
    }

    function getActiveTagValues() {
        var activeTags = $('.tags-container>.active');
        var activeTagValues = [];

        for (var index = 0; index < activeTags.length; index++) {
            var element = activeTags[index],
                trimmedTagValue = $(element).data('value').toString().toLowerCase().replace(/\s/g, '');
            activeTagValues.push(trimmedTagValue);
        }
        
        return activeTagValues;
    }

    api.onRegister = function (scope) {
        var $tooltip = scope.$scope;
        api.tagSearchElement.push(new TagSearch($tooltip));
    };

    Cog.registerComponent({
        name: 'tagSearchElement',
        api: api,
        selector: '.tagSearch'
    });
}(Cog.jQuery()));
/* jshint maxlen: 500 */
/* jshint sub:true */
/* global Hammer */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            RoboAdvisor: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * RoboAdvisor class
     * @param $el navigation wrapper
     * @constructor
     */
    function RoboAdvisor($el) {
        this.$el = $el;

        this.apiUrl = 'https://smartrandengine.com/api/SRengine/RecommendProduct';
        //this.apiUrl = 'https://esb.api.prd.absa.co.za:1001/enterprise/prod/smartrand/v1.0/api/SRengine/RecommendProduct';
        //this.dataPowerUrl = '';
        //this.continueUrl = 'http://v007webffc00b/Robo/Process/Details?ClientReferenceNumber=';
        this.continueUrl = 'https://www.absainvestments.co.za/virtualinvestor/Process/Details?ClientReferenceNumber=';

        this.activeQuestion = null;
        this.activeSection = 0;
        this.activeStep = 0;

        this.customerName = '';
        this.customerEmail = '';

        // The API payload gets reset under certain circumstances (EG. if advisor restarts after API error)
        // This default configuration will be used to populate the payload after it gets reset.
         this.defaultPayload = {
             /*'Partner': 'ABSA',
             'Credentials': 'HelloABSA',
             'UID': 0*/
             'Partner': 'ABSAlive',
             'Credentials': 'WeareA85A',
             'UID': 0
        };

        /* this.defaultPayload = {
            'Partner': 'Test',
            'Credentials': 'Test9a55',
            'UID': this.UID
        };*/

        this.apiPayload = this.defaultPayload;

        // This is necessary because the API only accepts questions if they are ordered a certain way.
        this.apiOrdering = [
            'Partner',
            'Credentials',
            'UID',
            'Q1',
            'Q2',
            'Q3',
            'Q4',
            'Q5',
            'Q6',
            'Q7',
            'Q8',
            'Q9',
            'Q10',
            'Q11',
            'Q12',
            'Experience',
            'Knowledge',
            'Capacity',
            'Horizon',
            'Investment'
        ];

        this.$elems = {
            inputs: {
                userName: $el.find('[data-hook="input-name"]'),
                email: $el.find('[data-hook="input-email"]'),
                xp: $el.find('[data-hook="input-xp"]'),
                know: $el.find('[data-hook="input-know"]'),
                existing: $el.find('[data-hook="input-existing"]'),
                guide: $el.find('[data-hook="input-guide"]'),
                terms: $el.find('[data-hook="input-terms"]'),
                feedback: $el.find('[data-hook="form-feedback"]')

            },
            stepBar: {
                elem: $el.find('[data-hook="step-bar"]'),
                items: $el.find('[data-hook="step-bar-item"]')
            },
            roboWrapper: $el.find('[data-hook="robo-wrapper"]'),
            sections: $el.find('[data-hook="robo-step"]'),
            questions: {
                container: $el.find('[data-hook="robo-step"][data-id="3"]'),
                nextButton: $el.find('[data-hook="question-next"]'),
                prevButton: $el.find('[data-hook="question-prev"]'),
                loader: $el.find('[data-hook="robo-loading"]'),
                error: $el.find('[data-hook="robo-error"]'),
                errorMsg: $el.find('[data-hook="robo-errorMsg"]'),
                restart: $el.find('[data-hook="robo-restart"]'),
                progress: $el.find('[data-hook="robo-progress"]')
            },
            summary: {
                container: $el.find('[data-hook="robo-step"][data-id="4"]'),
                capacity: $el.find('[data-hook="summary-risk-capacity"]'),
                score: $el.find('[data-hook="summary-risk-score"]'),
                group: $el.find('[data-hook="summary-risk-group"]'),
                horizon: $el.find('[data-hook="summary-time-horizon"]'),
                experience: $el.find('[data-hook="summary-experience"]'),
                productName: $el.find('[data-hook="summary-product-name"]'),
                productInfo: $el.find('[data-hook="summary-product-info"]'),
                riskProfile: $el.find('[data-hook="summary-risk-profile"]'),
                adviceRecord: $el.find('[data-hook="summary-advice-record"]'),
                factSheet: $el.find('[data-hook="summary-fact-sheet"]'),
                accept: $el.find('[data-hook="summary-accept"]'),
                decline: $el.find('[data-hook="summary-decline"]'),
                continue: $el.find('[data-hook="summary-continue"]'),
                restart: $el.find('[data-hook="summary-restart"]'),
                scale: $el.find('[data-hook="summary-scale"]'),
                contact: $el.find('[data-hook="summary-contact"]')
            },
            infoPopupToggler: $el.find('[data-hook="info-popup-open"]')
            /*calculator: {
                elem: $el.find('[data-hook="robo-calculator"]'),
                button: $el.find('[data-hook="robo-toggle-calculator"]')
            }*/
        };

        this.$feedback = {
            knowledge: {
                1: 'I have no/very little knowledge about investing',
                2: 'I have basic knowledge about investing',
                3: 'I am quite knowledgeable about investing',
                4: 'I am very knowledgeable about investing'
            },
            experience: {
                1: 'None/ very little',
                2: 'I am a reasonably experienced investor',
                3: 'I am a very experienced investor'
            }
        };

        this.hammertime = new Hammer(this.$elems.questions.container[0]);

        this.questionArray = [];
        this.init();
    }

    RoboAdvisor.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.getDomNodes();
            this.bindUIEvents();
            this.updateProgressBar();
            this.resetQuestions();
            history.pushState({}, 'home', '');
        }
    };

    RoboAdvisor.prototype.getDomNodes = function () {
        var that = this;

        var questionElems = this.$elems.questions.container.find('[data-hook="robo-question"]');

        questionElems.each(function () {
            var question = new Question($(this));
            that.questionArray.push(question);
        });

        this.activeQuestion = this.questionArray[questionElems.first().data('id')];
    };

    RoboAdvisor.prototype.bindUIEvents = function () {
        var that = this;

        // Reset the app if a user clicks back button
        $(window).on('popstate', function () {
            this.resetApp();
        }.bind(this));

        this.$elems.inputs.userName.on('change', function () {
            that.customerName = $(this).val();
            $('[data-hook="customer-name"]').html(that.customerName);
        });

       /* this.$elems.calculator.button.on('click', function () {
            this.toggleCalculator(true);
        }.bind(this));*/

        this.$elems.questions.nextButton.on('click', function () {
            this.toggleQuestion(this.activeQuestion.id + 1);
        }.bind(this));

        this.$elems.questions.prevButton.on('click', function () {
            this.toggleQuestion(this.activeQuestion.id - 1);
        }.bind(this));

        this.$elems.questions.restart.on('click', function () {
            this.resetApp();
        }.bind(this));

        this.$elems.summary.restart.on('click', function () {
            this.resetApp();
        }.bind(this));

        this.$elems.summary.accept.on('click', function () {
            this.$elems.summary.continue.removeClass('is-inactive');
            this.$elems.summary.contact.removeClass('is-active');
        }.bind(this));

        this.$elems.summary.continue.on('click', function (){
            var continueURL = this.$elems.summary.continue.attr('href');
            dataLayer.siteEvents = 'Journey | End | Continue Clicked: '+continueURL;
            _satellite.track('genericUserInteraction');
            //_satellite.test(dataLayer.siteEvents);
        }.bind(this));

        this.$elems.summary.decline.on('click', function () {
            this.$elems.summary.continue.addClass('is-inactive');
            this.$elems.summary.contact.addClass('is-active');
        }.bind(this));

        this.hammertime.on('swipeleft', function () {
            this.toggleQuestion(this.activeQuestion.id + 1);
        }.bind(this));

        this.hammertime.on('swiperight', function () {
            this.toggleQuestion(this.activeQuestion.id - 1);
        }.bind(this));

        this.$elems.infoPopupToggler.on('click', this.openInfoPopup.bind(this));

        this.$elems.sections.find('[data-hook="robo-continue"]').on('click', function (evt) {
            var $this = $(evt.target);
            var id = $this.data('validate');
            var $parent = $('[data-hook="robo-step"][data-id="' + id + '"]');

           if (id) {
                if (this.validateStep(id)) {

                      if (id == 2) {
                        this.$elems.questions.loader.addClass('is-active');
                        this.customerName = encodeURIComponent(that.customerName.toLowerCase());
                        this.customerEmail = this.$elems.inputs.email.val().toLowerCase();

                        // API call with toggle section callback
                          this.toggleSection(this.activeSection + 1);

                        var UID_url = 'https://' + window.location.host + '/bin/virtualAdvisor?name=' + this.customerName+'&email=' + this.customerEmail;
                        //var UID_url = 'https://absa-sit.devops.web.za/bin/virtualAdvisor?name=' + this.customerName + '&email=' +this.customerEmail;
                        //console.log('Calling this URL: '+UID_url);

                        $.ajax({
                            method: 'GET',
                            url: UID_url
                        })
                        .done(function (response) {

                                  if(response.statuscode === 200){
                                      this.defaultPayload.UID = response.reference;
                                      this.$elems.questions.loader.removeClass('is-active');

                                      dataLayer.siteEvents = 'API - DataPower | Success | Server code: '+response.statuscode;
                                  } else {
                                      this.$elems.questions.loader.removeClass('is-active');
                                      this.$elems.questions.error.addClass('is-active');

                                      dataLayer.siteEvents = 'API - DataPower | Fail | Server error code: '+JSON.stringify(response);
                                  }

                                  _satellite.track('genericUserInteraction');
                                  //_satellite.test(dataLayer.siteEvents);

                              }.bind(this))
                        .fail(function (msg) {
                                  this.$elems.questions.loader.removeClass('is-active');
                                  this.$elems.questions.error.addClass('is-active');

                                  dataLayer.siteEvents = 'API - DataPower | Fail | Connection error: '+JSON.stringify(msg);
                                  _satellite.track('genericUserInteraction');
                                  //_satellite.test(dataLayer.siteEvents);

                              }.bind(this));
                      } else if(id == 1)
                    {
                        // Toggle to the next screen, present loading page.
                        this.toggleSection(this.activeSection + 1);
                    }

                } else {
                    $parent.find('.radioGroup-error').addClass('is-active');
                }
            } else {
                this.toggleSection(this.activeSection + 1);

                dataLayer.siteEvents = 'Journey | Start ';
                _satellite.track('genericUserInteraction');
                //_satellite.test(dataLayer.siteEvents);
            }
        }.bind(this));
    };


    RoboAdvisor.prototype.validateStep = function (id) {
        // Validates the first two steps before actual Advisor journey starts
        var that = this;
        switch (id) {
            case 2:
            	return !!(
                	this.$elems.inputs.guide.prop('checked') && this.$elems.inputs.terms.prop('checked')
                );
            case 1:
            	var validationPassed = [[false,0],[false,0],false,false,false];
            	validationPassed[0][0] = this.$elems.inputs.userName.val() !== '';
            	validationPassed[0][1] = this.$elems.inputs.userName;

            	var emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,6}$/;
            	validationPassed[1][0] = emailRegex.test(this.$elems.inputs.email.val().toLowerCase());
            	validationPassed[1][1] = this.$elems.inputs.email;

                this.$elems.inputs.xp.find('input').each(
                    function () {
                        if ($(this).prop('checked')) {
                            that.apiPayload['Experience'] = parseInt($(this).val());
                            validationPassed[2] = true;
                        }
                    }
                );

                // this.$elems.inputs.existing.find('input').each(
                //     function () {
                //         if ($(this).prop('checked')) {
                //             that.apiPayload['Investment'] = parseInt($(this).val());
                //             validationPassed[3] = true;
                //         }
                //     }
                // );

            that.apiPayload['Investment'] = 1;
            validationPassed[3] = true;

                this.$elems.inputs.know.find('input').each(
                    function () {
                        if ($(this).prop('checked')) {
                            that.apiPayload['Knowledge'] = parseInt($(this).val());
                            validationPassed[4] = true;
                        }
                    }
                );

            return this.validateForm(validationPassed);
        }
        return false;
    };

    RoboAdvisor.prototype.validateForm = function (validationStep) {
        var that = this;
        var msg = '';
        var validated = true;

        validationStep.forEach(function(valid, i){
            if(i <= 1){
                if (valid[0] === false) {
                    valid[1].parent().addClass('error');
                } else {
                    valid[1].parent().removeClass('error');
                }
            }

            if(valid === false || valid[0] === false){
                if(msg === '') {
                    switch(i) {
                        case 0 : msg = 'Please fill in your name and email address.'; break;
                        case 1 : msg = 'We also require a valid E-mail.'; break;
                        default : msg = 'Please answer all the questions.'; break;
                    }
                    that.$elems.inputs.feedback.html(msg);
                    validated = false;
                }
            }
        });

        return validated;
    };

    RoboAdvisor.prototype.resetApp = function () {
        this.resetQuestions();
        this.toggleQuestion(0);
        this.toggleSection(0);
        //this.toggleCalculator(false);
        this.toggleStep(0);
        this.updateProgressBar();
        this.$elems.questions.error.removeClass('is-active');
        this.$elems.questions.loader.removeClass('is-active');
    };

    /*RoboAdvisor.prototype.toggleCalculator = function (state) {
        if (state) {
            this.$elems.roboWrapper.addClass('is-disabled');
            this.$elems.calculator.elem.removeClass('is-disabled');
        } else {
            this.$elems.roboWrapper.removeClass('is-disabled');
            this.$elems.calculator.elem.addClass('is-disabled');
        }
    };*/

    RoboAdvisor.prototype.toggleSection = function (id) {
        var that = this;
        this.$elems.sections.each(function () {

            if ($(this).hasClass('is-active')) {
                $(this).removeClass('is-active');
            }

            if ($(this).data('id') == id) {
                $(this).addClass('is-active');
                that.activeSection = id;

                if (that.activeSection == 2) {
                    that.toggleStep(that.activeStep + 1);
                }
            }
        });

        if (id == 1) {
            this.$elems.stepBar.elem.removeClass('is-disabled');
        } else if (id === 0) {
            this.$elems.stepBar.elem.addClass('is-disabled');
        }

        // Adds en empty state to to the browser history to prevent back button breaking app
        // TODO: In future either re-build entire tool using traditional HTTP or implement more robust JS routing library
        if (id === 0) {
            history.pushState({}, 'home', '');
        }

        $('html, body').animate({ scrollTop: this.$el.offset().top });
    };

    RoboAdvisor.prototype.toggleStep = function (id) {
        var that = this;
        this.$elems.stepBar.items.each(function () {

            if($(this).hasClass('is-active')) {
                $(this).removeClass('is-active');
            }

            if ($(this).data('id') == id) {
                $(this).addClass('is-active');
                that.activeStep = id;
            }
        });
    };

    RoboAdvisor.prototype.openInfoPopup = function () {
        this.activeQuestion.toggleInfoPopup(true);
    };

    RoboAdvisor.prototype.toggleQuestion = function (id) {
        // TODO: Too much logic in here. Some of it should be delegated to standalone functions.

        if (id < this.questionArray.length && id >= 0) {
            var question = this.questionArray[id];
            if (id > this.activeQuestion.id) {
                if (this.activeQuestion.isValid()) {
                    question.$el.addClass('is-active');
                    this.activeQuestion.$el.addClass('is-complete');
                } else {
                    this.activeQuestion.toggleError(true);
                    return;
                }
                this.activeQuestion.$el.removeClass('is-active');
            } else if (id < this.activeQuestion.id) {
                question.$el.removeClass('is-complete').addClass('is-active');
                this.activeQuestion.$el.removeClass('is-active');
            }

            this.activeQuestion.toggleInfoPopup(false);
            this.activeQuestion = question;

            this.activeQuestion.$el.parent().height(this.activeQuestion.$el.height());

        } else if (id == this.questionArray.length) {
            this.submitAnswers();
        }
        if (this.activeQuestion.id === 0) {
            this.$elems.questions.prevButton.addClass('is-disabled');
        } else {
            this.$elems.questions.prevButton.removeClass('is-disabled');
        }

        this.updateProgressBar();
    };

    RoboAdvisor.prototype.updateProgressBar = function () {
        var progress = ((this.activeQuestion.id + 1) / this.questionArray.length) * 100;
        this.$elems.questions.progress.css('width', progress + '%');
    };

    RoboAdvisor.prototype.resetQuestions = function () {
        for (var i = 0; i < this.questionArray.length; i++) {
            this.questionArray[i].answer = false;
            this.questionArray[i].$el.removeClass('is-complete');
            var radioItem = this.questionArray[i].$radioGroup.find('input[type="radio"]:checked');
            radioItem.each(function () {
                $(this).prop('checked', false);
            });
        }

        this.apiPayload = this.defaultPayload;
    };

    RoboAdvisor.prototype.submitAnswers = function () {

        this.$elems.questions.loader.addClass('is-active');

        for (var i = 0; i < this.questionArray.length; i++) {
            var question = this.questionArray[i];
            this.apiPayload[question.apiLabel] = parseInt(question.answer);
        }

        var apiRequestString = this.flattenPayload(this.apiPayload);
        //console.log('Request string: '+ this.apiUrl + '/' + apiRequestString);
        $.ajax({
            method: 'GET',
            url: this.apiUrl + '/' + apiRequestString
        })
        .done(function (response) {
            if(response.result === true) {
                this.renderResponse(response);
                this.$elems.questions.loader.removeClass('is-active');
                this.toggleStep(this.activeStep + 1);
                this.toggleSection(this.activeSection + 1);

                dataLayer.siteEvents = 'API - SmartRand | Success | Recommendation Recieved ';

            } else if(response.result === false) {
                this.$elems.questions.loader.removeClass('is-active');
                this.$elems.questions.error.addClass('is-active');

                var msg = '';
                switch(response.message){
                    case 'No recommendation': 	msg = 'We ran into some bugs while fetching your result. Please retake the assessment or give us a call.'; break;
                    case 'Not found':  			msg = 'We couldn’t generate a result for you due to some technical issues. Please retake the assessment or give us a call.'; break;
                    case 'Wrong parameter': 	msg = 'We couldn’t capture your response due to some technical issues. Please retake the assessment or give us a call.'; break;
                    case 'No score': 			msg = 'We couldn’t generate a result for you. Please retake the assessment or give us a call.'; break;
                    case 'Inconsistency Alert': msg = 'You don’t appear to have a clear preference for either high or low risk investments. Why not give us a call and discuss your specific requirements? '; break;
                    case 'Already done - '+this.defaultPayload.UID: msg = 'It looks like you’ve done this assessment before. Please retake the assessment with different details or give us a call.'; break;
                    case 'Database error': 		msg = 'We couldn’t connect to our database. Please retake the assessment or give us a call.'; break;
                    default:					msg = 'We couldn’t connect to our servers. Our technicians are on it! We’ll be up and running in no time.'; break;
      	        }

                this.$elems.questions.errorMsg.html(msg);

                if(response.message === 'Inconsistency Alert'){
                    dataLayer.siteEvents = 'API - SmartRand | Success | Could not recommend a product, instructed user to call Absa: '+response.message;
                } else {
                    dataLayer.siteEvents = 'API - SmartRand | Fail | Server error: '+response.message;
                }
       	    }

            _satellite.track('genericUserInteraction');

        }.bind(this))
        .fail(function (msg) {

                  this.$elems.questions.loader.removeClass('is-active');
                  this.$elems.questions.error.addClass('is-active');
                  this.$elems.questions.errorMsg.html('We couldn’t connect to our servers. Our technicians are on it! We’ll be up and running in no time.');

                  dataLayer.siteEvents = 'API - SmartRand | Fail | Connection error: '+JSON.stringify(msg);
                  _satellite.track('genericUserInteraction');

        }.bind(this));
    };

    RoboAdvisor.prototype.flattenPayload = function (payload) {
        var str = '';

        for (var i = 0; i < this.apiOrdering.length; i++) {
            str += payload[this.apiOrdering[i]];
            if (i != this.apiOrdering.length - 1) {
                str += ',';
            }
        }

        return str;
    };

    RoboAdvisor.prototype.renderResponse = function (data) {
        var productName = toTitleCase(data.RecommendedProductName);

        this.$elems.summary.capacity.html(this.$feedback.knowledge[this.apiPayload.Capacity]);
        this.$elems.summary.score.html(data.score);

        var group = 'Very Low';
        if (data.score >= 65) {
            group = 'Very High';
        } else if (data.score >= 55) {
            group = 'High';
        } else if (data.score >= 45) {
            group = 'Average';
        } else if (data.score >= 35) {
            group = 'Low';
        }

        this.$elems.summary.group.html(group);

        //console.log("Question 13 selection: "+this.apiPayload.Horizon);
        // TODO: refactor this to use fewer selector chains
        this.$elems.summary.horizon.html(
            $('#q13a' + (this.apiPayload.Horizon)).parent().find('.radioGroup-labelContent').html()
        );
        this.$elems.summary.experience.html(this.$feedback.experience[this.apiPayload.Experience]);
        this.$elems.summary.productName.html(productName);
        this.$elems.summary.productInfo.html(data.RecommendedProductInformation);
        this.$elems.summary.riskProfile.attr('href', data.profile);
        this.$elems.summary.adviceRecord.attr('href', data.record);
        this.$elems.summary.factSheet.attr('href', data.RecommendedProductFactSheet);
        this.$elems.summary.scale.css('width', data.score - 1 + '%');

        var continueUrl = this.continueUrl+this.defaultPayload.UID.replace(/"/g,'');
        this.$elems.summary.continue.attr('href', continueUrl);
        //this.$elems.summary.scale.attr('data-value', data.score);
    };

    var Question = function ($el) {
        this.$el = $el;
        this.id = $el.data('id');
        this.apiLabel = $el.data('api-label');

        // Deprecated: The field types are no longer relevant as all API fields get concatenated.
        // Keeping this here in case SmartRand modify their API to accept JSON input (as opposed to a comma-delimited url)
        this.apiType = $el.data('api-type');
        this.$radioGroup = $el.find('[data-hook="radio-group"]');
        this.$infoPopup = {
            closeButton: $el.find('[data-hook="info-popup-close"]'),
            elem: $el.find('[data-hook="info-popup-elem"]'),
            error: $el.find('[data-hook="radio-error"]')
        };

        this.answer = false;
        this.bindUIEvents();
    };

    Question.prototype.bindUIEvents = function () {
        this.$radioGroup.on('change', function (event) {
            this.answer = event.target.value;
            this.toggleError(false);
        }.bind(this));
        this.$infoPopup.closeButton.on('click', this.toggleInfoPopup.bind(this, false));
    };

    Question.prototype.toggleInfoPopup = function (state) {
        if(state) {
            this.$infoPopup.elem.addClass('is-open');
        } else {
            this.$infoPopup.elem.removeClass('is-open');
        }
    };

    Question.prototype.isValid = function () {
        return this.answer;
    };

    Question.prototype.toggleError = function (state) {
        if(state) {
            this.$infoPopup.error.addClass('is-active');
        } else {
            this.$infoPopup.error.removeClass('is-active');
        }
    };

    function toTitleCase(str) {
        return str.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
    }

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.RoboAdvisor.push(new RoboAdvisor($el));
    };

    Cog.registerComponent({
        name: 'roboAdvisor',
        api: api,
        selector: '.roboAdvisor',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/

(function () {
    'use strict';

    var api = {
            CalculatorRangeSlider: []
        },
        status = null,
        browser = null,
        currencyHelper = null;

    /**
     * calculatorRangeSlider class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculatorRangeSlider($el) {
        this.$el = $el;

        this.$input = $el.find('.calculator-range');
        this.hook = $el.data('hook');

        this.value = this.$input.val();

        // Determine disabled range (if specified)
        var disabledRange = this.$input.data('disabled-range') || '-1,-1';
        this.disabledRange = {};
        this.disabledRange['low'] = parseInt(disabledRange.split(',')[0]);
        this.disabledRange['high'] = parseInt(disabledRange.split(',')[1]);

        // Range slider tooltip value tabs
        this.$tab =  $el.find('.calculator-tab');

        // Range slider progress bars
        this.$progressMarker = $el.find('.calculator-progress');

        this.init();
    }

    CalculatorRangeSlider.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            // Hide range input progress override on IE
            if (browser.msie || (browser.mozilla && browser.version == '11.0') || /Edge/.test(navigator.userAgent)) {
                this.$el.find('.calculator-progress').hide();
                this.$el.find('.calculator-tab').addClass('ie-fix');
                this.$el.find('.calculator-range').addClass('ie-fix');
            }
            this.bindUIEvents();
            this.update();
        }
    };

    CalculatorRangeSlider.prototype.bindUIEvents = function () {
        this.$el.on('input change', function () {
            this.update();
            Cog.fireEvent('calculatorRangeSlider', 'update', {'hook': this.hook, 'value': this.value});
        }.bind(this));

        /*this.$el.on('change', function () {
            this.update();
            Cog.fireEvent('calculatorRangeSlider', 'complete', {'hook': this.hook, 'value': this.value});
        }.bind(this));*/

        this.$el.on('focusin', function () {
            this.update();
            Cog.fireEvent('calculatorRangeSlider', 'focusin', {'hook': this.hook, 'value': this.value});
        }.bind(this));
    };

    CalculatorRangeSlider.prototype.update = function () {

        this.value = parseInt(this.$input.val());

        // Ensure value is not within disabled range before doing anything else

        if (this.value >= this.disabledRange.low && this.value <= this.disabledRange.high) {
            var distFromLow = this.value  - this.disabledRange.low;
            var distFromHigh = this.disabledRange.high - this.value ;
            if (distFromLow < distFromHigh) {
                this.value  = this.disabledRange.low - 1;
            } else {
                this.value  = this.disabledRange.high + 1;
            }
            this.$input.val(this.value);
        }

        var progress = currencyHelper.mapRangePercentage(
            this.value,
            this.$input.attr('min'),
            this.$input.attr('max')
        );

        // Calculate width of progress bar relative to the range slider's control
        progress += 0.9 * (-3 * (progress / 100 - 0.5));
        this.$progressMarker.css('width', progress + '%');

        var tabPosition = 100 - progress;
        var tabWidth = 100 - (
            (this.$tab.outerWidth() / this.$tab.parent().outerWidth()) * 100
        );

        if (tabPosition > tabWidth) {
            tabPosition = tabWidth;
        }

        this.$tab.css('right', tabPosition + '%');

        switch(this.$input.data('format')) {

            case 'years':
             this.$tab.html(this.value + ' years');
            break;

            case 'months':
             var months = this.value;
             var years = Math.floor(this.value / 12);
             var remainderMonths = this.value % 12;

             var outputString = months + ' months';

             if (months < 2) {
                 outputString = months + ' month';
             }

             var yearsString = ' years ';
             if (years < 2) {
                yearsString = ' year ';
             }

             var monthsString = ' months';
             if (remainderMonths < 2) {
                 monthsString = ' month';
             }

             if (years !== 0) {
                 outputString += ' (' + years + yearsString;
                 if (remainderMonths !== 0) {
                     outputString += remainderMonths + monthsString + ')';
                 } else {
                     outputString += ')';
                 }
             }

             this.$tab.html(outputString);
            break;

            case 'percentage':
                this.$tab.html(this.value + '%');
                break;

            case 'currency':
                this.$tab.html('R'+this.value);

            break;
        }
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        browser = this.external.browser;
        currencyHelper = this.external.currencyHelper;

        api.CalculatorRangeSlider.push(new CalculatorRangeSlider($el));
    };

    Cog.registerComponent({
        name: 'CalculatorRangeSlider',
        api: api,
        selector: '.calculator-range-slider',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }, {
                name: 'utils.browser',
                apiId: 'browser'
            }, {
                name: 'utils.currencyHelper',
                apiId: 'currencyHelper'
            }
        ]
    });

})(Cog.jQuery());

(function ($) {
    'use strict';

    var api = {
            calculatorToggler: []
        },
        status = null;

    /**
     * CalculateHomeLoan class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatorToggler($el) {
        this.$el = $el;

        this.$toggler = {
            container: $el,
            switch: $el.find('.calculator-switch'),
            base_1: $el.find('[data-hook="toggler-switch-base_1"]'),
            base_2: $el.find('[data-hook="toggler-switch-base_2"]')
        };

        this.modes = [
            this.$toggler.base_1.data('mode'),
            this.$toggler.base_2.data('mode')
        ];

        this.mode = this.modes[0];

        // Cache html content of toggler switches
        this.modeStrings = {};

        this.modeStrings[this.modes[0]] = this.$toggler.base_1.html();
        this.modeStrings[this.modes[1]] = this.$toggler.base_2.html();

        this.init();
    }

    CalculatorToggler.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.bindUIEvents();
        }
    };

    CalculatorToggler.prototype.bindUIEvents = function () {
        var that = this;

        var active = false;
        var mouseX = 0;
        var clickPos = 0;

        var width = that.$toggler.switch.width();
        var containerWidth = that.$toggler.container.width();
        var containerOffset = that.$toggler.container.offset().left;

        var halfWay = containerWidth - width;

        $(window).on('resize', _.throttle(function () {

            width = that.$toggler.switch.width();
            containerWidth = that.$toggler.container.width();
            containerOffset = that.$toggler.container.offset().left;

            halfWay = containerWidth - width;

            if (that.mode == that.modes[0]) {
                that.$toggler.switch.css('left', 0);
            }

            if (that.mode == that.modes[1]) {
                that.$toggler.switch.css('left', (containerWidth / 2));
            }
        }, 100));

        $(document).on('mousemove touchmove', function (evt) {

            if (active) {

                if (evt.originalEvent.touches === undefined) {
                    mouseX = evt.pageX;
                } else {
                    mouseX = evt.originalEvent.touches[0].pageX;
                }

                var offsetAmount = mouseX - clickPos - containerOffset;

                if (offsetAmount < 0) {
                    offsetAmount = 0;
                }

                if (offsetAmount > halfWay && that.mode !== that.modes[0]) {
                    offsetAmount = halfWay;
                    that.mode = that.modes[0];
                    that.toggleMode();
                }

                if (offsetAmount < halfWay * 0.3 && that.mode !== that.modes[0]) {
                    that.mode = that.modes[0];
                    that.toggleMode();
                }

                if (offsetAmount > halfWay * 0.6 && that.mode !== that.modes[1]) {
                    that.mode = that.modes[1];
                    that.toggleMode();
                }

                that.$toggler.switch.css('left', offsetAmount);

            }
        });

        $(document).on('mouseup touchend', function () {

            if (active) {
                active = false;

                var progress = that.$toggler.switch.css('left');
                progress = parseInt(progress.replace('px', ''), 10);
                var width = that.$toggler.switch.width();

                progress = progress / width;

                if (progress < 0.5) {
                    that.$toggler.switch.animate({'left': 0}, 200);
                    that.mode = that.modes[0];
                } else {
                    that.$toggler.switch.animate({'left': width}, 200);
                    that.mode = that.modes[1];
                }
                that.toggleMode();
                //that.updateOutputs();
            }
        });

        this.$toggler.switch.on('touchstart mousedown', function (evt) {
            active = true;

            if (evt.originalEvent.touches === undefined) {
                mouseX = evt.pageX;
            } else {
                mouseX = evt.originalEvent.touches[0].pageX;
            }

            clickPos = mouseX - containerOffset;

            if (clickPos > width) {
                clickPos = clickPos - width;
            }
        });

        this.$toggler.base_1.on('tap click', function () {
            that.$toggler.switch.animate({'left': 0}, 200);
            that.mode = that.modes[0];
            that.toggleMode();
        });

        this.$toggler.base_2.on('tap click', function () {
            var width = that.$toggler.switch.width();
            that.$toggler.switch.animate({'left': width}, 200);
            that.mode = that.modes[1];
            that.toggleMode();
        });
    };

    CalculatorToggler.prototype.toggleMode = function () {
        this.$toggler.switch.html(this.modeStrings[this.mode]);
        Cog.fireEvent('calculatorToggler', 'switched', this.mode);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        api.calculatorToggler.push(new CalculatorToggler($el));
    };

    Cog.registerComponent({
        name: 'calculatorToggler',
        api: api,
        selector: '.calculator-toggler',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }]
    });

})(Cog.jQuery());

/* jshint maxlen: 500 */
/* global formtracker */

(function ($) {
    'use strict';

    var api = {
        RatesPricingComponent: []
    },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * DemoComponent class
     * @param $el navigation wrapper
     * @constructor
     */


    function RatesPricingComponent($el) {
        this.$el = $el;
        var that = this;

        this.$inputs = {
            types: {
                dropdowns: $el.find('[data-hook="dropDown-container"]'),
                transactionCount: $el.find('[data-hook="transaction-counter"]'),
                transactionMinus: $el.find('[data-hook="transaction-minus"]'),
                transactionPlus: $el.find('[data-hook="transaction-plus"]'),
                transactionBars: $el.find('[data-hook="transaction-bar"]'),
                reset: $el.find('[data-hook="reset"]')
            },
            dropdownObj: [],
            transactionObj: [],
            currentTransaction: 0
        };

        this.json = {
            raw: {},
            selectedAccount: 0,
            selectedTransaction: 0,
            selectedTransactionBenefit: 0,
            selectedChannel: 0,
            benefitLimit: 0,
            accTransactions: []
        };

        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$transferFeesSummary = $el.find('[data-hook="section-transfer_fees_summary"]');

        this.$outputs = {
            accountName: $el.find('[data-hook="account-name"]'),
            //accountMonthlyFee: $el.find('[data-hook="monthly-fee"]'),
            accountDescription: $el.find('[data-hook="account-description"]'),
            accountBenefits: $el.find('[data-hook="account-benefits"]'),
            transactionGroup: $el.find('[data-hook2="transaction-group"]'),
            transactionFee: $el.find('[data-hook="transaction-fee-summary"]'),
            transactionFees: $el.find('[data-hook="transaction-fee"]'),
            transactionFeesContainer: $el.find('[data-hook="transaction-fees-container"]'),
            similarTransactions: $el.find('[data-hook="similar-transactions"]'),
            freeTransactions: $el.find('[data-hook="free-transactions"]'),
            collapsible: $el.find('[data-hook="collapsible"]'),
            elements: {
                tick: '<svg class="tick" width="24px" height="24px" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><circle fill="#FFFFFF" cx="12" cy="12" r="12"></circle><path d="M10.9527764,14.9032347 L8.43469371,12.4877577" stroke="#012B44" stroke-width="4" stroke-linecap="round"></path><path d="M10.9527764,14.9032347 L16.4194336,9.65933025" stroke="#012B44" stroke-width="4" stroke-linecap="round"></path></svg>'
            }
        };

        this.$content = {
            json: $el.find('[data-hook="ratesPricing-data"]')
        };

        this.model = {
            selectedType: '',
            selectedAccount: '',
            derived: {
                get total() {
                    return that.model.derived.absa + that.model.derived.partners + that.model.derived.fuel;
                }
            }
        };

        this.init();
    }

    RatesPricingComponent.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.createObjects();
            this.bindUIEvents();
            // this.updateOutputs();
            this.json.raw = this.getData(this.$content.json.html());
        }
    };

    RatesPricingComponent.prototype.getData = function (src) {
        return JSON.parse(src || null);
    };

    RatesPricingComponent.prototype.createObjects = function () {
        var that = this;

        _.forEach(this.$inputs.types.dropdowns, function (element, key) {
            var elem = $(element);
            that.$inputs.dropdownObj[key] = {};
            that.$inputs.dropdownObj[key].container = elem;
            that.$inputs.dropdownObj[key].type = elem.attr('data-type') || null;
            that.$inputs.dropdownObj[key].drawer = elem.find('[data-hook="drawer"]');
            that.$inputs.dropdownObj[key].display = elem.find('[data-hook="displayInput"]');
            that.$inputs.dropdownObj[key].displayText = that.$inputs.dropdownObj[key].display.find('input[type=text]');
            that.$inputs.dropdownObj[key].tracking = that.$inputs.dropdownObj[key].display.find('input[type=text]').attr('id');
        });

        var fees = [];
        _.forEach(this.$outputs.transactionFees, function (element, key) {
            var elem = $(element);
            fees[key] = elem;
        });

        _.forEach(this.$inputs.types.transactionBars, function (element, key) {
            var elem = $(element);
            that.$inputs.transactionObj[key] = {};
            that.$inputs.transactionObj[key].bar = elem;
            that.$inputs.transactionObj[key].value = parseInt(elem.attr('data-value'));
            that.$inputs.transactionObj[key].visible = !elem.hasClass('hide');
            that.$inputs.transactionObj[key].feeElem = fees[key];
            that.$inputs.transactionObj[key].amount = fees[key].attr('data-value');
        });

        // if(that.$inputs.dropdownObj.length > 0)
        //     console.dir(that.$inputs.dropdownObj)

        // if(that.$inputs.transactionObj.length > 0)
        //     console.dir(that.$inputs.transactionObj)
    };

    RatesPricingComponent.prototype.bindUIEvents = function () {
        var that = this;

        this.$el.on('click', function () {
            // if user clicks on page, close any open dropdowns
            // this requires a 'stopPropogation' for all other events
            that.closeDropdowns();
        });

        this.$subMenu.on('click', function (evt) {
            evt.stopPropagation();
            that.toggleTransactionsDisplay();
        });

        this.$inputs.types.transactionMinus.on('click', function (evt) {
            evt.stopPropagation();

            that.transactionAction('remove');
        });

        this.$inputs.types.reset.on('click', function (evt) {
            evt.stopPropagation();

            that.$outputs.collapsible.removeClass('active');
            that.resetDropdowns();
            that.$subMenu.removeClass('active');
            that.$transferFeesSummary.removeClass('active');
            that.$outputs.transactionFeesContainer.removeClass('active');
        });

        this.$inputs.types.transactionPlus.on('click', function (evt) {
            evt.stopPropagation();
            that.transactionAction('add');
        });

        _.forEach(that.$inputs.dropdownObj, function (element) {
            var elem = $(element)[0];

            if (elem) {
                elem.display.on('click', function (evt) {
                    evt.stopPropagation();

                    if (typeof formtracker !== 'undefined') {
                        formtracker.trigger(elem.tracking, 'change');
                    }

                    if (!elem.container.hasClass('disabled')) {
                        that.closeDropdowns(elem);
                        elem.drawer.toggleClass('open');
                    }
                });

                elem.drawer.on('click', function (evt) {
                    evt.stopPropagation();

                    if ($(evt.target).is('li')) {
                        elem.displayText.attr('value', that.capitaliseString($(evt.target).text()));
                        elem.drawer.removeClass('open');

                        var next = that.enableDropdowns(elem);
                        that.populateDropdown(elem.type, $(evt.target).text(), next);
                    }
                });
            }
        });
    };

    RatesPricingComponent.prototype.transactionAction = function (type) {
        var length = this.$inputs.transactionObj.length - 1;

        if (type === 'add') {
            this.checkTransactionAdd(length);
            this.$inputs.transactionObj[this.$inputs.currentTransaction].visible = true;
        } else if (type === 'remove') {
            this.$inputs.transactionObj[this.$inputs.currentTransaction].visible = false;
            this.checkTransactionRemove();
        }

        this.$inputs.types.transactionCount.html(parseInt(this.$inputs.currentTransaction) + 1);

        _.forEach(this.$inputs.transactionObj, function (element) {
            if (element.visible) {
                element.bar.removeClass('hide');
                element.feeElem.removeClass('hide');
            } else {
                element.bar.addClass('hide');
                element.feeElem.addClass('hide');
            }
        });
    };

    RatesPricingComponent.prototype.checkTransactionAdd = function (length) {
        var current = parseInt(this.$inputs.currentTransaction);

        if (current < length) {
            current++;
            this.$inputs.types.transactionMinus.removeClass('hide');
        }
        if (current >= length) {
            current = length;
            this.$inputs.types.transactionPlus.addClass('hide');
        }
        this.$inputs.currentTransaction = current;
    };

    RatesPricingComponent.prototype.checkTransactionRemove = function () {
        var current = parseInt(this.$inputs.currentTransaction);

        if (current >= 1) {
            current--;
            this.$inputs.types.transactionPlus.removeClass('hide');
        }
        if (current < 1) {
            current = 0;
            this.$inputs.types.transactionMinus.addClass('hide');
        }
        this.$inputs.currentTransaction = current;
    };


    RatesPricingComponent.prototype.closeDropdowns = function ($current) {
        _.forEach(this.$inputs.dropdownObj, function (element) {
            if ($current !== $(element)[0]) {
                $(element)[0].drawer.removeClass('open');
            }
        });
    };

    RatesPricingComponent.prototype.resetDropdowns = function () {
        _.forEach(this.$inputs.dropdownObj, function (element, key) {
            // current element & next
            if (key > 0) {
                element.displayText.attr('value', '');
                element.container.addClass('disabled');
            }
        });
    };

    RatesPricingComponent.prototype.enableDropdowns = function ($current) {
        var ref = null;

        _.forEach(this.$inputs.dropdownObj, function (element, key) {
            // current element & next
            if (element === $current) { ref = key + 1; }
            if (ref && key >= ref) {
                element.displayText.attr('value', '');
                element.container.addClass('disabled');
            }
        });

        if (this.$inputs.dropdownObj[ref]) {
            this.$inputs.dropdownObj[ref].container.removeClass('disabled');
            this.$inputs.dropdownObj[ref].drawer.find('ul').empty();
        } else {
            ref--;
        }
        return this.$inputs.dropdownObj[ref];
    };

    RatesPricingComponent.prototype.capitaliseString = function ($str) {
        return $str.charAt(0).toUpperCase() + $str.slice(1);
    };

    RatesPricingComponent.prototype.populateDropdown = function (targetType, selectedText, target) {
        //var that = this;

        var nextElements = {};
        switch (targetType) {
            case 'accType': nextElements = this.filterJson(targetType, selectedText, this.json.raw.accounts); break;
            case 'accName': nextElements = this.subsectionJson(targetType, selectedText, this.json.raw.accounts); break;
            case 'accTransactions':
                nextElements = this.transactionsJson(selectedText, this.json.selectedAccount.accTransactions); break;
            case 'accSelected': this.showResults(selectedText); break;
        }

        var textToWrite = '';
        _.forEach(nextElements, function (element) {
            switch (targetType) {
                case 'accType': textToWrite = element.accName; break;
                case 'accName': textToWrite = Object.keys(element); break;
                case 'accTransactions': textToWrite = element; break;
            }

            target.drawer.find('ul').append('<li>' + textToWrite + '</li>');
        });
    };

    RatesPricingComponent.prototype.showResults = function ($selected) {
        this.json.selectedChannel = $selected;

        this.showSections(this.json.selectedTransaction);

        this.$outputs.accountDescription.html(this.json.selectedAccount.accDescription);
        this.$outputs.accountName.html(this.json.selectedAccount.accName);
        this.$outputs.transactionFee.html(this.formatTransaction(this.json.accTransactions[this.json.selectedChannel]));

        this.transactionFeeCalculation(this.json.accTransactions[this.json.selectedChannel]);

        this.populateBenefits();
        this.populateOtherTransactions();
        this.populateTransactionBenefits();
    };

    RatesPricingComponent.prototype.showSections = function () {

        this.$outputs.collapsible.addClass('active');

        if (this.json.selectedTransaction.search('check') !== -1 ||
            this.json.selectedChannel.search('prepaid') !== -1) {
            this.removeTransactionsDisplay();
            this.$outputs.transactionGroup.removeClass('active');
        } else {
            this.$outputs.transactionGroup.addClass('active');
        }
    };

    RatesPricingComponent.prototype.toggleTransactionsDisplay = function () {
        this.$subMenu.toggleClass('active');
        this.$transferFeesSummary.toggleClass('active');
        this.$outputs.transactionFeesContainer.toggleClass('active');
    };

    RatesPricingComponent.prototype.removeTransactionsDisplay = function () {
        this.$subMenu.removeClass('active');
        this.$transferFeesSummary.removeClass('active');
        this.$outputs.transactionFeesContainer.removeClass('active');
    };

    RatesPricingComponent.prototype.formatPrice = function (val) {
        var length = val.length;
        var str = '';

        function getSavingAccountString(val_1, val_2, val_3) {
            var str = '';
            if (val_1 == '0') {
                str = val_2 + ' for every ' + val_3;
            } else {
                str = 'First ' + val_1 + ' no charge, thereafter ' + val_2 + ' per ' + val_3;
            }
            return str;
        }
        switch (length) {
            case 1: str = this.formatNum(val[0]); break;
            case 2: str = getSavingAccountString(this.formatNum(this.json.selectedAccount.benefitLimit), this.formatNum(val[0]), this.formatNum(val[1])); break;
            case 3: str = this.formatNum(val[0]) + ' + ' + this.formatNum(val[1]) +
                ' per ' + this.formatNum(val[2]); break;
            case 4: str = this.formatNum(val[0]) + ' + ' + this.formatNum(val[1]) +
                ' per ' + this.formatNum(val[2]) + ' (min ' + this.formatNum(val[3]) + ' fee)'; break;
        }

        return str;
    };

    RatesPricingComponent.prototype.formatTransaction = function (val) {
        var length = val.length;
        var str = '';

        function getChequeAccountString(val_1, val_2, val_3) {
            var str = '';
            if (val_1 == '0') {
                str =  val_2 + ' for every ' + val_3;
            } else {
                str = 'First ' + val_1 + ' no charge, thereafter ' + val_2 + ' per ' + val_3;
            }
            return str;
        }

        switch (length) {
            case 1: str = this.formatNum(val[0]); break;
            case 2: str = getChequeAccountString(this.formatNum(this.json.selectedAccount.benefitLimit), this.formatNum(val[0]), this.formatNum(val[1]));break;
            case 3: str = this.formatNum(val[0]) + ' plus ' + this.formatNum(val[1]) + ' for every ' +
                this.formatNum(val[2]); break;
            case 4: str = this.formatNum(val[0]) + ' plus ' + this.formatNum(val[1]) + ' for every ' +
                this.formatNum(val[2]) + ' with a minimum fee of ' + this.formatNum(val[3]); break;
        }

        return str;
    };

    RatesPricingComponent.prototype.transactionFeeCalculation = function (val) {
        var that = this;
        var length = val.length;
        var str = '';

        _.forEach(this.$inputs.transactionObj, function (elem) {
            switch (length) {

                case 1: str = that.formatNum(val[0]); break;
                case 2: var threshold = that.json.selectedAccount.benefitLimit;
                    str = (elem.amount <= threshold) ?
                        that.formatNum(0) :
                        that.formatNum(val[0] * ((elem.amount - threshold) / val[1]));
                    break;
                case 3: str = that.formatNum(val[0] + val[1] * Math.floor(elem.amount / val[2])); break;
                case 4: str = that.formatNum(((val[0] + val[1] * (elem.amount / val[2])) > val[3]) ?
                    (val[0] + val[1] * (elem.amount / val[2])) : val[3]); break;

            }
            elem.feeElem.find('div').html(str);
        });
    };

    RatesPricingComponent.prototype.formatNum = function (val) {
        var str = '';
        if (val === 'N/A' || val === 'Included') {
            str = val;
        } else {
            str = 'R ' + parseFloat(val).toFixed(2).toString();
        }

        return str;
    };

    RatesPricingComponent.prototype.populateBenefits = function () {
        var that = this;
        this.$outputs.accountBenefits.empty();
        this.$outputs.accountBenefits.parent().removeClass('hide');

        _.forEach(this.json.selectedAccount.benefits, function (benefit) {
            that.$outputs.accountBenefits.append('<li>' + benefit + '</li>');
        });

        if (this.$outputs.accountBenefits.html() === '') {
            that.$outputs.accountBenefits.parent().addClass('hide');
        }
    };

    RatesPricingComponent.prototype.populateOtherTransactions = function () {
        var that = this;
        this.$outputs.similarTransactions.empty();

        _.forEach(this.json.accTransactions, function (trans, key) {
            if (key != that.json.selectedChannel) {
                that.$outputs.similarTransactions.append(that.writeBenefit(key, trans));
            }
        });
    };

    RatesPricingComponent.prototype.populateTransactionBenefits = function () {
        var that = this;
        //var count = 0;
        this.$outputs.freeTransactions.empty();
        that.$outputs.freeTransactions.parent().removeClass('hide');

        if (this.json.selectedTransactionBenefit !== 'none') {
            that.$outputs.freeTransactions.append(that.writeBenefit(this.json.selectedTransactionBenefit));
            //count++;
        }

        _.forEach(this.json.selectedAccount.accTransactions, function (account) {
            var thisBenefit = account[Object.keys(account)[0]][0].benefit;
            // if(count < 3 && thisBenefit !== 'none' && thisBenefit !== that.json.selectedTransactionBenefit){
            if (thisBenefit !== 'none' && thisBenefit !== that.json.selectedTransactionBenefit) {
                that.$outputs.freeTransactions.append(that.writeBenefit(thisBenefit));
                // count++;
            }
        });

        if (that.$outputs.freeTransactions.html() === '') {
            that.$outputs.freeTransactions.parent().addClass('hide');
        }
    };

    RatesPricingComponent.prototype.writeBenefit = function (str1, str2) {

        return '<div class="benefit">' + this.$outputs.elements.tick +
            '<div class="benefitName">' + str1 + '</div>' +
            ((!str2) ? '' : '<div class="price">' + this.formatPrice(str2) + '</div>') + '</div>';

    };

    RatesPricingComponent.prototype.subsectionJson = function ($param, $value, $json) {
        var i = _.findIndex($json, function (acc) { return acc[$param] === $value; });

        this.json.selectedAccount = $json[i];

        return $json[i].accTransactions;
    };

    RatesPricingComponent.prototype.transactionsJson = function ($value, $json) {
        var transactions = _.find($json, function (elem) {
            return Object.keys(elem) == $value;
        });

        this.json.selectedTransaction = $value;
        this.json.selectedTransactionBenefit = transactions[$value][0].benefit;
        this.json.accTransactions = transactions[$value][1];

        return _.keys(transactions[$value][1]);
    };

    RatesPricingComponent.prototype.filterJson = function ($param, $value, $json) {
        return _.filter($json, function (acc) { return acc[$param] === $value; });
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.RatesPricingComponent.push(new RatesPricingComponent($el));
    };

    Cog.registerComponent({
        name: 'RatesPricingComponent',
        api: api,
        selector: '.calculateRatesPricing',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
           DynamicFixedComponent : []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * DemoComponent class
     * @param $el navigation wrapper
     * @constructor
     */

    function DynamicFixedComponent($el) {
        this.$el = $el;
        var that = this;

        this.$inputs = {
            types: {
                dropdowns: $el.find('[data-hook="dropDown-container"]')
            },
            currency: {
                amount:  $el.find('[data-hook="input-price"]')
            },
            number: {
                period:  $el.find('[data-hook="input-period"]')
            },
            range: {
                liquidity: $el.find('[data-hook="input-liquidity"]'),
                liquiditySlider: $el.find('[data-hook="input-liquiditySlider"]')
            },
            dropdownObj: {}
        };

        this.$outputs = {
            raw:{
                  period: $el.find('[data-hook="output-period"]')
            },
            whole:{
                totalSave: $el.find('[data-hook="output-total_savings"]'),
                totalInterest: $el.find('[data-hook="output-total_interest"]'),
                liquidity: $el.find('[data-hook="output-liquidity"]')
            },
            decimals:{
                interestRate: $el.find('[data-hook="output-interest_rate"]')
            }
        };

        this.$content = {
            raw : $el.find('[data-hook="dynamicFixed-data"]'),
            json: {}
        };

        this.model = {
            amount: 0,
            period: -1,
            periodDays:[8,31],
            investmentType: 'dynamicFixed',
            rateType: -2,
            liquidity: false,
            interestRate: 0,
            derived: {
                get period() {
                    return '('+that.model.periodDays[0]+' to '+that.model.periodDays[1]+' days)';
                },

                get totalSave() {
                    return parseFloat(that.model.amount * (that.model.interestRate/100) *
                                      that.model.periodDays[0] / 365).toFixed(0);
                },
                get interestRate() {
                    return that.model.interestRate;
                },
                get liquidity() {
                    return that.model.amount * (that.model.rateType / 10);
                },
                get totalInterest() {

                    return (parseFloat(that.model.derived.totalSave) !== 0)?
                        parseFloat(that.model.derived.totalSave) + parseFloat(that.model.amount): 0;
                }
            }
        };

        this.showSlider = this.addRemoveClass(this.$inputs.range.liquidity.parent(), 'hide');
        this.activeSlider = this.addRemoveClass(this.$inputs.range.liquidity, 'inactive');
        this.setSliderMax = this.setAttribute(this.$inputs.range.liquiditySlider, 'max');
        this.activePeriod = this.addRemoveClass(this.$inputs.number.period.parent(), 'hide');
        this.activeLiquidity = this.addRemoveClass(this.$outputs.whole.liquidity.parent().parent(), 'hide');

        this.init();
    }

    DynamicFixedComponent.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.createObjects();
            this.bindUIEvents();
            this.updateOutputs();
            this.$content.json = this.getData(this.$content.raw.html());
        }
    };

    DynamicFixedComponent.prototype.addRemoveClass = _.curry(function($elem, $class, $enable){
                                                         if($enable){
                                                             $elem.removeClass($class);
                                                         } else {
                                                             $elem.addClass($class);
                                                         }
                                                     });

    DynamicFixedComponent.prototype.setAttribute = _.curry(function($elem, $attr, $value){
                                                       $elem.attr($attr, $value);
                                                   });

    DynamicFixedComponent.prototype.filterJson = function($param, $value, $json){
        return _.filter($json, function(section){ return section[$param] === $value; });
    };

    DynamicFixedComponent.prototype.filterAmount = function($param, $value, $json){
        return _.find($json, function(section){
                   return (section[$param][0] <= $value && $value < section[$param][1]);
               });
    };

    DynamicFixedComponent.prototype.filterPeriod = function($param, $value, $json){
        return _.filter($json, function(section){
                   return section[$param] == $value || (section[$param][0] <= $value && $value <= section[$param][1]);
               });
    };

    DynamicFixedComponent.prototype.runCalculations = function(){
        var round1 = this.filterJson('accType', this.model.investmentType, this.$content.json.accounts);
        var round2 = this.filterJson('liquidity', this.model.liquidity, round1);
        var round3 = this.filterAmount('investAmount', this.model.amount, round2[0].tables);
        var round4 = this.filterPeriod('period', this.model.period, round3.collection);

        return round4[0].rates[this.model.rateType];
    };

    DynamicFixedComponent.prototype.enableSlider = function($enable){
        this.$inputs.range.liquiditySlider.attr('value', 0);
        if($enable){
            this.activeSlider(true);
            this.showSlider(true);
            this.setSliderMax(50);
            this.activeLiquidity(true);
            this.model.liquidity = true;
            this.model.rateType = 0;
        } else {
            this.activeSlider(false);
            this.showSlider(false);
            this.activeLiquidity(false);
            this.setSliderMax(0);
            this.model.liquidity = false;
        }
    };

    DynamicFixedComponent.prototype.getData = function (src) {
        return JSON.parse(src || null);
    };

    DynamicFixedComponent.prototype.createObjects = function () {
        var that = this;

        _.forEach(this.$inputs.types.dropdowns, function(element, key) {
            var elem = $(element);
            that.$inputs.dropdownObj[key] = {};
            that.$inputs.dropdownObj[key].container = elem;
            that.$inputs.dropdownObj[key].type = elem.attr('data-type') || null;
            that.$inputs.dropdownObj[key].drawer = elem.find('[data-hook="drawer"]');
            that.$inputs.dropdownObj[key].display = elem.find('[data-hook="displayInput"]');
            that.$inputs.dropdownObj[key].displayText = that.$inputs.dropdownObj[key].display.find('input[type=text]');
            that.$inputs.dropdownObj[key].isEnabled = that.addRemoveClass(elem, 'disabled');
        });
    };

    DynamicFixedComponent.prototype.bindUIEvents = function () {
        var that = this;

        this.enableSlider(false);

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.number,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.number,
            this.model
        );

        this.$el.on('click', function(){
            // if user clicks on page, close any open dropdowns
            // this requires a 'stopPropogation' for all other events
            that.closeDropdowns();
        });

        _.forEach(that.$inputs.dropdownObj, function(element) {
            var elem = $(element)[0];

            if(elem){
                elem.display.on('click', function(evt){
                    evt.stopPropagation();

                    if(formtracker){
                        formtracker.trigger($(evt.target).attr('name'), 'opened');
                    }

                    if(!elem.container.hasClass('disabled')) {
                        that.closeDropdowns(elem);
                        elem.drawer.toggleClass('open');
                    }
                });

                elem.drawer.on('click', function(evt){
                    evt.stopPropagation();

                    if($(evt.target).is('li')){
                        elem.displayText.attr('value', that.capitaliseString($(evt.target).text()));
                        elem.drawer.removeClass('open');
                        that.userSelection($(evt.target).attr('data-option'));

                        if(formtracker){
                            formtracker.trigger($(evt.target).html(), 'selected');
                        }
                    }
                });
            }
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.liquidity.data('hook') === data.eventData.hook) {
                this.convertLiquidity(data.eventData.value);
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.liquidity.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    DynamicFixedComponent.prototype.convertLiquidity = function($val){
        switch($val){
            case 0: this.model.rateType = 0; break;
            case 10: this.model.rateType = 1; break;
            case 20: this.model.rateType = 2; break;
            case 30: this.model.rateType = 3; break;
            case 40: this.model.rateType = 4; break;
            case 50: this.model.rateType = 5; break;
            default: this.model.rateType = 0; break;
        }
    };

    DynamicFixedComponent.prototype.userSelection = function($selection){

        switch($selection){
            case 'dynamicFixed': this.model.investmentType = $selection; break;
            case 'primeLinked': this.model.investmentType = $selection; break;
            case '0': this.model.rateType = $selection; this.enableSlider(false); break;
            case '1': this.model.rateType = $selection; this.enableSlider(false); break;
            case '2': this.model.rateType = $selection; this.enableSlider(false); break;
            case '3': this.model.rateType = $selection; this.enableSlider(false); break;
            case '4': this.model.rateType = $selection; this.enableSlider(false); break;
            case '-1': this.model.rateType = $selection; this.enableSlider(true); break;
        }

        this.updateOutputs();
    };

    DynamicFixedComponent.prototype.closeDropdowns = function($current){
        _.forEach(this.$inputs.dropdownObj, function(element){
            if($current !== $(element)[0]){
                $(element)[0].drawer.removeClass('open');
            }
        });
    };

    DynamicFixedComponent.prototype.capitaliseString = function($str) {
        return $str.charAt(0).toUpperCase() + $str.slice(1);
    };

    DynamicFixedComponent.prototype.findMonthsAsDays = function($period) {
        return _.filter(this.$content.json.periods, function(section, key){
                          return key == $period;
               })[0];
    };

    DynamicFixedComponent.prototype.updateOutputs = function () {

        if (this.model.period !== -1){
            this.model.periodDays =  this.findMonthsAsDays(this.model.period);
        }

        if (this.model.amount !== 0 && this.model.period !== -1 && this.model.rateType !== -2){
            this.model.interestRate = this.runCalculations();
        }

        DynamicFixedComponent.bindOutputs(this.$outputs.raw, this.model.derived, false);
        DynamicFixedComponent.bindOutputs(this.$outputs.whole, this.model.derived, 0);
        DynamicFixedComponent.bindOutputs(this.$outputs.decimals, this.model.derived, 2);
    };

	DynamicFixedComponent.bindOutputs = function(outputs, model, decimals) {
         _.forEach(outputs, function(output, key) {
             var result = model[key];
             if (result < 0) {
                 result = 0;
             }
             if(decimals === false){
                 output.html(result);
             } else {
                 output.html(
                     currencyHelper.numberToCurrency(result, decimals)
                 );
             }
         });
	};

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.DynamicFixedComponent.push(new DynamicFixedComponent($el));
    };

    Cog.registerComponent({
        name: 'DynamicFixedComponent',
        api: api,
        selector: '.calculateDynamicFixed',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* jshint maxlen: 500 */
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculateRetirementAnnuities: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculateHomeLoan class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculateRetirementAnnuities($el) {
        this.$el = $el;
        var that = this;

        this.$inputs = {
            currency: {
                salary_gross: $el.find('[data-hook="input-salary_gross"]'),
                savings_total: $el.find('[data-hook="input-contributions_current"]'),
                savings_contributions: $el.find('[data-hook="input-contributions_monthly"]')
            },
            numeric: {
                salary_final: $el.find('[data-hook="input-salary_final"]'),
                retirement_length: $el.find('[data-hook="input-post_retirement"]')
            },
            range:{
                age_retirement: $el.find('[data-hook="input-retirement_age"]'),
                age_current: $el.find('[data-hook="input-current_age"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['age_retirement'] = $el.find('[data-hook="input-retirementAge"]');
            this.$inputs.numeric['age_current'] = $el.find('[data-hook="input-currentAge"]');
        }

        this.$outputs = {
            monthly_contributions: $el.find('[data-hook="output-monthly_contributions"]'),
            other_savings: $el.find('[data-hook="output-savings"]'),
            short_fall: $el.find('[data-hook="output-short_fall"]'),
            target: $el.find('[data-hook="output-target"]')
        };

        this.model = {
            salary_gross: 0,
            savings_total: 0,
            savings_contributions: 0,
            salary_final: 0,
            retirement_length: 0,
            age_retirement: 65,
            age_current: 30,
            monthly_contributions: 0,
            other_savings: 0,
            short_fall: 0,
            target: 0,
            inflation: 0.01,
            inflationRate: 0.06,
            absa_monthlyContributions: 500,
            avgRA_returns: 0.315558605002542,
            derived: {
                get monthly_contributions(){
                    if(that.model.derived.timeToRetirment <= 0 || that.model.retirement_length === 0){
                        return 0;
                    } else {
                        return currencyHelper.calcAnnuityPMT(that.model.derived.nominal_interest, (that.model.derived.timeToRetirment * 12), 0, that.model.derived.capitalShortfall) - that.model.absa_monthlyContributions;
                    }
                },

                get other_savings(){
                    if(that.model.retirement_length === 0) {
                        return 0;
                    }
                    else {
                        return currencyHelper.calcAnnuityPMT(0, (that.model.retirement_length * 12), that.model.derived.futureValueCombined);
                    }
                },

                get short_fall(){
                    return that.model.derived.target - that.model.derived.other_savings - that.model.derived.raContributionsAtRetirement;
                },

                get target(){
                    return that.model.derived.futureSalary * (that.model.salary_final / 100);
                },

                get futureSalary(){
                    return currencyHelper.calcAnnuityFutureValue(
                        that.model.inflation,
                        (that.model.derived.timeToRetirment),
                        0,
                        that.model.salary_gross);
                },

                get requiredFutureSalary(){
                    return that.model.derived.futureValueOfSalary * that.model.salary_final / 100;
                },

                get requiredToGetToFutureRetirementSalary(){
                    return currencyHelper.calcAnnuityPresentValue(0, (that.model.retirement_length * 12), that.model.derived.requiredFutureSalary);
                },

                get capitalShortfall(){
                    return that.model.derived.requiredToGetToFutureRetirementSalary - that.model.derived.futureValueCombined;
                },

                get timeToRetirment(){
                    var ageDiff = that.model.age_retirement - that.model.age_current;
                    return (ageDiff > 0)? ageDiff : 0;
                },

                get nominal_interest(){
                    return that.rates[that.model.derived.timeToRetirment].nominal_month / 100;
                },

                get futureValueOfSalary(){
                    return currencyHelper.calcAnnuityFutureValue(that.model.inflation, that.model.derived.timeToRetirment, 0, that.model.salary_gross);
                },

                get futureValueOfContributions(){
                    return currencyHelper.calcAnnuityFutureValue(
                        that.model.avgRA_returns / 100,
                        (that.model.derived.timeToRetirment * 12),
                        that.model.savings_contributions
                    );
                },

                get futureValueOfCurrentSavings(){
                    return currencyHelper.calcAnnuityFutureValue(
                        that.model.avgRA_returns / 100,
                        (that.model.derived.timeToRetirment * 12),
                        0,
                        that.model.savings_total
                    );
                },

                get futureValueCombined(){
                    return that.model.derived.futureValueOfContributions + that.model.derived.futureValueOfCurrentSavings;
                },

                get raFutureValue(){
                    return currencyHelper.calcAnnuityFutureValue(
                        that.model.derived.nominal_interest,
                        (that.model.derived.timeToRetirment * 12),
                        that.model.absa_monthlyContributions
                    );
                },

                get raContributionsAtRetirement(){
                    return currencyHelper.calcAnnuityPMT(
                        0,
                        (that.model.retirement_length * 12),
                        that.model.derived.raFutureValue
                    );
                }
            }
        };

        this.rates = {
            //year to retire : {'age', 'nominal monthly rate(%)'}

            75:  {age:0,    nominal_month:0.00},
            74:  {age:1,    nominal_month:0.710263462233285},
            73:  {age:2,    nominal_month:0.708957575650326},
            72:  {age:3,    nominal_month:0.707615220312063},
            71:  {age:4,    nominal_month:0.706234846904064},
            70:  {age:5,    nominal_month:0.704814817090238},
            69:  {age:6,    nominal_month:0.703353397025586},
            68:  {age:7,    nominal_month:0.701848750293488},
            67:  {age:8,    nominal_month:0.700298930206755},
            66:  {age:9,    nominal_month:0.698701871404639},
            65: {age:10,    nominal_month:0.697055380669531},
            64: {age:11,    nominal_month:0.695357126877627},
            63: {age:12,    nominal_month:0.693604629986355},
            62: {age:13,    nominal_month:0.691795248949623},
            61: {age:14,    nominal_month:0.689926168436594},
            60: {age:15,    nominal_month:0.687994384213853},
            59: {age:16,    nominal_month:0.685996687031176},
            58: {age:17,    nominal_month:0.683929644829018},
            57: {age:18,    nominal_month:0.681789583060333},
            56: {age:19,    nominal_month:0.679572562889308},
            55: {age:20,    nominal_month:0.677274356994961},
            54: {age:21,    nominal_month:0.674890422666596},
            53: {age:22,    nominal_month:0.672415871831222},
            52: {age:23,    nominal_month:0.66984543759645},
            51: {age:24,    nominal_month:0.667173436827051},
            50: {age:25,    nominal_month:0.664393728195578},
            49: {age:26,    nominal_month:0.661499665055265},
            48: {age:27,    nominal_month:0.65848404237383},
            47: {age:28,    nominal_month:0.655339036836566},
            46: {age:29,    nominal_month:0.652056139069734},
            45: {age:30,    nominal_month:0.648626076748671},
            44: {age:31,    nominal_month:0.645038727126623},
            43: {age:32,    nominal_month:0.641283017246863},
            42: {age:33,    nominal_month:0.637346809765704},
            41: {age:34,    nominal_month:0.633216771906309},
            40: {age:35,    nominal_month:0.628878224561702},
            39: {age:36,    nominal_month:0.624314967948081},
            38: {age:37,    nominal_month:0.619509079443792},
            37: {age:38,    nominal_month:0.614440678294925},
            36: {age:39,    nominal_month:0.609087650674556},
            35: {age:40,    nominal_month:0.603425327075713},
            34: {age:41,    nominal_month:0.597426102110044},
            33: {age:42,    nominal_month:0.592616818443359},
            32: {age:43,    nominal_month:0.587504181746556},
            31: {age:44,    nominal_month:0.582058554604203},
            30: {age:45,    nominal_month:0.576246308743289},
            29: {age:46,    nominal_month:0.571805898120714},
            28: {age:47,    nominal_month:0.567045920962173},
            27: {age:48,    nominal_month:0.56193059097025},
            26: {age:49,    nominal_month:0.556418571198369},
            25: {age:50,    nominal_month:0.550461854436346},
            24: {age:51,    nominal_month:0.54615736586503},
            23: {age:52,    nominal_month:0.541476273648134},
            22: {age:53,    nominal_month:0.536366891870288},
            21: {age:54,    nominal_month:0.530767623034412},
            20: {age:55,    nominal_month:0.524604462498868},
            19: {age:56,    nominal_month:0.52051502057493},
            18: {age:57,    nominal_month:0.515969048809239},
            17: {age:58,    nominal_month:0.510885579066223},
            16: {age:59,    nominal_month:0.505163293054789},
            15: {age:60,    nominal_month:0.498673700194718},
            14: {age:61,    nominal_month:0.494963290750539},
            13: {age:62,    nominal_month:0.490680175729552},
            12: {age:63,    nominal_month:0.485680668854793},
            11: {age:64,    nominal_month:0.479768630931043},
            10: {age:65,    nominal_month:0.472669130868741},
            9: {age:66,     nominal_month:0.469775159186581},
            8: {age:67,     nominal_month:0.466156404642537},
            7: {age:68,     nominal_month:0.46150161240659},
            6: {age:69,     nominal_month:0.455291529990642},
            5: {age:70,     nominal_month:0.446590313898887},
            4: {age:71,     nominal_month:0.446590313898887},
            3: {age:72,     nominal_month:0.446590313898887},
            2: {age:73,     nominal_month:0.446590313898887},
            1: {age:74,     nominal_month:0.446590313898887},
            0: {age:75,     nominal_month:0},
        };

        this.init();
    }

    CalculateRetirementAnnuities.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateRetirementAnnuities.prototype.setDefaultInputValues = function () {
        var that = this;

        that.model.retirement_length = that.$inputs.numeric.retirement_length.val();
        that.model.salary_final = that.$inputs.numeric.salary_final.val();
    };

    CalculateRetirementAnnuities.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
                this.updateRangeSlider(data);
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.age_retirement.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-retirement annuities calculator | retirement age';
                _satellite.track('genericUserInteraction');
            } else if (this.$inputs.range.age_current.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-retirement annuities calculator | current age';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateRetirementAnnuities.prototype.updateRangeSlider = function (data) {
        if (this.$inputs.range.age_retirement.data('hook') === data.eventData.hook) {
            this.model.age_retirement = data.eventData.value;
            this.updateOutputs();
        } else if (this.$inputs.range.age_current.data('hook') === data.eventData.hook) {
            this.model.age_current = data.eventData.value;
            this.updateOutputs();
        }
    };

    CalculateRetirementAnnuities.prototype.updateOutputs = function () {
        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateRetirementAnnuities.push(new CalculateRetirementAnnuities($el));
    };

    Cog.registerComponent({
        name: 'calculateRetirementAnnuities',
        api: api,
        selector: '.calculateRetirementAnnuities',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            calculateHomeLoan: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculateHomeLoan class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculateHomeLoan($el) {
        this.$el = $el;

        var that = this;

        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode'),
            this.$el.find('[data-hook="switch-icon"]').data('mode')
        ];

        // The currently active calculation mode
        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        this.modeDetails[this.modes[2]] = [
            this.$el.find('[data-hook="switch-chckbx"]'),
            this.$el.find('[data-hook="switch-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                income: $el.find('[data-hook="input-income"]'),
                price: $el.find('[data-hook="input-price"]'),
                bond: $el.find('[data-hook="input-bond"]'),
                deposit: $el.find('[data-hook="input-deposit"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            },
            extras: {
                vat: $el.find('[data-hook="content-vat"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$transferFeesSummary = $el.find('[data-hook="section-transfer_fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            afford: $el.find('[data-hook="output-amount"]'),
            repayment: $el.find('[data-hook="output-repayment"]'),
            repayment_absa: $el.find('[data-hook="output-repayment-absa"]'),
            premium: $el.find('[data-hook="output-premium"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest: $el.find('[data-hook="output-total_interest"]')
        };

        // Transfer cost calculation outputs
        this.$transferOutputs = {
            transferCostDeedsOffice: $el.find('[data-hook="output-transfer_fees-deeds_office"]'),
            transferCostConvFee: $el.find('[data-hook="output-transfer_fees-conv_fee"]'),
            transferCostNatural: $el.find('[data-hook="output-transfer_fees-cost_natural"]'),
            transferFees: $el.find('[data-hook="output-transfer_fees"]'),
            bondCostConvFee: $el.find('[data-hook="output-bond_cost-conv_fee"]'),
            bondCostDeedsOffice: $el.find('[data-hook="output-bond_cost-deeds_office"]'),
            bondCost: $el.find('[data-hook="output-bond_cost"]'),
            transferFeesTotal: $el.find('[data-hook="output-total_transfer"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$outputs.afford,
            this.$outputs.premium
        ];

        // Visible in mode 3
        this.modeStates[this.modes[2]] = [
            this.$inputs.currency.bond,
            this.$outputs.repayment_absa
        ];

        this.title = $el.find('[data-hook="output-heading"]');
        this.titles = {};
        this.titles[this.modes[0]] = 'See how much your dream home will cost';
        this.titles[this.modes[1]] = 'See what dream home you can unlock';
        this.titles[this.modes[2]] = 'See how much you could save by switching to ABSA';

        this.feesTitle = $el.find('[data-hook="output-total_transfer_text"]');
        this.feesTitles = {};
        this.feesTitles[this.modes[0]] = 'Total bond, transfer and initiation fees:';
        this.feesTitles[this.modes[1]] = 'Total bond, transfer and initiation fees:';
        this.feesTitles[this.modes[2]] = 'Total bond and initiation fees:';

        this.model = {
            income: 0,
            price: 0,
            bond: 0,
            deposit: 0,
            interest_rate: this.getInterestRateValueFromService() || 10.5,
            period: 20,
            vat: parseFloat(that.$inputs.extras.vat.html()) || 0.14,
            initiation_fee: 5250,
            attourneyDiscount: 30,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price;
                    } else if(that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.premium
                        );
                    } else if(that.mode === that.modes[2]) {
                        return that.model.bond;
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT (
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            -(that.model.price - that.model.deposit)
                        );
                    }
                },

                get afford(){
                    if (that.mode == that.modes[1]) {
                        return that.model.derived.amount;
                    }
                },

                get repayment_absa() {
                    return currencyHelper.calculatePMT(
                        that.model.interest_rate / (100 * 12),
                        that.model.period * 12,
                        -(that.model.derived.amount)
                    );
                },

                get minimum_income() {
                    return (that.model.derived.repayment * 10) / 3;
                },

                get premium() {
                    if (that.mode === that.modes[0]) {
                        return that.model.derived.repayment;
                    } else {
                        return Math.ceil(that.model.income * 0.3 * 100) / 100;
                    }
                },

                get total_repayment() {
                    if (that.mode === that.modes[0]) {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                    } else if(that.mode === that.modes[1]) {
                        return Math.ceil(that.model.derived.premium * (that.model.period * 12) * 100) / 100;
                    } else if(that.mode === that.modes[2]) {
                        return that.model.derived.repayment_absa * (that.model.period * 12);
                    }
                },

                get interest() {
                    if (that.mode === that.modes[0] || that.mode === that.modes[1]){
                        return Math.ceil((that.model.derived.total_repayment - that.model.derived.amount) * 100) / 100;
                    } else if(that.mode === that.modes[2]) {
                        return that.model.derived.total_repayment - that.model.derived.amount;
                    }
                },

                get initiationFee(){
                    if(that.model.derived.amount === 0){
                        return 0;
                    }

                    if(that.mode !== that.modes[2] || that.model.derived.amount < 500000){
                        // return that.model.initiation_fee;
                        return that.model.initiation_fee * (that.model.vat + 1);
                    } else {
                        return 0;
                    }
                }
            }
        };

        this.calculationModel = {

            get transferCostNatural() {
                if(that.mode !== that.modes[2]){

                    if (that.model.derived.amount <= 900000) {
                        return 0;
                    } else if (that.model.derived.amount > 900000 && that.model.derived.amount <= 1250000) {
                        return Math.max(((that.model.derived.amount - 900000) * (0.03)), 0);
                    } else if (that.model.derived.amount > 1250000 && that.model.derived.amount <= 1750000) {
                        return (((that.model.derived.amount  - 1250000) * (0.06)) + 10500);
                    } else if (that.model.derived.amount > 1750000 && that.model.derived.amount <= 2250000) {
                        return (((that.model.derived.amount - 1750000) * (0.08)) + 40500);
                    } else if (that.model.derived.amount > 2250000 && that.model.derived.amount <= 10000000) {
                        return (((that.model.derived.amount - 2250000) * (0.11)) + 80500);
                    } else if (that.model.derived.amount > 10000000) {
                        return (((that.model.derived.amount - 10000000) * (0.13)) + 933000);
                    }
                } else {
                    return 0;
                }
            },

            get transferCostConvFee() {
                var transferCostConv = 0;

                if(that.mode !== that.modes[2]){
                    for (var key in that.transferCostConvFeeModel) {
                        if (that.model.derived.amount > key) {
                            if (that.transferCostConvFeeModel[key] instanceof Function) {
                                transferCostConv = that.transferCostConvFeeModel[key]();
                            } else {
                                transferCostConv = that.transferCostConvFeeModel[key];
                            }
                        }
                    }
                }

                return transferCostConv;
            },

            get transferCostDeedsOffice() {
                var transferCostDeeds = 0;

                if(that.mode !== that.modes[2]){
                    for (var key in that.transferCostDeedsOfficeModel) {
                        if (that.model.derived.amount > key) {
                            transferCostDeeds = that.transferCostDeedsOfficeModel[key];
                        }
                    }
                }

                return transferCostDeeds;
            },

            get bondCostConvFee() {
                var bondCostConvFees = 0;

                for (var key in that.bondCostConversionFeeModel) {
                    if (that.model.derived.amount > key) {
                        if (that.bondCostConversionFeeModel[key] instanceof Function) {
                            bondCostConvFees = that.bondCostConversionFeeModel[key]();
                        } else {
                            bondCostConvFees = that.bondCostConversionFeeModel[key];
                        }
                    }
                }

                // added another check here to determine minu
                if(that.mode === that.modes[2] && that.model.derived.amount >= 500000){

                    if(that.calculationModel.attorneyFeeAndVat <= that.calculationModel.attorneyRebateTiers ){
                        bondCostConvFees = 0;
                    } else {
                        bondCostConvFees = (that.calculationModel.attorneyFeeAndVat -
                        that.calculationModel.attorneyRebateTiers) / (that.model.vat + 1);
                    }
                }
                return bondCostConvFees;
            },

            get attorneyFeeDiscount(){
                return (((100 - that.model.attourneyDiscount) / 100) *
                        (that.calculationModel.bondCostConvFeeChecker +
                         that.calculationModel.bondCostConvFeeChecker * that.model.vat)) / (that.model.vat + 1);
            },

            get attorneyFeeVAT(){
              return that.calculationModel.attorneyFeeDiscount * that.model.vat;
            },

            get attorneyFeeAndVat(){
                return that.calculationModel.attorneyFeeDiscount + that.calculationModel.attorneyFeeVAT;
            },

            get bondCostConvFeeChecker(){
                var bondCostConvFees = 0;

                for (var key in that.bondCostConversionFeeModel) {
                    if (that.model.derived.amount > key) {
                        if (that.bondCostConversionFeeModel[key] instanceof Function) {
                            bondCostConvFees = that.bondCostConversionFeeModel[key]();
                        } else {
                            bondCostConvFees = that.bondCostConversionFeeModel[key];
                        }
                    }
                }

                return bondCostConvFees;
            },

            get attorneyRebateTiers() {
                var rebate = 10000;

                for (var key in that.attorneyRebateTiersModel) {
                    if (that.model.bond >= key) {
                        rebate = that.attorneyRebateTiersModel[key];
                    }
                }
                return rebate;
            },

            get bondCostDeedsOffice() {
                var bondCostDeeds = 0;

                for (var key in that.bondCostDeedsOfficeModel) {
                    if (that.model.derived.amount > key) {
                        bondCostDeeds = that.bondCostDeedsOfficeModel[key];
                    }
                }

                return bondCostDeeds;
            },

            bondCostPostPetties: 0,
            get transferFees() {
                return (
                        that.calculationModel.transferCostConvFee +
                        that.calculationModel.transferCostDeedsOffice +
                        (that.calculationModel.transferCostConvFee * that.model.vat)
                );
            },

            get VAT(){

                var vat = Math.round(that.calculationModel.bondCostConvFeeChecker * that.model.vat);

                if(that.mode !== that.modes[2]){
                    return vat;
                } else {
                    if(that.model.derived.amount < 500000){
                        return vat;
                    } else if(that.calculationModel.attorneyFeeAndVat > 10000) {
                        return that.calculationModel.bondCostConvFee * that.model.vat;
                    } else {
                        return 0;
                    }
                }
            },

            get bondCost() {
                return (that.calculationModel.bondCostConvFee +
                            that.calculationModel.bondCostDeedsOffice +
                            that.calculationModel.bondCostPostPetties +
                            that.calculationModel.VAT);
            },

            get transferFeesTotal() {
                return(
                    that.calculationModel.bondCost +
                    that.calculationModel.transferFees +
                    that.calculationModel.transferCostNatural +
                    that.model.derived.initiationFee
                );
            }
        };

        this.bondCostConversionFeeModel = {
            0: 4800,
            100000: function () {
                        return (4800 + (735 * Math.ceil((this.model.derived.amount - 100000) / 50000)));
                    }.bind(this),
            500000: function () {
                        return (10680 + (1470 * Math.ceil((this.model.derived.amount - 500000) / 100000)));
                    }.bind(this),
            1000000: function () {
                         return (18030 + (735 * Math.ceil((this.model.derived.amount - 1000000) / 100000)));
                     }.bind(this),
            5000000: function () {
                         return (47430 + (370 * Math.ceil((this.model.derived.amount - 5000000) / 100000)));
                     }.bind(this)
        };

        this.transferCostConvFeeModel = {
            0: 4800,
            100000: function () {
                        return (4800 + (735 * Math.ceil((this.model.derived.amount - 100000) / 50000)));
                    }.bind(this),
            500000: function () {
                        return (10680 + (1470 * Math.ceil((this.model.derived.amount - 500000) / 100000)));
                    }.bind(this),
            1000000: function () {
                         return (18030 + (735 * Math.ceil((this.model.derived.amount - 1000000) / 100000)));
                     }.bind(this),
            5000000: function () {
                         return (47430 + (370 * Math.ceil((this.model.derived.amount - 5000000) / 100000)));
                     }.bind(this)
        };

        // Transfer Cost for Deeds Office
        // Do NOT edit model.derived.amount()
        // Only edit TrDO_TransferCostDeedsOffice
        this.transferCostDeedsOfficeModel = {
            0: 35,
            100000: 75,
            200000: 465,
            300000: 580,
            600000: 815,
            800000: 930,
            1000000: 1050,
            2000000: 1275,
            4000000: 1750,
            6000000: 2100,
            8000000: 2455,
            10000000: 2920,
            15000000: 3505,
            20000000: 4675
        };

        this.bondCostDeedsOfficeModel = {
            0: 360,
            150000: 400,
            300000: 580,
            600000: 810,
            800000: 935,
            1000000: 1050,
            2000000: 1456,
            4000000: 1765,
            6000000: 2100,
            8000000: 2455,
            10000000: 2923,
            15000000: 3510,
            20000000: 4090,
            30000000: 5845
        };

        this.attorneyRebateTiersModel = {
            0: 10000,
            2500000: 20000,
            4500000: 30000
        };

        this.init();
    }

    CalculateHomeLoan.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoan.prototype.setDefaultInputValues = function () {
        this.$inputs.numeric.interest_rate.val(this.model.interest_rate);
    };

    CalculateHomeLoan.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric

        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        // Other

        that.$subMenu.on('click', function () {
            var $this = $(this);
            $this.toggleClass('active');
            that.$transferFeesSummary.toggleClass('active');
        });

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        // Dispatcher events for child components

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoan.prototype.toggleMode = function ($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = element.parent().parent();
                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.title.html(that.titles[$key]);
        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');

        that.feesTitle.html(that.feesTitles[$key]);
    };

    CalculateHomeLoan.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
            attributes = attributes.replace(new RegExp(this.modes[2], 'g'), this.modes[0]);
        }
        else if(this.mode == this.modes[1]){
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
            attributes = attributes.replace(new RegExp(this.modes[2], 'g'), this.modes[1]);
        }
        else if(this.mode == this.modes[2]){
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[2]);
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[2]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoan.prototype.getInterestRateValueFromService = function () {
        return this.$el.find('.interest-rate-value').data('interest');
    };

    CalculateHomeLoan.prototype.updateOutputs = function () {
        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
        calculatorHelper.bindOutputs(this.$transferOutputs, this.calculationModel);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoan.push(new CalculateHomeLoan($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoan',
        api: api,
        selector: '.calculateHomeLoan',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            calculateVehicleFinance: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculateVehicleFinance class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculateVehicleFinance($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price: $el.find('[data-hook="input-price"]'),
                repayment: $el.find('[data-hook="input-repayment"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                insurance: $el.find('[data-hook="input-insurance"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="vehicle-finance-period"]'),
                residual: $el.find('[data-hook="vehicle-finance-residual"]')
            },
            contentVars: {
                service:  $el.find('[data-hook="content-servicefee"]'),
                initiation:  $el.find('[data-hook="content-initiation"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.currency['residual'] = $el.find('[data-hook="input-residual"]');
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        // The range slider progress tab needs custom data injection for residual payments
        this.$residualTab = $el.find('[data-hook="residual-tab"]');


        // Calculation outputs
        this.$outputs = {
            actual_repayment: $el.find('[data-hook="output-actual_repayment"]'),
            price: $el.find('[data-hook="output-price"]'),
            interest: $el.find('[data-hook="output-interest"]'),
            residual: $el.find('[data-hook="output-residual_initial"]')
            //affordability: $el.find('[data-hook="output-affordability"]')
        };

        // Buttons to toggle additional products
        this.$extras = {
            container: $el.find('[data-hook="extras"]'),
            toggler: $el.find('[data-hook="extras-toggler"]'),
            content: $el.find('[data-hook="extras-content"]'),
            credit: {
                circle: $el.find('.calculateVehicleFinance-products-credit .calculateVehicleFinance-product-circle')
            },
            warranty: {
                circle: $el.find('.calculateVehicleFinance-products-warranty .calculateVehicleFinance-product-circle')
            },
            extended: {
                circle: $el.find('.calculateVehicleFinance-products-extended .calculateVehicleFinance-product-circle')
            },
            outputs: {
                credit: {
                    A: $el.find('[data-hook="credit-A"]'),
                    B: $el.find('[data-hook="credit-B"]'),
                    C: $el.find('[data-hook="credit-C"]'),
                    D: $el.find('[data-hook="credit-D"]'),
                    Taxi: $el.find('[data-hook="credit-Taxi"]'),
                    Platinum: $el.find('[data-hook="credit-Platinum"]')
                },
                warranty: {
                    '1y': $el.find('[data-hook="warranty-1y"]'),
                    '1y_ext': $el.find('[data-hook="warranty-1y_ext"]'),
                    '1y_2': $el.find('[data-hook="warranty-1y_2"]'),
                    '2y': $el.find('[data-hook="warranty-2y"]'),
                    '2y_ext': $el.find('[data-hook="warranty-2y_ext"]'),
                    '2y_2': $el.find('[data-hook="warranty-2y_2"]')
                },
                extended: {
                    'cover': $el.find('[data-hook="product-extended-cover"]')
                }
            }
        };

        this.tooltips = $el.find('.calculator-tip');

        this.model = {
            price: 0,
            repayment: 0,
            deposit: 0,
            interest_rate: this.getInterestRateValueFromService() || 10.5,
            period: 72,
            residual: 0,
            initiation_fee: parseFloat(that.$inputs.contentVars.initiation.html()) || 1197,
            service_fee: parseFloat(that.$inputs.contentVars.service.html()) || 68.4,
            insurance: 0,
            derived: {
                get price() {
                    if (that.model.price === 0) {
                        return 0;
                    } else {
                        /* return that.model.price - that.model.deposit +
                            that.model.initiation_fee +
                           that.model.extras.warranty;*/
                        return that.model.price -
                            that.model.deposit +
                            that.model.initiation_fee +
                            that.model.extras.warranty;
                    }
                },

                get total_price() {
                    return that.model.derived.actual_repayment * that.model.period + that.model.derived.residual;
                },

                get actual_repayment() {
                    if (that.model.price === 0) {
                        return 0;
                    } else {

                        // Possibly updating calculatePMT, but need to investigate impact
                        var newCalc = currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period,
                            that.model.derived.price * -1,
                            that.model.derived.residual
                        ) + that.model.service_fee;

                        // var newTotal = newCalc +
                        //     that.model.extras.credit +
                        //     that.model.extras.extended +
                        //     that.model.insurance;

                        return newCalc;
                    }
                },

                get residual() {
                    return ((that.model.residual / 100) * that.model.derived.price);
                },

                get interest() {
                    return that.model.derived.total_price - that.model.derived.price;
                }
            },

            extras: {
                credit: 0,
                creditPlan: 0,
                warranty: 0,
                extended: 0,
                maps: {
                    credit: {
                        'A': 1.20,
                        'B': 1.30,
                        'C': 1.70,
                        'D': 1.90,
                        'Taxi': 2.20,
                        'Platinum': 1.50
                    },
                    warranty: {
                        '1y': 5710,
                        '1y_ext': 6290,
                        '1y_2': 5080,
                        '2y': 6960,
                        '2y_ext': 7515,
                        '2y_2': 5900
                    },
                     extended: {
                        0: 55,
                        15000: 58,
                        20000: 60,
                        25000: 62,
                        30000: 66,
                        35000: 68,
                        40000: 70,
                        45000: 73,
                        50000: 75,
                        55000: 78,
                        60000: 81,
                        65000: 83,
                        70000: 85,
                        75000: 89,
                        80000: 92,
                        85000: 94,
                        90000: 98,
                        95000: 101,
                        100000: 105,
                        110000: 107,
                        120000: 111,
                        130000: 113,
                        140000: 114,
                        150000: 116,
                        160000: 119,
                        170000: 122,
                        180000: 124,
                        190000: 127,
                        200000: 130,
                        210000: 134,
                        220000: 137,
                        230000: 140,
                        240000: 143,
                        250000: 146,
                        260000: 150,
                        270000: 153,
                        280000: 157,
                        290000: 160,
                        300000: 162,
                        310000: 166,
                        320000: 169,
                        330000: 173,
                        340000: 176,
                        350000: 178,
                        360000: 182,
                        370000: 185,
                        380000: 189,
                        390000: 192,
                        400000: 196,
                        410000: 198,
                        420000: 201,
                        430000: 205,
                        440000: 208,
                        450000: 212,
                        460000: 214,
                        470000: 217,
                        480000: 221,
                        490000: 224,
                        500000: 228,
                        510000: 232,
                        520000: 236,
                        530000: 239,
                        540000: 244,
                        550000: 247,
                        560000: 251,
                        570000: 255,
                        580000: 259,
                        590000: 263,
                        600000: 267,
                        610000: 270,
                        620000: 275,
                        630000: 278,
                        640000: 283,
                        650000: 286,
                        660000: 290,
                        670000: 295,
                        680000: 298,
                        690000: 301,
                        700000: 306,
                        710000: 309,
                        720000: 314,
                        730000: 318,
                        740000: 321,
                        750000: 325,
                        760000: 329,
                        770000: 333,
                        780000: 337,
                        790000: 341,
                        800000: 345,
                        810000: 349,
                        820000: 352,
                        830000: 356,
                        840000: 360,
                        850000: 364,
                        860000: 368,
                        870000: 372,
                        880000: 376,
                        890000: 380,
                        900000: 384,
                        910000: 388,
                        920000: 391,
                        930000: 395,
                        940000: 399,
                        950000: 403,
                        960000: 407,
                        970000: 411,
                        980000: 415,
                        990000: 419
                    }
                }
            }
        };

        this.init();
    }

    CalculateVehicleFinance.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
        }
    };

    CalculateVehicleFinance.prototype.setDefaultInputValues = function () {
        // Late request to make the default interest rate 'prime + 2%'
        this.model.interest_rate = this.model.interest_rate + 2;
        this.$inputs.numeric.interest_rate.val(this.model.interest_rate);
    };

    CalculateVehicleFinance.prototype.calcCredit = function(plan) {
        return this.model.derived.price * this.model.extras.maps.credit[plan] / 1000;
    };

    CalculateVehicleFinance.prototype.bindUIEvents = function () {
        var that = this;

        // Bind inputs to associated model fields
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model
        );

        this.$extras.credit.circle.on('click', function () {
            var $this = $(this);

            if ($this.hasClass('active')) {
                that.$extras.credit.circle.removeClass('active');
                that.model.extras.credit = 0;
                that.model.extras.creditPlan = 0;
            } else {
                that.$extras.credit.circle.removeClass('active');
                $this.addClass('active');
                that.model.extras.creditPlan = $this.data('plan');
            }
            that.updateOutputs();
        });

        this.$extras.warranty.circle.on('click', function () {
            var $this = $(this);

            if ($this.hasClass('active')) {
                that.$extras.warranty.circle.removeClass('active');
                that.model.extras.warranty = 0;
            } else {
                that.$extras.warranty.circle.removeClass('active');
                $this.addClass('active');
                that.model.extras.warranty = that.model.extras.maps.warranty[$this.data('option')];
            }
            that.updateOutputs();
        });

        this.$extras.extended.circle.on('click', function () {
            var $this = $(this);

            $this.toggleClass('active');
            if (that.model.extras.extended === 0) {
                for (var c in that.model.extras.maps.extended) {
                    if (that.model.derived.price > c) {
                        that.model.extras.extended = that.model.extras.maps.extended[c];
                    }
                }
            } else {
                that.model.extras.extended = 0;
            }
            that.updateOutputs();
        });

        this.$extras.toggler.on('click', function () {
            that.$extras.container.toggleClass('active');
        });

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        Cog.addListener('calculatorToggler', 'switched', function (data) {
            this.mode = data.eventData;
            this.toggleMode();
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            this.updateRangeSlider(data);
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            this.updateRangeSlider(data);

            if(this.$inputs.range.period.data('hook') === data.eventData.hook){
                dataLayer.siteEvents = 'tools_Tools-vehicle finance calculator | payment terms';
            }
            else if(this.$inputs.range.residual.data('hook') === data.eventData.hook){
                dataLayer.siteEvents = 'tools_Tools-vehicle finance calculator | balloon payment';
            }
            _satellite.track('genericUserInteraction');
        }.bind(this));

        that.updateOutputs();
    };

    CalculateVehicleFinance.prototype.updateRangeSlider = function (data) {
        if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
            this.model.period = data.eventData.value;
            this.updateOutputs();
        } else if (this.$inputs.range.residual.data('hook') === data.eventData.hook) {
            this.model.residual = data.eventData.value;
            var residualAmount = currencyHelper.numberToCurrency(this.model.derived.residual);
            var tabString = this.model.residual;
            tabString += '% / R ' + residualAmount;
            this.$residualTab.html(tabString);
            this.updateOutputs();
        }
    };

    CalculateVehicleFinance.prototype.getInterestRateValueFromService = function () {
        return this.$el.find('.interest-rate-value').data('interest');
    };

    CalculateVehicleFinance.prototype.updateOutputs = function () {
        var that = this;
        //var result = 0;

        // Since the extras are essential to the calculations, we need to do them first
        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
        //calculatorHelper.bindOutputs(this.$extras.outputs.warranty, this.model.extras.maps.warranty);

        // Credit products need custom output bindings
        _.forEach(that.$extras.outputs.credit, function(output, key) {
            var result = that.calcCredit(key);
            if (result < 0) {
                result = 0;
            }

            if(that.model.extras.creditPlan == key) {
                that.model.extras.credit = that.calcCredit(key);
            }

            result = currencyHelper.numberToCurrency(result);
            output.html(result);
        });

        _.forEach(that.$extras.outputs.extended, function(output) {
            var result = 0;
            for (var c in that.model.extras.maps.extended) {
                if (that.model.derived.price > c) {
                    result = that.model.extras.maps.extended[c];
                }
            }
            result = currencyHelper.numberToCurrency(result);
            output.html(result);
        });

        // And one more time to ensure we are using the correct totals
        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
        calculatorHelper.bindOutputs(this.$extras.outputs.warranty, this.model.extras.maps.warranty);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        browser = this.external.browser;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        api.calculateVehicleFinance.push(new CalculateVehicleFinance($el));
    };

    Cog.registerComponent({
        name: 'calculateVehicleFinance',
        api: api,
        selector: '.calculateVehicleFinance',
        requires: [
            {
                name: 'utils.status',
                apiId: 'status'
            }, {
                name: 'utils.browser',
                apiId: 'browser'
            }, {
                name: 'utils.currencyHelper',
                apiId: 'currencyHelper'
            }, {
                name: 'utils.calculatorHelper',
                apiId: 'calculatorHelper'
            }
        ]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';


    var api = {
            calculateHomeLoanBotswana: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanBotswana class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanBotswana($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };


        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 1000000,
            deposit:  100000,
            interest_rate: 10,
            period: 25,
            vat: 1.14,
            maxDSR: 0.50,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }
                    return that.model.derived.amount * 0.0112;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
                        return that.model.derived.amount * 0.0035;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanBotswana.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanBotswana.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanBotswana.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanBotswana.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.1;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanBotswana.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanBotswana.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanBotswana.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanBotswana.push(new CalculateHomeLoanBotswana($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanBotswana',
        api: api,
        selector: '.calculateHomeLoanBotswana',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            calculateHomeLoanKenya: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanKenya class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculateHomeLoanKenya($el) {
        this.$el = $el;

        var that = this;

        // The currently active calculation mode

        this.modes = [
            this.$el.find('[data-hook="toggler-switch-base_1"]').data('mode'),
            this.$el.find('[data-hook="toggler-switch-base_2"]').data('mode')
        ];

        this.mode = this.modes[0];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                income: $el.find('[data-hook="input-income"]'),
                expenses: $el.find('[data-hook="input-expenses"]'),
                price: $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$transferFeesSummary = $el.find('[data-hook="section-transfer_fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            amount: $el.find('[data-hook="output-amount"]'),
            repayment: $el.find('[data-hook="output-repayment"]'),
            premium: $el.find('[data-hook="output-premium"]'),
            minimum_income: $el.find('[data-hook="output-minimum_income"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest: $el.find('[data-hook="output-total_interest"]')
        };

        // Transfer cost calculation outputs
        this.$transferOutputs = {
            transferFees: $el.find('[data-hook="output-transfer_fees"]'),
            valuation: $el.find('[data-hook="output-valuation"]'),
            legalFee: $el.find('[data-hook="output-legal_fee"]'),
            initiationFee: $el.find('[data-hook="output-initiation_fee"]'),
            transferTransferStampDuty: $el.find('[data-hook="output-transfer_stamp-duty"]'),
            transferChargeStampDuty: $el.find('[data-hook="output-charge_stamp-duty"]'),
            annualFee: $el.find('[data-hook="output-annual_fee"]'),
            fireInsurance: $el.find('[data-hook="output-fire_insurance"]'),
            morgageProtection: $el.find('[data-hook="output-morgage_protection"]'),
            transferFeesTotal: $el.find('[data-hook="output-total_duty_legal_valuation_insurance"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.deposit,
            this.$inputs.currency.price,
            this.$outputs.minimum_income,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.expenses,
            this.$outputs.amount,
            this.$outputs.premium
        ];

        this.model = {
            income: 0,
            expenses: 0,
            price: 0,
            deposit: 0,
            interest_rate: 14.50,
            period: 20,
            vat: 1.14,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price;
                    } else {
                        /*return currencyHelper.calcFutureValue(
                            that.model.derived.premium,
                            that.model.interest_rate / 100,
                            that.model.period * 12
                          );*/
                        return currencyHelper.calculatePresentValue(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.premium
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        /*return currencyHelper.calcMonthlyPayments(
                            that.model.price - that.model.deposit,
                            that.model.interest_rate / 100,
                            that.model.period * 12
                        );*/
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            -(that.model.price + that.model.deposit)
                        );

                    } else {
                        return that.model.income - that.model.expenses;
                    }
                },

                get minimum_income() {
                    return (that.model.derived.repayment * 10) / 3;
                },

                get premium() {
                    if (that.mode == that.modes[0]) {
                        return that.model.derived.repayment;
                    } else {
                        return Math.ceil(that.model.derived.repayment * that.model.derived.getMaxDSR * 100) / 100;
                    }
                },

                get total_repayment() {
                    if (that.mode == that.modes[0]) {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                    } else {
                        return Math.ceil(that.model.derived.premium * (that.model.period * 12) * 100) / 100;
                    }

                },

                get interest() {
                    if (that.mode == that.modes[0]) {
                        return Math.ceil((that.model.derived.total_repayment - that.model.derived.amount) * 100) / 100;
                    } else {
                        return Math.ceil(that.model.derived.total_repayment - that.model.derived.amount);
                    }
                },

                get getMaxDSR() {
                    var dsr = 0;
                    for (var key in that.debtServiceRation) {
                        if (that.model.income > key) {
                            if (that.debtServiceRation[key] instanceof Function) {
                                dsr = that.debtServiceRation[key]();
                            } else {
                                dsr = that.debtServiceRation[key];
                            }
                        }
                    }
                    return dsr;
                }
            }
        };

        this.calculationModel = {

            get transferFees(){
                return that.calculationModel.valuation +
                    that.calculationModel.transferTransferStampDuty +
                    that.calculationModel.transferChargeStampDuty +
                    that.calculationModel.legalFee;
            },
            get valuation(){
                return that.model.derived.amount * 0.0025;
            },
            get transferTransferStampDuty(){
                return that.model.derived.amount * 0.04;
            },
            get transferChargeStampDuty(){
                return that.model.derived.amount * 0.001;
            },
            get legalFee(){
                return that.model.derived.amount * 0.0125;
            },
            get initiationFee(){
                return that.model.derived.amount * 0.0105;
            },
            get annualFee(){
                return that.calculationModel.fireInsurance + that.calculationModel.morgageProtection;
            },
            get fireInsurance(){
                return that.model.derived.amount * 0.00125;
            },
            get morgageProtection(){
                return that.model.derived.amount * 0.003;
            },
            get transferFeesTotal(){
                // probably needs an update
                return that.calculationModel.transferFees + that.calculationModel.annualFee;
            },
        };

        this.debtServiceRation = {
            0 : 0.4,
            100000 : 0.57,
            500000 : 0.67
        };

        this.init();
    }

    CalculateHomeLoanKenya.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanKenya.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanKenya.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric

        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        // Other

        that.$subMenu.on('click', function () {
            var $this = $(this);
            $this.toggleClass('active');
            that.$transferFeesSummary.toggleClass('active');
        });

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        // Dispatcher events for child components

        Cog.addListener('calculatorToggler', 'switched', function (data) {
            this.mode = data.eventData;
            this.toggleMode();
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
       }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanKenya.prototype.toggleMode = function () {
        var that = this;

        _.forEach(that.modeStates[that.modes[0]], function(element) {
            var parent = element.parent().parent();
            if(that.modes[0] === that.mode){
                parent.removeClass('disabled');
            }else{
                parent.addClass('disabled');
            }
        });

        _.forEach(that.modeStates[that.modes[1]], function(element) {
            var parent = element.parent().parent();
            if(that.modes[1] === that.mode){
                parent.removeClass('disabled');
            }else{
                parent.addClass('disabled');
            }
        });


        that.toggleTracking();
        this.updateOutputs();
    };

    CalculateHomeLoanKenya.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }
    };

    CalculateHomeLoanKenya.prototype.updateOutputs = function () {
        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
        calculatorHelper.bindOutputs(this.$transferOutputs, this.calculationModel);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanKenya.push(new CalculateHomeLoanKenya($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanKenya',
        api: api,
        selector: '.calculateHomeLoanKenya',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            calculateHomeLoanMauritius: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanKenya class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculateHomeLoanMauritius($el) {
        this.$el = $el;

        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            },
            radio: {
                salary: $el.find('[data-hook="input-salary"]')
            }
        };

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest: $el.find('[data-hook="output-total_interest"]')
        };

        // Transfer cost calculation outputs
        this.$fees = {
            facilityFee: $el.find('[data-hook="output-transfer_facility"]'),
            registrationAndStampDuty: $el.find('[data-hook="output-registration_stamp_duty"]'),
            valuationFee: $el.find('[data-hook="output-valuation"]'),
            securityFees: $el.find('[data-hook="output-security"]'),
            totalFees: $el.find('[data-hook="output-total_fees"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.radio.salary,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 8000,
            commitments: 0,
            price: 500000,
            deposit: 0,
            interest_rate_PLR: 6.25,
            //interest_rate: 7.25,
            period: 30,
            vat: 1.14,
            segment: 'personal',
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price;
                    } else {
                        return that.model.income;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        that.setInterestRate(that.model.derived.affordCalc);
                        return that.model.derived.affordCalc;
                    }
                },

                get affordCalc(){
                    return currencyHelper.calculatePresentValue(
                        (that.model.interest_rate / 100) / 12,
                        that.model.period * 12,
                        that.model.derived.getMaxDSR - that.model.commitments
                    );
                },

                get segment(){
                    if(that.mode == that.modes[0]){
                        return that.model.segment;
                    } else {
                        if(that.model.income < 30000){
                            return 'personal';
                        } else if(that.model.income < 150000 && that.model.income >= 30000) {
                            return 'prestige';
                        } else {
                            return 'premier';
                        }
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.price * -1
                        );
                    } else {
                        return that.model.income - that.model.commitments;
                    }
                },

                get total_repayment() {
                    if (that.mode == that.modes[0]) {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                    } else {
                        return Math.ceil(that.model.derived.getMaxDSR * (that.model.period * 12) * 100) / 100;
                    }

                },

                get interest() {
                    if (that.mode == that.modes[0]) {
                        return Math.ceil(that.model.derived.total_repayment - that.model.derived.amount);
                    } else {
                        return Math.ceil(that.model.derived.total_repayment - that.model.derived.afford);
                    }
                },

                get getMaxDSR() {
                    if(that.model.derived.amount < 200000) {
                        return 0.4 * that.model.derived.amount;
                    } else {
                        return 0.5 * that.model.derived.amount;
                    }
                }
            }
        };

        this.calculationModel = {

            get facilityFee(){
                if(that.model.derived.amount <= 0) {
                    return 0;
                }

                var calc = that.model.derived.amount * 0.01;

                if(calc <= 5000){ calc = 5000; }
                if(calc > 50000){ calc = 50000;}

                return calc;
            },
            get registrationFee(){
                if(that.model.derived.amount <= 0){
                    return 0;
                }

                var val = that.model.derived.amount, result = 0;

                if(val <= 300000){
                    result = 1000;
                } else if(val > 300000 && val <= 500000) {
                    result = 3000;
                } else if(val > 500000 && val <= 1000000) {
                    result = 10000;
                } else if(val > 1000000 && val <= 5000000) {
                    result = 30000;
                } else {
                    result = 50000;
                }

                return result;
            },
            get stampDutyFee(){
                if(that.model.derived.amount <= 0){
                    return 0;
                } else {
                    return 2400;
                }
            },
            get registrationAndStampDuty(){
                return that.calculationModel.registrationFee + that.calculationModel.stampDutyFee;
            },
            get valuationFee(){
                if(that.model.derived.amount <= 0) {
                    return 0;
                } else {
                    return 7000;
                }
            },
            get securityFees(){
                if(that.model.derived.amount <= 0){
                    return 0;
                } else {
                    return 1500;
                }
            },
            get totalFees(){
                return that.calculationModel.facilityFee +
                    that.calculationModel.registrationAndStampDuty +
                    that.calculationModel.valuationFee +
                    that.calculationModel.securityFees;
            }
        };

        this.interestRate = {
            lessThanBar:  {
                personal : +1,
                prestige : +0.2,
                premier : -0.15
            },
            moreThanBar: {
                personal : -0.6,
                prestige : -1.3,
                premier : -1.45
            }
        };

        this.init();
    }

    CalculateHomeLoanMauritius.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
            this.bindOutputs();
        }
    };

    CalculateHomeLoanMauritius.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate_PLR = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate.toFixed(2));
        }
    };

    CalculateHomeLoanMauritius.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
            //this.updateOutputs.bind(this)
        );

        // --- numeric

        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        // Other

        that.$subMenu.on('click', function () {
            var $this = $(this);
            $this.toggleClass('active');
            that.$totalFeesSummary.toggleClass('active');
        });

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        // Dispatcher events for child components
        this.$inputs.radio.salary.on('change', function (event) {
            this.model.segment = event.target.value;
            //this.setInterestRate(this.model.derived.amount);
            this.updateOutputs();
            }.bind(this));

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanMauritius.prototype.setInterestRate = function(amount){

        if(amount < 1000000){
            this.model.interest_rate = (this.model.interest_rate_PLR +
                                        this.interestRate.lessThanBar[this.model.derived.segment]);

        } else if(amount >= 1000000){
            this.model.interest_rate = (this.model.interest_rate_PLR +
                                        this.interestRate.moreThanBar[this.model.derived.segment]);
        }

        this.$inputs.numeric.interest_rate.val(this.model.interest_rate.toFixed(2));
    };

    CalculateHomeLoanMauritius.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanMauritius.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanMauritius.prototype.updateOutputs = function () {
        this.setInterestRate(this.model.derived.amount);

        this.bindOutputs(this.$outputs, this.model.derived);
        calculatorHelper.bindOutputs(this.$fees, this.calculationModel);
    };

    CalculateHomeLoanMauritius.prototype.bindOutputs = function(outputs, model) { //changed
        _.forEach(outputs, function(output, key) {
            var result = model[key];
            if (result < 0) {
                result = 0;
            }
            var twodec = Math.ceil(result*100)/100;
            output.html(
                currencyHelper.numberToCurrency(twodec, true)
            );
        });
   };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanMauritius.push(new CalculateHomeLoanMauritius($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanMauritius',
        api: api,
        selector: '.calculateHomeLoanMauritius',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';


    var api = {
            calculateHomeLoanMozambique: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanMozambique class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanMozambique($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 30000000,
            deposit: 6000000,
            interest_rate: 19,
            period: 25,
            vat: 1.14,
            maxDSR: 0.45,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }

                    return that.model.derived.amount * 0.02;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
                        return that.model.derived.amount * 0.0015;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanMozambique.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanMozambique.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanMozambique.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanMozambique.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.2;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanMozambique.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanMozambique.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }
    };

    CalculateHomeLoanMozambique.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanMozambique.push(new CalculateHomeLoanMozambique($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanMozambique',
        api: api,
        selector: '.calculateHomeLoanMozambique',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';


    var api = {
            calculateHomeLoanNBCTanzania: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculateHomeLoanNBCTanzania class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanNBCTanzania($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 1000000,
            deposit: 200000,
            interest_rate: 0.18,
            period: 25,
            vat: 1.14,
            maxDSR: 0.50,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }

                    return that.model.derived.amount * 0.02;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
                        return that.model.derived.amount * 0.0015;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanNBCTanzania.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanNBCTanzania.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanNBCTanzania.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanNBCTanzania.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.2;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanNBCTanzania.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanNBCTanzania.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanNBCTanzania.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanNBCTanzania.push(new CalculateHomeLoanNBCTanzania($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanNBCTanzania',
        api: api,
        selector: '.calculateHomeLoanNBCTanzania',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';


    var api = {
            calculateHomeLoanSeychelles: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanSeychelles class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanSeychelles($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 1000000,
            deposit: 200000,
            interest_rate: 0.9,
            period: 25,
            vat: 1.14,
            maxDSR: 0.45,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }

//                    return that.model.derived.amount * 0.02;
                    return 4000;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
//                        return that.model.derived.amount * 0.0015;
                        return 5000;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanSeychelles.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanSeychelles.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanSeychelles.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanSeychelles.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.2;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanSeychelles.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanSeychelles.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanSeychelles.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanSeychelles.push(new CalculateHomeLoanSeychelles($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanSeychelles',
        api: api,
        selector: '.calculateHomeLoanSeychelles',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';


    var api = {
            calculateHomeLoanTanzania: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanTanzania class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanTanzania($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 0,
            deposit: 0,
            interest_rate: 18,
            period: 25,
            vat: 1.14,
            maxDSR: 0.50,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }

                    return that.model.derived.amount * 0.01;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
                        return that.model.derived.amount * 0.0035;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanTanzania.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanTanzania.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanTanzania.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanTanzania.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.2;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanTanzania.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanTanzania.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanTanzania.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanTanzania.push(new CalculateHomeLoanTanzania($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanTanzania',
        api: api,
        selector: '.calculateHomeLoanTanzania',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            calculateHomeLoanUganda: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanUganda class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanUganda($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 30000000,
            deposit: 6000000,
            interest_rate: 19,
            period: 25,
            vat: 1.14,
            maxDSR: 0.45,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }

                    return that.model.derived.amount * 0.02;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
                        return that.model.derived.amount * 0.0015;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanUganda.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanUganda.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanUganda.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanUganda.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.2;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanUganda.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanUganda.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanUganda.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanUganda.push(new CalculateHomeLoanUganda($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanUganda',
        api: api,
        selector: '.calculateHomeLoanUganda',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global formtracker */
/* global dataLayer */
/* global _satellite */

(function ($) {
    'use strict';

    var api = {
            calculateHomeLoanZambia: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * calculateHomeLoanZambia class
     * @param $el navigation wrapper
     * @constructor
     */

    function CalculateHomeLoanZambia($el) {
        this.$el = $el;
        var that = this;

        // The currently active calculation mode
        this.modes = [
            this.$el.find('[data-hook="repayments-icon"]').data('mode'),
            this.$el.find('[data-hook="affordability-icon"]').data('mode')
        ];

        this.mode = this.modes[0];

        this.modeDetails = {};

        this.modeDetails[this.modes[0]] = [
            this.$el.find('[data-hook="repayments-chckbx"]'),
            this.$el.find('[data-hook="repayments-icon"]')
        ];

        this.modeDetails[this.modes[1]] = [
            this.$el.find('[data-hook="affordability-chckbx"]'),
            this.$el.find('[data-hook="affordability-icon"]')
        ];

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                price:  $el.find('[data-hook="input-price"]'),
                deposit: $el.find('[data-hook="input-deposit"]'),
                income: $el.find('[data-hook="input-income"]'),
                commitments: $el.find('[data-hook="input-credit_commitments"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="home-loan-period"]')
            }
        };

        // Add conitional IE9 inputs
        if (browser.msie && browser.version === '9.0') {
            this.$inputs.numeric['period'] = $el.find('[data-hook="input-period"]');
        }

        this.tooltips = $el.find('.calculator-tip');

        // Transfer fee sub-section
        this.$subMenu = $el.find('[data-hook="menu-sub_menu_toggler"]');
        this.$totalFeesSummary = $el.find('[data-hook="section-fees_summary"]');

        // Calculation outputs
        this.$outputs = {
            repayment: $el.find('[data-hook="output-repayment"]'),
            afford: $el.find('[data-hook="output-afford"]'),
            monthly_repayments: $el.find('[data-hook="output-monthly_repayments"]'),
            facility: $el.find('[data-hook="output-facility"]'),
            valuation: $el.find('[data-hook="output-valuation"]')
        };

        this.tracking = $el.find('.calculateHomeLoan-form');

        // Range slider tooltip value tabs
        this.$tabs = {
            period: $el.find('[data-hook="period-tab"]')
        };

        // Range slider progress bars
        this.$progressMarkers = {
            period: $el.find('[data-hook="period-progress"]')
        };

        // Which items to hide/show in calculator modes
        this.modeStates = {};

        // Visible in mode 1
        this.modeStates[this.modes[0]] = [
            this.$inputs.currency.price,
            this.$inputs.currency.deposit,
            this.$outputs.repayment
        ];

        // Visible in mode 2
        this.modeStates[this.modes[1]] = [
            this.$inputs.currency.income,
            this.$inputs.currency.commitments,
            this.$outputs.afford
        ];

        this.model = {
            income: 0,
            commitments: 0,
            price: 30000000,
            deposit: 6000000,
            interest_rate: 19,
            period: 25,
            vat: 1.14,
            maxDSR: 0.45,
            derived: {
                get amount() {
                    if (that.mode === that.modes[0]) {
                        return that.model.price - that.model.deposit;
                    } else {
                        return that.model.derived.afford;
                    }
                },

                get afford(){
                    if (that.mode === that.modes[1]) {
                        return currencyHelper.calculatePresentValue(
                            that.model.interest_rate / (100 * 12),
                            that.model.period * 12,
                            that.model.derived.repayment
                        );
                    }
                },

                get repayment() {
                    if (that.mode == that.modes[0]) {
                        return currencyHelper.calculatePMT(
                            (that.model.interest_rate / 100) / 12,
                            that.model.period * 12,
                            that.model.derived.amount * -1
                        );
                    } else {
                        return ((that.model.income * that.model.maxDSR) - that.model.commitments);
                    }
                },

                get total_repayment() {
                        return Math.ceil(that.model.derived.repayment * (that.model.period * 12) * 100) / 100;
                },

                get facility(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    }

                    return that.model.derived.amount * 0.02;
                },

                get valuation(){
                    if(that.model.derived.amount <= 0) {
                        return 0;
                    } else {
                        return that.model.derived.amount * 0.0015;
                    }
                }
            }
        };

        this.init();
    }

    CalculateHomeLoanZambia.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculateHomeLoanZambia.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculateHomeLoanZambia.prototype.bindUIEvents = function () {
        var that = this;

        // Inputs
        // --- currency
        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        // --- numeric
        calculatorHelper.bindInputs(
            'numeric',
            'input',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'numeric',
            'focusout',
            this.$inputs.numeric,
            this.model,
            this.updateOutputs.bind(this)
        );

        that.tooltips.on('tap click', function () {
            var $this = $(this);
            $this.toggleClass('active');
        });

        that.tooltips.on('mouseenter', function () {
            var $this = $(this);
            $this.addClass('active');
        });

        that.tooltips.on('mouseleave', function () {
            var $this = $(this);
            $this.removeClass('active');
        });

        _.forEach(that.modeDetails, function(input, key) {
            input[1].on('click', function () {
                that.mode = key;
                that.toggleMode(key);
                that.updateOutputs();
            });
        });

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-home loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculateHomeLoanZambia.prototype.setDepositBoundaries = function($loanAmount) {
        if(!this.$inputs.currency.deposit.is(':focus')){
            var deposit = $loanAmount * 0.2;
            this.$inputs.currency.deposit.attr('min', deposit);
            this.$inputs.currency.deposit.attr('max', $loanAmount - 1);
            this.$inputs.currency.deposit.val(currencyHelper.numberToCurrency(deposit));
            this.model.deposit = deposit;
        }
    };

    CalculateHomeLoanZambia.prototype.toggleMode = function($key) {
        var that = this;

        for(var i=0; i<that.modes.length; i++){
            _.forEach(that.modeStates[that.modes[i]], function(element) {
                var parent = '';
                if(element.hasClass('calculateHomeLoan-salary')){
                    parent = element;
                }
                else{
                    parent = element.parent().parent();
                }

                if(that.modes[i] === that.mode){
                    parent.removeClass('disabled');
                }else{
                    parent.addClass('disabled');
                }
            });
        }

        _.forEach(that.modeDetails, function(element){
            element[0].prop('checked', false);
            element[1].removeClass('blue');
        });

        that.toggleTracking();

        that.modeDetails[$key][0].prop('checked', true);
        that.modeDetails[$key][1].addClass('blue');
    };

    CalculateHomeLoanZambia.prototype.toggleTracking = function () {
        var attributes = this.tracking.attr('data-frmcontainer');

        if(this.mode == this.modes[0]){
            attributes = attributes.replace(new RegExp(this.modes[1], 'g'), this.modes[0]);
        }
        else {
            attributes = attributes.replace(new RegExp(this.modes[0], 'g'), this.modes[1]);
        }

        this.tracking.attr('data-frmcontainer', attributes);

        if(typeof formtracker != 'undefined') {
            formtracker.restartForm();
        }

    };

    CalculateHomeLoanZambia.prototype.updateOutputs = function () {
        this.setDepositBoundaries(this.model.price);

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;

        browser = this.external.browser;

        api.calculateHomeLoanZambia.push(new CalculateHomeLoanZambia($el));
    };

    Cog.registerComponent({
        name: 'calculateHomeLoanZambia',
        api: api,
        selector: '.calculateHomeLoanZambia',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanBotswana: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanBotswana class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanBotswana($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                12499: 0,
                14999: 0,
                29999: -2,
                39999: -2,
                50000: -2
            },
            maxLoan: {
                0: 250000,
                12499: 300000,
                14999: 400000,
                29999: 400000,
                39999: 475000,
                50000: 475000
            },
            tenor: {
                0: 72,
                12499: 72,
                14999: 72,
                29999: 72,
                39999: 72,
                50000: 72
            }
        };

        this.model = {
            amount: 0,
            interest_rate : 21.5,
            interest_base : 21.5,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 10000,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };
        this.init();
    }

    CalculatePersonalLoanBotswana.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanBotswana.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanBotswana.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
         }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanBotswana.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanBotswana.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanBotswana.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanBotswana.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanBotswana.push(new CalculatePersonalLoanBotswana($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanBotswana',
        api: api,
        selector: '.calculatePersonalLoanBotswana',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanGhana: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanGhana class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanGhana($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.model = {
            amount: 0,
            interest_rate : 34.0,
            initiation_fee: 0,
            service_fee: 0,
            period : 24,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calculatePMT(
                                (that.model.interest_rate / 100) / 12,
                                that.model.period,
                                -(that.model.amount + that.model.initiation_fee)
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }


    CalculatePersonalLoanGhana.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculatePersonalLoanGhana.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate.toFixed(1));
        }
    };

    CalculatePersonalLoanGhana.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanGhana.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanGhana.push(new CalculatePersonalLoanGhana($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanGhana',
        api: api,
        selector: '.calculatePersonalLoanGhana',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanKenya: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanKenya class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanKenya($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.model = {
            amount: 0,
            interest_rate : 14.5,
            initiation_fee: 0.033,
            service_fee: 57,
            period : 12,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calculatePMT(
                                (that.model.interest_rate / 100) / 12,
                                that.model.period,
                                -(that.model.amount + that.model.derived.initiation_fee)
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanKenya.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculatePersonalLoanKenya.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanKenya.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            this.updateOutputs.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanKenya.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanKenya.push(new CalculatePersonalLoanKenya($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanKenya',
        api: api,
        selector: '.calculatePersonalLoanKenya',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanMauritius: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanMauritius class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanMauritius($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                8000: 0,
                15000: 0,
                20000: -1,
                30000: -4,
                50000: -4,
                100000: -6,
                150000: -6
            },
            maxLoan: {
                8000: 150000,
                15000: 310000,
                20000: 500000,
                30000: 900000,
                50000: 1500000,
                100000: 1500000,
                150000: 2500000
            },
            tenor: {
                8000: 60,
                15000: 60,
                20000: 60,
                30000: 72,
                50000: 72,
                100000: 84,
                150000: 84
            }
        };



        this.model = {
            amount: 0,
            interest_rate : 14,
            interest_base : 14,
            initiation_fee: 0.033,
            service_fee: 57,
            period: 12,
            salary: 0,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            )// + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return 0;//that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanMauritius.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };

    CalculatePersonalLoanMauritius.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate.toFixed(1));
        }
    };

    CalculatePersonalLoanMauritius.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

          // Dispatcher events for child components
        /*this.$inputs.radio.salary.on('change', function (event) {
            this.model.interest_rate = this.interestRate[event.target.value];
            //console.log("Radio: "+this.model.interest_rate);
            this.$inputs.numeric.interest_rate.val(this.model.interest_rate.toFixed(1));
            //this.setInterestRate(this.model.derived.amount);
            this.updateOutputs();
        }.bind(this));*/

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
         }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanMauritius.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        if(this.model.interest_rate.toString().length > 1){
            this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate).toFixed(1));
        } else {
            this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate).toFixed(2));
        }
    };

    CalculatePersonalLoanMauritius.prototype.setMaxLoanAmount = function (salary) {
        var result = 150000;

        for (var key in this.lookup.maxLoan) {
            if (salary > key) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanMauritius.prototype.setTenor = function (salary) {
        var result = 60;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanMauritius.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanMauritius.push(new CalculatePersonalLoanMauritius($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanMauritius',
        api: api,
        selector: '.calculatePersonalLoanMauritius',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanMozambique: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanMozambique class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanMozambique($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                600000: 0,
                3000000: -1,
                4000000: -1,
                10000000: -2,
                100000000: -2
            },
            maxLoan: {
                0: 2000000,
                600000: 70000000,
                3000000: 90000000,
                4000000: 135000000,
                10000000: 200000000,
                100000000: 200000000
            },
            tenor: {
                0: 48,
                600000: 60,
                3000000: 60,
                4000000: 72,
                10000000: 72,
                100000000: 72
            }
        };

        this.model = {
            amount: 0,
            interest_rate : 22,
            interest_base : 22,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 150000,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanMozambique.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanMozambique.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanMozambique.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
         }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanMozambique.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanMozambique.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanMozambique.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanMozambique.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanMozambique.push(new CalculatePersonalLoanMozambique($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanMozambique',
        api: api,
        selector: '.calculatePersonalLoanMozambique',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanNBCTanzania: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanUganda class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanNBCTanzania($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                350: 0,
                500: 0,
                1000: 0,
                2000: 0,
                3500: 0,
                5000: 0,
                6000: 0,
                7500: 0
            },
            maxLoan: {
                0: 5000,
                350: 8000,
                500: 20000,
                1000: 37000,
                2000: 55000,
                3500: 65000,
                5000: 70000,
                6000: 75000,
                7500: 80000
            },
            tenor: {
                0: 60,
                350: 60,
                500: 60,
                1000: 60,
                2000: 60,
                3500: 60,
                5000: 60,
                6000: 72,
                7500: 72
            }
        };

        this.model = {
            amount: 0,
            interest_rate : 22,
            interest_base : 22,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 201,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanNBCTanzania.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanNBCTanzania.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanNBCTanzania.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
         }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanNBCTanzania.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanNBCTanzania.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanNBCTanzania.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanNBCTanzania.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanNBCTanzania.push(new CalculatePersonalLoanNBCTanzania($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanNBCTanzania',
        api: api,
        selector: '.calculatePersonalLoanNBCTanzania',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanSeychelles: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanSeychelles class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanSeychelles($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                5000: 0,
                6000: 0,
                7000: 0,
                8000: 0,
                15000: -6,
                20000: -6,
                40000: -6,
                60000: -6
            },
            maxLoan: {
                0: 70000,
                5000: 95000,
                6000: 110000,
                7000: 130000,
                8000: 150000,
                15000: 290000,
                20000: 330000,
                40000: 400000,
                60000: 400000
            },
            tenor: {
                0: 60,
                5000: 60,
                6000: 60,
                7000: 60,
                8000: 60,
                15000: 60,
                20000: 60,
                40000: 60,
                60000: 60
            }
        };

        this.model = {
            amount: 0,
            interest_rate : 24,
            interest_base : 24,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 3500,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanSeychelles.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanSeychelles.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanSeychelles.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
         }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanSeychelles.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanSeychelles.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanSeychelles.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanSeychelles.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanSeychelles.push(new CalculatePersonalLoanSeychelles($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanSeychelles',
        api: api,
        selector: '.calculatePersonalLoanSeychelles',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
        calculatePersonalLoanTanzania: []
    },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanTanzania class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanTanzania($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                350000: 0,
                500000: 0,
                1000000: 0,
                2000000: 0,
                3500000: +2.25,
                5000000: 0,
                6000000: 0,
                7499000: +2.25,
                7500000: 0
            },
            maxLoan: {
                0: 5000000,
                350000: 8000000,
                500000: 20000000,
                1000000: 37000000,
                2000000: 55000000,
                3500000: 65000000,
                5000000: 70000000,
                6000000: 75000000,
                7499000: 80000000,
                7500000: 80000000
            },
            tenor: {
                0: 60,
                350000: 60,
                500000: 60,
                1000000: 60,
                2000000: 60,
                3500000: 60,
                5000000: 60,
                6000000: 72,
                7499000: 72,
                7500000: 72
            }
        };

        this.model = {
            amount: 0,
            interest_rate : 20.75,
            interest_base : 20.75,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 201000,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanTanzania.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanTanzania.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanTanzania.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanTanzania.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanTanzania.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanTanzania.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanTanzania.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanTanzania.push(new CalculatePersonalLoanTanzania($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanTanzania',
        api: api,
        selector: '.calculatePersonalLoanTanzania',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
            calculatePersonalLoanUganda: []
        },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanUganda class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanUganda($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                600000: 0,
                3000000: -1,
                4000000: -1,
                10000000: -2,
                100000000: -2
            },
            maxLoan: {
                0: 2000000,
                600000: 70000000,
                3000000: 90000000,
                4000000: 135000000,
                10000000: 200000000,
                100000000: 200000000
            },
            tenor: {
                0: 48,
                600000: 60,
                3000000: 60,
                4000000: 72,
                10000000: 72,
                100000000: 72
            }
        };

        this.model = {
            amount: 0,
            interest_rate : 22,
            interest_base : 22,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 150000,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanUganda.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanUganda.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanUganda.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
         }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanUganda.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanUganda.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanUganda.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanUganda.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanUganda.push(new CalculatePersonalLoanUganda($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanUganda',
        api: api,
        selector: '.calculatePersonalLoanUganda',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());

/*jshint sub:true*/
/* global dataLayer */
/* global _satellite */

(function () {
    'use strict';

    var api = {
        calculatePersonalLoanZambia: []
    },
        status = null,
        browser = null,
        currencyHelper = null,
        calculatorHelper = null;

    /**
     * CalculatePersonalLoanZambia class
     * @param $el navigation wrapper
     * @constructor
     */
    function CalculatePersonalLoanZambia($el) {
        this.$el = $el;
        var that = this;

        // Inputs for all user defined variables
        this.$inputs = {
            currency: {
                amount: $el.find('[data-hook="input-amount"]'),
                salary: $el.find('[data-hook="input-salary"]')
            },
            numeric: {
                interest_rate: $el.find('[data-hook="input-interest_rate"]')
            },
            range: {
                period: $el.find('[data-hook="personal-loan-period"]')
            }
        };

        // Calculation outputs
        this.$outputs = {
            monthly_repayment: $el.find('[data-hook="output-monthly_repayment"]'),
            total_repayment: $el.find('[data-hook="output-total_repayment"]'),
            interest_paid: $el.find('[data-hook="output-interest_paid"]')
        };

        this.lookup = {
            interestRate: {
                0: 0,
                5000: 0,
                8000: -0.5,
                15000: -0.5,
                20000: -1,
                25000: -1,
                30000: -1,
                35000: -1
            },
            maxLoan: {
                0: 65000,
                5000: 120000,
                8000: 180000,
                15000: 220000,
                20000: 240000,
                25000: 250000,
                30000: 300000,
                35000: 300000
            },
            tenor: {
                0: 36,
                40000: 54,
                180000: 60
            },
        };

        this.model = {
            amount: 0,
            interest_rate : 27,
            interest_base : 27,
            initiation_fee: 0,
            service_fee: 0,
            period: 12,
            salary: 5000,
            derived: {
                get monthly_repayment() {
                    if(that.model.amount === 0){
                        return 0;
                    } else {
                        return (
                            currencyHelper.calcMonthlyPayments(
                                (that.model.amount + that.model.derived.initiation_fee),
                                that.model.interest_rate / 100,
                                that.model.period
                            ) + that.model.service_fee
                        );
                    }
                },

                get total_repayment () {
                    return that.model.derived.monthly_repayment * that.model.period;
                },

                get interest_paid () {
                    return that.model.derived.total_repayment - that.model.amount -
                        that.model.derived.initiation_fee - that.model.service_fee;
                },

                get initiation_fee () {
                    return that.model.amount * that.model.initiation_fee;
                }
            }
        };

        this.init();
    }

    CalculatePersonalLoanZambia.prototype.init = function () {
        if (status.isAuthor()) {
            return;
        } else {
            this.setDefaultInputValues();
            this.bindUIEvents();
            this.updateOutputs();
        }
    };


    CalculatePersonalLoanZambia.prototype.setDefaultInputValues = function () {
        var interestRate = parseFloat(this.$inputs.numeric.interest_rate.attr('data-interest-rate'), 10);

        if(!isNaN(interestRate)){
            this.model.interest_base = interestRate;
            this.model.interest_rate = interestRate;
            this.$inputs.numeric.interest_rate.val(interestRate);
        }
    };

    CalculatePersonalLoanZambia.prototype.bindUIEvents = function () {

        calculatorHelper.bindInputs(
            'currency',
            'input',
            this.$inputs.currency,
            this.model,
            function(){
                this.setInterestRate(this.model.salary);
                this.setMaxLoanAmount(this.model.salary);
                this.setTenor(this.model.salary);

                this.updateOutputs();
            }.bind(this)
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusin',
            this.$inputs.currency,
            this.model
        );

        calculatorHelper.bindInputs(
            'currency',
            'focusout',
            this.$inputs.currency,
            this.model
        );

        Cog.addListener('calculatorRangeSlider', 'update', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                this.model.period = data.eventData.value;
                this.updateOutputs();
            }
        }.bind(this));

        Cog.addListener('calculatorRangeSlider', 'focusin', function (data) {
            if (this.$inputs.range.period.data('hook') === data.eventData.hook) {
                dataLayer.siteEvents = 'tools_Tools-persoanl loan calculator | payment terms';
                _satellite.track('genericUserInteraction');
            }
        }.bind(this));
    };

    CalculatePersonalLoanZambia.prototype.setInterestRate = function(salary) {
        for (var key in this.lookup.interestRate) {
            if (salary > key) {
                this.model.interest_rate = this.model.interest_base + this.lookup.interestRate[key];
            }
        }

        this.$inputs.numeric.interest_rate.val(parseInt(this.model.interest_rate));
    };

    CalculatePersonalLoanZambia.prototype.setMaxLoanAmount = function (salary) {
        var result = 0;

        for (var key in this.lookup.maxLoan) {
            if (salary > parseInt(key)) {
                result = this.lookup.maxLoan[key];
            }
        }

        result = parseInt(result);
        this.$inputs.currency.amount.attr('max', result);

        if(this.model.amount > result){
            this.model.amount = result;
            this.$inputs.currency.amount.val(currencyHelper.numberToCurrency(result));
        }
    };

    CalculatePersonalLoanZambia.prototype.setTenor = function (salary) {
        var result = 0;

        for (var key in this.lookup.tenor) {
            if (salary > key) {
                result = this.lookup.tenor[key];
            }
        }

        var periodInput = this.$inputs.range.period.find('input');

        periodInput.attr('max', parseInt(result));
        periodInput.trigger('input');
    };

    CalculatePersonalLoanZambia.prototype.updateOutputs = function () {

        calculatorHelper.bindOutputs(this.$outputs, this.model.derived);
    };

    api.onRegister = function (scope) {
        var $el = scope.$scope;

        status = this.external.status;
        currencyHelper = this.external.currencyHelper;
        calculatorHelper = this.external.calculatorHelper;
        browser = this.external.browser;

        api.calculatePersonalLoanZambia.push(new CalculatePersonalLoanZambia($el));
    };

    Cog.registerComponent({
        name: 'calculatePersonalLoanZambia',
        api: api,
        selector: '.calculatePersonalLoanZambia',
        requires: [{
            name: 'utils.status',
            apiId: 'status'
        }, {
            name: 'utils.browser',
            apiId: 'browser'
        }, {
            name: 'utils.currencyHelper',
            apiId: 'currencyHelper'
        }, {
            name: 'utils.calculatorHelper',
            apiId: 'calculatorHelper'
        }]
    });

})(Cog.jQuery());



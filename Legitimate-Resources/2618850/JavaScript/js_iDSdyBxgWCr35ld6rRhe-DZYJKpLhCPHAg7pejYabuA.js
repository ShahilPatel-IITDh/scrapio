/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
(function ($, Drupal) {
  Drupal.theme.progressBar = function (id) {
    return "<div id=\"".concat(id, "\" class=\"progress\" aria-live=\"polite\">") + '<div class="progress__label">&nbsp;</div>' + '<div class="progress__track"><div class="progress__bar"></div></div>' + '<div class="progress__percentage"></div>' + '<div class="progress__description">&nbsp;</div>' + '</div>';
  };
  Drupal.ProgressBar = function (id, updateCallback, method, errorCallback) {
    this.id = id;
    this.method = method || 'GET';
    this.updateCallback = updateCallback;
    this.errorCallback = errorCallback;
    this.element = $(Drupal.theme('progressBar', id));
  };
  $.extend(Drupal.ProgressBar.prototype, {
    setProgress: function setProgress(percentage, message, label) {
      if (percentage >= 0 && percentage <= 100) {
        $(this.element).find('div.progress__bar').css('width', "".concat(percentage, "%"));
        $(this.element).find('div.progress__percentage').html("".concat(percentage, "%"));
      }
      $('div.progress__description', this.element).html(message);
      $('div.progress__label', this.element).html(label);
      if (this.updateCallback) {
        this.updateCallback(percentage, message, this);
      }
    },
    startMonitoring: function startMonitoring(uri, delay) {
      this.delay = delay;
      this.uri = uri;
      this.sendPing();
    },
    stopMonitoring: function stopMonitoring() {
      clearTimeout(this.timer);
      this.uri = null;
    },
    sendPing: function sendPing() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      if (this.uri) {
        var pb = this;
        var uri = this.uri;
        if (uri.indexOf('?') === -1) {
          uri += '?';
        } else {
          uri += '&';
        }
        uri += '_format=json';
        $.ajax({
          type: this.method,
          url: uri,
          data: '',
          dataType: 'json',
          success: function success(progress) {
            if (progress.status === 0) {
              pb.displayError(progress.data);
              return;
            }
            pb.setProgress(progress.percentage, progress.message, progress.label);
            pb.timer = setTimeout(function () {
              pb.sendPing();
            }, pb.delay);
          },
          error: function error(xmlhttp) {
            var e = new Drupal.AjaxError(xmlhttp, pb.uri);
            pb.displayError("<pre>".concat(e.message, "</pre>"));
          }
        });
      }
    },
    displayError: function displayError(string) {
      var error = $('<div class="messages messages--error"></div>').html(string);
      $(this.element).before(error).hide();
      if (this.errorCallback) {
        this.errorCallback(this);
      }
    }
  });
})(jQuery, Drupal);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
(function ($, once) {
  var deprecatedMessageSuffix = "is deprecated in Drupal 9.3.0 and will be removed in Drupal 10.0.0. Use the core/once library instead. See https://www.drupal.org/node/3158256";
  var originalJQOnce = $.fn.once;
  var originalJQRemoveOnce = $.fn.removeOnce;
  $.fn.once = function jQueryOnce(id) {
    Drupal.deprecationError({
      message: "jQuery.once() ".concat(deprecatedMessageSuffix)
    });
    return originalJQOnce.apply(this, [id]);
  };
  $.fn.removeOnce = function jQueryRemoveOnce(id) {
    Drupal.deprecationError({
      message: "jQuery.removeOnce() ".concat(deprecatedMessageSuffix)
    });
    return originalJQRemoveOnce.apply(this, [id]);
  };
  var drupalOnce = once;
  function augmentedOnce(id, selector, context) {
    originalJQOnce.apply($(selector, context), [id]);
    return drupalOnce(id, selector, context);
  }
  function remove(id, selector, context) {
    originalJQRemoveOnce.apply($(selector, context), [id]);
    return drupalOnce.remove(id, selector, context);
  }
  window.once = Object.assign(augmentedOnce, drupalOnce, {
    remove: remove
  });
})(jQuery, once);;
loadjs=function(){var h=function(){},c={},u={},f={};function o(e,n){if(e){var r=f[e];if(u[e]=n,r)for(;r.length;)r[0](e,n),r.splice(0,1)}}function l(e,n){e.call&&(e={success:e}),n.length?(e.error||h)(n):(e.success||h)(e)}function d(r,t,s,i){var c,o,e=document,n=s.async,u=(s.numRetries||0)+1,f=s.before||h,l=r.replace(/[\?|#].*$/,""),a=r.replace(/^(css|img)!/,"");i=i||0,/(^css!|\.css$)/.test(l)?((o=e.createElement("link")).rel="stylesheet",o.href=a,(c="hideFocus"in o)&&o.relList&&(c=0,o.rel="preload",o.as="style")):/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(l)?(o=e.createElement("img")).src=a:((o=e.createElement("script")).src=r,o.async=void 0===n||n),!(o.onload=o.onerror=o.onbeforeload=function(e){var n=e.type[0];if(c)try{o.sheet.cssText.length||(n="e")}catch(e){18!=e.code&&(n="e")}if("e"==n){if((i+=1)<u)return d(r,t,s,i)}else if("preload"==o.rel&&"style"==o.as)return o.rel="stylesheet";t(r,n,e.defaultPrevented)})!==f(r,o)&&e.head.appendChild(o)}function r(e,n,r){var t,s;if(n&&n.trim&&(t=n),s=(t?r:n)||{},t){if(t in c)throw"LoadJS";c[t]=!0}function i(n,r){!function(e,t,n){var r,s,i=(e=e.push?e:[e]).length,c=i,o=[];for(r=function(e,n,r){if("e"==n&&o.push(e),"b"==n){if(!r)return;o.push(e)}--i||t(o)},s=0;s<c;s++)d(e[s],r,n)}(e,function(e){l(s,e),n&&l({success:n,error:r},e),o(t,e)},s)}if(s.returnPromise)return new Promise(i);i()}return r.ready=function(e,n){return function(e,r){e=e.push?e:[e];var n,t,s,i=[],c=e.length,o=c;for(n=function(e,n){n.length&&i.push(e),--o||r(i)};c--;)t=e[c],(s=u[t])?n(t,s):(f[t]=f[t]||[]).push(n)}(e,function(e){l(n,e)}),r},r.done=function(e){o(e,[])},r.reset=function(){c={},u={},f={}},r.isDefined=function(e){return e in c},r}();;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
(function (Drupal) {
  Drupal.behaviors.responsiveImageAJAX = {
    attach: function attach() {
      if (window.picturefill) {
        window.picturefill();
      }
    }
  };
})(Drupal);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
(function ($, window, Drupal, drupalSettings, loadjs, _ref) {
  var isFocusable = _ref.isFocusable,
    tabbable = _ref.tabbable;
  Drupal.behaviors.AJAX = {
    attach: function attach(context, settings) {
      function loadAjaxBehavior(base) {
        var elementSettings = settings.ajax[base];
        if (typeof elementSettings.selector === 'undefined') {
          elementSettings.selector = "#".concat(base);
        }
        once('drupal-ajax', $(elementSettings.selector)).forEach(function (el) {
          elementSettings.element = el;
          elementSettings.base = base;
          Drupal.ajax(elementSettings);
        });
      }
      Object.keys(settings.ajax || {}).forEach(function (base) {
        return loadAjaxBehavior(base);
      });
      Drupal.ajax.bindAjaxLinks(document.body);
      once('ajax', '.use-ajax-submit').forEach(function (el) {
        var elementSettings = {};
        elementSettings.url = $(el.form).attr('action');
        elementSettings.setClick = true;
        elementSettings.event = 'click';
        elementSettings.progress = {
          type: 'throbber'
        };
        elementSettings.base = el.id;
        elementSettings.element = el;
        Drupal.ajax(elementSettings);
      });
    },
    detach: function detach(context, settings, trigger) {
      if (trigger === 'unload') {
        Drupal.ajax.expired().forEach(function (instance) {
          Drupal.ajax.instances[instance.instanceIndex] = null;
        });
      }
    }
  };
  Drupal.AjaxError = function (xmlhttp, uri, customMessage) {
    var statusCode;
    var statusText;
    var responseText;
    if (xmlhttp.status) {
      statusCode = "\n".concat(Drupal.t('An AJAX HTTP error occurred.'), "\n").concat(Drupal.t('HTTP Result Code: !status', {
        '!status': xmlhttp.status
      }));
    } else {
      statusCode = "\n".concat(Drupal.t('An AJAX HTTP request terminated abnormally.'));
    }
    statusCode += "\n".concat(Drupal.t('Debugging information follows.'));
    var pathText = "\n".concat(Drupal.t('Path: !uri', {
      '!uri': uri
    }));
    statusText = '';
    try {
      statusText = "\n".concat(Drupal.t('StatusText: !statusText', {
        '!statusText': xmlhttp.statusText.trim()
      }));
    } catch (e) {}
    responseText = '';
    try {
      responseText = "\n".concat(Drupal.t('ResponseText: !responseText', {
        '!responseText': xmlhttp.responseText.trim()
      }));
    } catch (e) {}
    responseText = responseText.replace(/<("[^"]*"|'[^']*'|[^'">])*>/gi, '');
    responseText = responseText.replace(/[\n]+\s+/g, '\n');
    var readyStateText = xmlhttp.status === 0 ? "\n".concat(Drupal.t('ReadyState: !readyState', {
      '!readyState': xmlhttp.readyState
    })) : '';
    customMessage = customMessage ? "\n".concat(Drupal.t('CustomMessage: !customMessage', {
      '!customMessage': customMessage
    })) : '';
    this.message = statusCode + pathText + statusText + customMessage + responseText + readyStateText;
    this.name = 'AjaxError';
  };
  Drupal.AjaxError.prototype = new Error();
  Drupal.AjaxError.prototype.constructor = Drupal.AjaxError;
  Drupal.ajax = function (settings) {
    if (arguments.length !== 1) {
      throw new Error('Drupal.ajax() function must be called with one configuration object only');
    }
    var base = settings.base || false;
    var element = settings.element || false;
    delete settings.base;
    delete settings.element;
    if (!settings.progress && !element) {
      settings.progress = false;
    }
    var ajax = new Drupal.Ajax(base, element, settings);
    ajax.instanceIndex = Drupal.ajax.instances.length;
    Drupal.ajax.instances.push(ajax);
    return ajax;
  };
  Drupal.ajax.instances = [];
  Drupal.ajax.expired = function () {
    return Drupal.ajax.instances.filter(function (instance) {
      return instance && instance.element !== false && !document.body.contains(instance.element);
    });
  };
  Drupal.ajax.bindAjaxLinks = function (element) {
    once('ajax', '.use-ajax', element).forEach(function (ajaxLink) {
      var $linkElement = $(ajaxLink);
      var elementSettings = {
        progress: {
          type: 'throbber'
        },
        dialogType: $linkElement.data('dialog-type'),
        dialog: $linkElement.data('dialog-options'),
        dialogRenderer: $linkElement.data('dialog-renderer'),
        base: $linkElement.attr('id'),
        element: ajaxLink
      };
      var href = $linkElement.attr('href');
      if (href) {
        elementSettings.url = href;
        elementSettings.event = 'click';
      }
      Drupal.ajax(elementSettings);
    });
  };
  Drupal.Ajax = function (base, element, elementSettings) {
    var defaults = {
      event: element ? 'mousedown' : null,
      keypress: true,
      selector: base ? "#".concat(base) : null,
      effect: 'none',
      speed: 'none',
      method: 'replaceWith',
      progress: {
        type: 'throbber',
        message: Drupal.t('Please wait...')
      },
      submit: {
        js: true
      }
    };
    $.extend(this, defaults, elementSettings);
    this.commands = new Drupal.AjaxCommands();
    this.instanceIndex = false;
    if (this.wrapper) {
      this.wrapper = "#".concat(this.wrapper);
    }
    this.element = element;
    this.element_settings = elementSettings;
    this.elementSettings = elementSettings;
    if (this.element && this.element.form) {
      this.$form = $(this.element.form);
    }
    if (!this.url) {
      var $element = $(this.element);
      if ($element.is('a')) {
        this.url = $element.attr('href');
      } else if (this.element && element.form) {
        this.url = this.$form.attr('action');
      }
    }
    var originalUrl = this.url;
    this.url = this.url.replace(/\/nojs(\/|$|\?|#)/, '/ajax$1');
    if (drupalSettings.ajaxTrustedUrl[originalUrl]) {
      drupalSettings.ajaxTrustedUrl[this.url] = true;
    }
    var ajax = this;
    ajax.options = {
      url: ajax.url,
      data: ajax.submit,
      isInProgress: function isInProgress() {
        return ajax.ajaxing;
      },
      beforeSerialize: function beforeSerialize(elementSettings, options) {
        return ajax.beforeSerialize(elementSettings, options);
      },
      beforeSubmit: function beforeSubmit(formValues, elementSettings, options) {
        ajax.ajaxing = true;
        return ajax.beforeSubmit(formValues, elementSettings, options);
      },
      beforeSend: function beforeSend(xmlhttprequest, options) {
        ajax.ajaxing = true;
        return ajax.beforeSend(xmlhttprequest, options);
      },
      success: function success(response, status, xmlhttprequest) {
        var _this = this;
        if (typeof response === 'string') {
          response = $.parseJSON(response);
        }
        if (response !== null && !drupalSettings.ajaxTrustedUrl[ajax.url]) {
          if (xmlhttprequest.getResponseHeader('X-Drupal-Ajax-Token') !== '1') {
            var customMessage = Drupal.t('The response failed verification so will not be processed.');
            return ajax.error(xmlhttprequest, ajax.url, customMessage);
          }
        }
        return Promise.resolve(ajax.success(response, status)).then(function () {
          ajax.ajaxing = false;
          $(document).trigger('ajaxSuccess', [xmlhttprequest, _this]);
          $(document).trigger('ajaxComplete', [xmlhttprequest, _this]);
          if (--$.active === 0) {
            $(document).trigger('ajaxStop');
          }
        });
      },
      error: function error(xmlhttprequest, status, _error) {
        ajax.ajaxing = false;
      },
      complete: function complete(xmlhttprequest, status) {
        if (status === 'error' || status === 'parsererror') {
          return ajax.error(xmlhttprequest, ajax.url);
        }
      },
      dataType: 'json',
      jsonp: false,
      type: 'POST'
    };
    if (elementSettings.dialog) {
      ajax.options.data.dialogOptions = elementSettings.dialog;
    }

    var wrapper = "drupal_".concat(elementSettings.dialogType || 'ajax');
    if (elementSettings.dialogRenderer) {
      wrapper += ".".concat(elementSettings.dialogRenderer);
    }
    var queryParameter = Drupal.ajax.WRAPPER_FORMAT + '=' + wrapper;
    if (ajax.options.url.indexOf(Drupal.ajax.WRAPPER_FORMAT) === -1) {
      // Ensure that we have a valid URL by adding ? when no query parameter is
      // yet available, otherwise append using &.
      ajax.options.url += (ajax.options.url.indexOf('?') === -1) ? '?' : '&';
      ajax.options.url += queryParameter;
    } else {
      var regexPattern = new RegExp(Drupal.ajax.WRAPPER_FORMAT + '=[^&]*', 'i');
      ajax.options.url = ajax.options.url.replace(regexPattern, queryParameter);
    }
    $(ajax.element).on(elementSettings.event, function (event) {
      if (!drupalSettings.ajaxTrustedUrl[ajax.url] && !Drupal.url.isLocal(ajax.url)) {
        throw new Error(Drupal.t('The callback URL is not local and not trusted: !url', {
          '!url': ajax.url
        }));
      }
      return ajax.eventResponse(this, event);
    });
    if (elementSettings.keypress) {
      $(ajax.element).on('keypress', function (event) {
        return ajax.keypressResponse(this, event);
      });
    }
    if (elementSettings.prevent) {
      $(ajax.element).on(elementSettings.prevent, false);
    }
  };
  Drupal.ajax.WRAPPER_FORMAT = '_wrapper_format';
  Drupal.Ajax.AJAX_REQUEST_PARAMETER = '_drupal_ajax';
  Drupal.Ajax.prototype.execute = function () {
    if (this.ajaxing) {
      return;
    }
    try {
      this.beforeSerialize(this.element, this.options);
      return $.ajax(this.options);
    } catch (e) {
      this.ajaxing = false;
      window.alert("An error occurred while attempting to process ".concat(this.options.url, ": ").concat(e.message));
      return $.Deferred().reject();
    }
  };
  Drupal.Ajax.prototype.keypressResponse = function (element, event) {
    var ajax = this;
    if (event.which === 13 || event.which === 32 && element.type !== 'text' && element.type !== 'textarea' && element.type !== 'tel' && element.type !== 'number') {
      event.preventDefault();
      event.stopPropagation();
      $(element).trigger(ajax.elementSettings.event);
    }
  };
  Drupal.Ajax.prototype.eventResponse = function (element, event) {
    event.preventDefault();
    event.stopPropagation();
    var ajax = this;
    if (ajax.ajaxing) {
      return;
    }
    try {
      if (ajax.$form) {
        if (ajax.setClick) {
          element.form.clk = element;
        }
        ajax.$form.ajaxSubmit(ajax.options);
      } else {
        ajax.beforeSerialize(ajax.element, ajax.options);
        $.ajax(ajax.options);
      }
    } catch (e) {
      ajax.ajaxing = false;
      window.alert("An error occurred while attempting to process ".concat(ajax.options.url, ": ").concat(e.message));
    }
  };
  Drupal.Ajax.prototype.beforeSerialize = function (element, options) {
    if (this.$form && document.body.contains(this.$form.get(0))) {
      var settings = this.settings || drupalSettings;
      Drupal.detachBehaviors(this.$form.get(0), settings, 'serialize');
    }
    options.data[Drupal.Ajax.AJAX_REQUEST_PARAMETER] = 1;
    var pageState = drupalSettings.ajaxPageState;
    options.data['ajax_page_state[theme]'] = pageState.theme;
    options.data['ajax_page_state[theme_token]'] = pageState.theme_token;
    options.data['ajax_page_state[libraries]'] = pageState.libraries;
  };
  Drupal.Ajax.prototype.beforeSubmit = function (formValues, element, options) {};
  Drupal.Ajax.prototype.beforeSend = function (xmlhttprequest, options) {
    if (this.$form) {
      options.extraData = options.extraData || {};
      options.extraData.ajax_iframe_upload = '1';
      var v = $.fieldValue(this.element);
      if (v !== null) {
        options.extraData[this.element.name] = v;
      }
    }
    $(this.element).prop('disabled', true);
    if (!this.progress || !this.progress.type) {
      return;
    }
    var progressIndicatorMethod = "setProgressIndicator".concat(this.progress.type.slice(0, 1).toUpperCase()).concat(this.progress.type.slice(1).toLowerCase());
    if (progressIndicatorMethod in this && typeof this[progressIndicatorMethod] === 'function') {
      this[progressIndicatorMethod].call(this);
    }
  };
  Drupal.theme.ajaxProgressThrobber = function (message) {
    var messageMarkup = typeof message === 'string' ? Drupal.theme('ajaxProgressMessage', message) : '';
    var throbber = '<div class="throbber">&nbsp;</div>';
    return "<div class=\"ajax-progress ajax-progress-throbber\">".concat(throbber).concat(messageMarkup, "</div>");
  };
  Drupal.theme.ajaxProgressIndicatorFullscreen = function () {
    return '<div class="ajax-progress ajax-progress-fullscreen">&nbsp;</div>';
  };
  Drupal.theme.ajaxProgressMessage = function (message) {
    return "<div class=\"message\">".concat(message, "</div>");
  };
  Drupal.theme.ajaxProgressBar = function ($element) {
    return $('<div class="ajax-progress ajax-progress-bar"></div>').append($element);
  };
  Drupal.Ajax.prototype.setProgressIndicatorBar = function () {
    var progressBar = new Drupal.ProgressBar("ajax-progress-".concat(this.element.id), $.noop, this.progress.method, $.noop);
    if (this.progress.message) {
      progressBar.setProgress(-1, this.progress.message);
    }
    if (this.progress.url) {
      progressBar.startMonitoring(this.progress.url, this.progress.interval || 1500);
    }
    this.progress.element = $(Drupal.theme('ajaxProgressBar', progressBar.element));
    this.progress.object = progressBar;
    $(this.element).after(this.progress.element);
  };
  Drupal.Ajax.prototype.setProgressIndicatorThrobber = function () {
    this.progress.element = $(Drupal.theme('ajaxProgressThrobber', this.progress.message));
    $(this.element).after(this.progress.element);
  };
  Drupal.Ajax.prototype.setProgressIndicatorFullscreen = function () {
    this.progress.element = $(Drupal.theme('ajaxProgressIndicatorFullscreen'));
    $('body').append(this.progress.element);
  };
  Drupal.Ajax.prototype.commandExecutionQueue = function (response, status) {
    var _this2 = this;
    var ajaxCommands = this.commands;
    return Object.keys(response || {}).reduce(function (executionQueue, key) {
      return executionQueue.then(function () {
        var command = response[key].command;
        if (command && ajaxCommands[command]) {
          return ajaxCommands[command](_this2, response[key], status);
        }
      });
    }, Promise.resolve());
  };
  Drupal.Ajax.prototype.success = function (response, status) {
    var _this3 = this;
    if (this.progress.element) {
      $(this.progress.element).remove();
    }
    if (this.progress.object) {
      this.progress.object.stopMonitoring();
    }
    $(this.element).prop('disabled', false);
    var elementParents = $(this.element).parents('[data-drupal-selector]').addBack().toArray();
    var focusChanged = Object.keys(response || {}).some(function (key) {
      var _response$key = response[key],
        command = _response$key.command,
        method = _response$key.method;
      return command === 'focusFirst' || command === 'invoke' && method === 'focus';
    });
    return this.commandExecutionQueue(response, status).then(function () {
      if (!focusChanged && _this3.element && !$(_this3.element).data('disable-refocus')) {
        var target = false;
        for (var n = elementParents.length - 1; !target && n >= 0; n--) {
          target = document.querySelector("[data-drupal-selector=\"".concat(elementParents[n].getAttribute('data-drupal-selector'), "\"]"));
        }
        if (target) {
          $(target).trigger('focus');
        }
      }
      if (_this3.$form && document.body.contains(_this3.$form.get(0))) {
        var settings = _this3.settings || drupalSettings;
        Drupal.attachBehaviors(_this3.$form.get(0), settings);
      }
      _this3.settings = null;
    }).catch(function (error) {
      return console.error(Drupal.t('An error occurred during the execution of the Ajax response: !error', {
        '!error': error
      }));
    });
  };
  Drupal.Ajax.prototype.getEffect = function (response) {
    var type = response.effect || this.effect;
    var speed = response.speed || this.speed;
    var effect = {};
    if (type === 'none') {
      effect.showEffect = 'show';
      effect.hideEffect = 'hide';
      effect.showSpeed = '';
    } else if (type === 'fade') {
      effect.showEffect = 'fadeIn';
      effect.hideEffect = 'fadeOut';
      effect.showSpeed = speed;
    } else {
      effect.showEffect = "".concat(type, "Toggle");
      effect.hideEffect = "".concat(type, "Toggle");
      effect.showSpeed = speed;
    }
    return effect;
  };
  Drupal.Ajax.prototype.error = function (xmlhttprequest, uri, customMessage) {
    if (this.progress.element) {
      $(this.progress.element).remove();
    }
    if (this.progress.object) {
      this.progress.object.stopMonitoring();
    }
    $(this.wrapper).show();
    $(this.element).prop('disabled', false);
    if (this.$form && document.body.contains(this.$form.get(0))) {
      var settings = this.settings || drupalSettings;
      Drupal.attachBehaviors(this.$form.get(0), settings);
    }
    throw new Drupal.AjaxError(xmlhttprequest, uri, customMessage);
  };
  Drupal.theme.ajaxWrapperNewContent = function ($newContent, ajax, response) {
    return (response.effect || ajax.effect) !== 'none' && $newContent.filter(function (i) {
      return !($newContent[i].nodeName === '#comment' || $newContent[i].nodeName === '#text' && /^(\s|\n|\r)*$/.test($newContent[i].textContent));
    }).length > 1 ? Drupal.theme('ajaxWrapperMultipleRootElements', $newContent) : $newContent;
  };
  Drupal.theme.ajaxWrapperMultipleRootElements = function ($elements) {
    return $('<div></div>').append($elements);
  };
  Drupal.AjaxCommands = function () {};
  Drupal.AjaxCommands.prototype = {
    insert: function insert(ajax, response) {
      var $wrapper = response.selector ? $(response.selector) : $(ajax.wrapper);
      var method = response.method || ajax.method;
      var effect = ajax.getEffect(response);
      var settings = response.settings || ajax.settings || drupalSettings;
      var $newContent = $($.parseHTML(response.data, document, true));
      $newContent = Drupal.theme('ajaxWrapperNewContent', $newContent, ajax, response);
      switch (method) {
        case 'html':
        case 'replaceWith':
        case 'replaceAll':
        case 'empty':
        case 'remove':
          Drupal.detachBehaviors($wrapper.get(0), settings);
          break;
        default:
          break;
      }
      $wrapper[method]($newContent);
      if (effect.showEffect !== 'show') {
        $newContent.hide();
      }
      var $ajaxNewContent = $newContent.find('.ajax-new-content');
      if ($ajaxNewContent.length) {
        $ajaxNewContent.hide();
        $newContent.show();
        $ajaxNewContent[effect.showEffect](effect.showSpeed);
      } else if (effect.showEffect !== 'show') {
        $newContent[effect.showEffect](effect.showSpeed);
      }
      if ($newContent.parents('html').length) {
        $newContent.each(function (index, element) {
          if (element.nodeType === Node.ELEMENT_NODE) {
            Drupal.attachBehaviors(element, settings);
          }
        });
      }
    },
    remove: function remove(ajax, response, status) {
      var settings = response.settings || ajax.settings || drupalSettings;
      $(response.selector).each(function () {
        Drupal.detachBehaviors(this, settings);
      }).remove();
    },
    changed: function changed(ajax, response, status) {
      var $element = $(response.selector);
      if (!$element.hasClass('ajax-changed')) {
        $element.addClass('ajax-changed');
        if (response.asterisk) {
          $element.find(response.asterisk).append(" <abbr class=\"ajax-changed\" title=\"".concat(Drupal.t('Changed'), "\">*</abbr> "));
        }
      }
    },
    alert: function alert(ajax, response, status) {
      window.alert(response.text);
    },
    announce: function announce(ajax, response) {
      if (response.priority) {
        Drupal.announce(response.text, response.priority);
      } else {
        Drupal.announce(response.text);
      }
    },
    redirect: function redirect(ajax, response, status) {
      window.location = response.url;
    },
    css: function css(ajax, response, status) {
      $(response.selector).css(response.argument);
    },
    settings: function settings(ajax, response, status) {
      var ajaxSettings = drupalSettings.ajax;
      if (ajaxSettings) {
        Drupal.ajax.expired().forEach(function (instance) {
          if (instance.selector) {
            var selector = instance.selector.replace('#', '');
            if (selector in ajaxSettings) {
              delete ajaxSettings[selector];
            }
          }
        });
      }
      if (response.merge) {
        $.extend(true, drupalSettings, response.settings);
      } else {
        ajax.settings = response.settings;
      }
    },
    data: function data(ajax, response, status) {
      $(response.selector).data(response.name, response.value);
    },
    focusFirst: function focusFirst(ajax, response, status) {
      var focusChanged = false;
      var container = document.querySelector(response.selector);
      if (container) {
        var tabbableElements = tabbable(container);
        if (tabbableElements.length) {
          tabbableElements[0].focus();
          focusChanged = true;
        } else if (isFocusable(container)) {
          container.focus();
          focusChanged = true;
        }
      }
      if (ajax.hasOwnProperty('element') && !focusChanged) {
        ajax.element.focus();
      }
    },
    invoke: function invoke(ajax, response, status) {
      var $element = $(response.selector);
      $element[response.method].apply($element, _toConsumableArray(response.args));
    },
    restripe: function restripe(ajax, response, status) {
      $(response.selector).find('> tbody > tr:visible, > tr:visible').removeClass('odd even').filter(':even').addClass('odd').end().filter(':odd').addClass('even');
    },
    update_build_id: function update_build_id(ajax, response, status) {
      document.querySelectorAll("input[name=\"form_build_id\"][value=\"".concat(response.old, "\"]")).forEach(function (item) {
        item.value = response.new;
      });
    },
    add_css: function add_css(ajax, response, status) {
      $('head').prepend(response.data);
    },
    message: function message(ajax, response) {
      var messages = new Drupal.Message(document.querySelector(response.messageWrapperQuerySelector));
      if (response.clearPrevious) {
        messages.clear();
      }
      messages.add(response.message, response.messageOptions);
    },
    add_js: function add_js(ajax, response, status) {
      var parentEl = document.querySelector(response.selector || 'body');
      var settings = ajax.settings || drupalSettings;
      var allUniqueBundleIds = response.data.map(function (script) {
        var uniqueBundleId = script.src + ajax.instanceIndex;
        loadjs(script.src, uniqueBundleId, {
          async: false,
          before: function before(path, scriptEl) {
            Object.keys(script).forEach(function (attributeKey) {
              scriptEl.setAttribute(attributeKey, script[attributeKey]);
            });
            parentEl.appendChild(scriptEl);
            return false;
          }
        });
        return uniqueBundleId;
      });
      return new Promise(function (resolve, reject) {
        loadjs.ready(allUniqueBundleIds, {
          success: function success() {
            Drupal.attachBehaviors(parentEl, settings);
            resolve();
          },
          error: function error(depsNotFound) {
            var message = Drupal.t("The following files could not be loaded: @dependencies", {
              '@dependencies': depsNotFound.join(', ')
            });
            reject(message);
          }
        });
      });
    }
  };
  var stopEvent = function stopEvent(xhr, settings) {
    return xhr.getResponseHeader('X-Drupal-Ajax-Token') === '1' && settings.isInProgress && settings.isInProgress();
  };
  $.extend(true, $.event.special, {
    ajaxSuccess: {
      trigger: function trigger(event, xhr, settings) {
        if (stopEvent(xhr, settings)) {
          return false;
        }
      }
    },
    ajaxComplete: {
      trigger: function trigger(event, xhr, settings) {
        if (stopEvent(xhr, settings)) {
          $.active++;
          return false;
        }
      }
    }
  });
})(jQuery, window, Drupal, drupalSettings, loadjs, window.tabbable);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
(function (Drupal) {
  Drupal.theme.ajaxProgressBar = function ($element) {
    return $element.addClass('ajax-progress ajax-progress-bar');
  };
})(Drupal);;
/**
 * @file
 * Aegon behaviors.
 */
Drupal = Drupal || {};
window.dataLayer = window.dataLayer || [];

(function ($, Drupal) {
  "use strict";

  $(document).ready(function () {
    // Initialize accordions.
    if ($(".aeon-accordion").length > 0) {
      aeon.accordion.init();
    }
  });
  Drupal.behaviors.aegonInit = {
    attach: function (context, settings) {
      aegonInit(context);
    }
  };
  Drupal.behaviors.aegonNav = {
    attach: function (context, settings) {
      aegonNav(context);
    }
  };
  Drupal.behaviors.aegonResize = {
    attach: function (context, settings) {
      aegonResize(context);
    }
  };
  Drupal.behaviors.aegonCollapse = {
    attach: function (context, settings) {
      aegonCollapse(context);
    }
  };
  Drupal.behaviors.aegonFirstSecondLastComp = {
    attach: function (context, settings) {
      aegonFirstSecondLastComp(context);
    }
  };
  Drupal.behaviors.aegonHeroImageShadow = {
    attach: function (context, settings) {
      aegonHeroImageShadow(context);
    }
  };
  Drupal.behaviors.aegonDeepDive = {
    attach: function (context, settings) {
      aegonDeepDive(context);
    }
  };
  Drupal.behaviors.aegonForms = {
    attach: function (context, settings) {
      aegonForms(context);
    }
  };
  Drupal.behaviors.aegonFundTabs = {
    attach: function (context, settings) {
      aegonFundTabs(context);
    }
  };
  Drupal.behaviors.aegonDsTabs = {
    attach: function (context, settings) {
      aegonDsTabs(context);
    }
  };
  Drupal.behaviors.aegonNavigationItems = {
    attach: function (context, settings) {
      aegonNavigationItems(context);
    }
  };
  Drupal.behaviors.aegonFileDownload = {
    attach: function (context, settings) {
      aegonFileDownload(context);
    }
  };
  Drupal.behaviors.aegonLimitedBreadcrumb = {
    attach: function (context, settings) {
      aegonLimitedBreadcrumb(context);
    }
  };
  Drupal.behaviors.aegonStickyCTA = {
    attach: function (context, settings) {
      aegonStickyCTA();
    }
  };

  function aegonStickyCTA(context) {
    let stickyElement = $('div[data-cta-sticky] > a');

    if (!stickyElement.length) {
      return;
    }

    $('div[data-cta-sticky]', context).once('cta-sticky').each(function () {
      // Construct sticky header.
      $('.layout-container').prepend('<div class="aeon-cta__sticky aeon-background-secondary-aqua"><div class="aeon-grid"><div class="aeon-grid__row"><div class="aeon-grid__col"></div></div></div></div>');
      let heroWithImageElement = stickyElement.closest('.aegon-hero-with-image');
      let stickyHeader = $('.aeon-cta__sticky');
      let headingText = !$('.cta-sticky--heading').length ? heroWithImageElement.find('.aeon-type-heading-l').text() : $('.cta-sticky--heading').text();
      stickyHeader.find('.aeon-grid__col').prepend('<h1 class="aeon-type-heading-s">' + headingText + '</h1>');
      heroWithImageElement.find('a.aeon-button').clone().appendTo(stickyHeader.find('.aeon-grid__col'));
      stickyHeader.find('a.aeon-button').removeClass().addClass('aeon-button aeon-button--icon aeon-button--medium aeon-margin-bottom-16 aeon-button--aeon-button--medium');
      stickyHeader.hide();

      window.onscroll = function () {
        let boundingElementTop = stickyElement[0].getBoundingClientRect().top;
        let elementTop = stickyElement.offset().top;
        let elementBottom = stickyElement.offset().top + stickyElement.outerHeight();
        let screenBottom = $(window).scrollTop() + $(window).innerHeight();
        let screenTop = $(window).scrollTop();

        if (screenBottom > elementTop && screenTop < elementBottom) {
          stickyHeader.removeClass('is-sticky').hide();
          $('#usbl-integrated-button').removeClass('present-sticky-cta');
          $('#block-aegonchatbot').removeClass('present-sticky-cta');
        } else {
          if (boundingElementTop >= 0) {
            stickyHeader.removeClass('is-sticky').hide();
            $('#usbl-integrated-button').removeClass('present-sticky-cta');
            $('#block-aegonchatbot').removeClass('present-sticky-cta');
          } else {
            stickyHeader.addClass('is-sticky').show();
            $('#usbl-integrated-button').addClass('present-sticky-cta');
            $('#block-aegonchatbot').addClass('present-sticky-cta');
          }
        }
      };
    });
  }

  function aegonNav(context) {
    "use strict"; //Main menu interactions

    $(".cms-mainnav__menu-link", context).on("click", function () {
      // Turn on backdrop
      $("#backdrop").addClass("cms__backdrop--open-by-mainnav"); // Clsoe nav search

      $(".nav-search.aegon-search-bar").addClass("d-none"); // reset active items

      $(".cms-mainnav__menu-item", context).removeClass("active-item"); // set selected item to active

      $(this, context).closest(".cms-mainnav__menu-item").addClass("active-item"); //  reset aria expanded

      $(".cms-mainnav__menu-link", context).attr("aria-expanded", "false"); // reset active sub item

      $(".cms-mainnav__menu-item--sub-item", context).removeClass("active-sub-item"); // reset left menu active state

      $(".cms-mainnav__menu-item--sub-item--heading-link", context).removeClass("active-state"); // reset right menu

      $(".cms-mainnav__menu-item--sub-item__right-nav", context).removeClass("active-right-menu-item active-right-menu-item--mobile"); // hide all left menu items on mobile

      $(".cms-mainnav__menu-item.active-item", context).find("div.cms-mainnav__menu-item--sub-item--heading-link").removeClass("d-none");
      $(".cms-mainnav__menu-item.active-item", context).find("div.cms-mainnav__menu-item--sub-item--external-link").removeClass("d-none"); // set active sub-item

      $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.cms-mainnav__menu-item--sub-item").addClass("active-sub-item"); //  set aria expanded true

      $(this, context).attr("aria-expanded", "true"); // On open set left menu active state active on first left menu item

      $(this, context).closest(".cms-mainnav__menu-item.active-item").find("a.cms-mainnav__menu-item--sub-item--heading-link").first().addClass("active-state"); // set active right menu item based on active left menu item

      $(this, context).closest(".cms-mainnav__menu-item.active-item").find("a.cms-mainnav__menu-item--sub-item--heading-link.active-state").closest(".aeon-grid__row").find("div.cms-mainnav__menu-item--sub-item__right-nav").addClass("active-right-menu-item"); // check menu height

      let height = $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.active-right-menu-item").height();
      $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.cms-mainnav__menu-item--sub-item").height(height); // After click Hide main menu items on mobile

      $(".cms-mainnav__menu-link", context).addClass("d-none d-lg-flex"); // mobile menu toggle aegon logo

      $(".mobile-menu-center .cms-mainnav__logo--mobile", context).addClass("d-none"); // show title as text of clicked link

      $(".mobile-menu-center .mobile-menu-center__title", context).removeClass("d-none");
      let title = $(this, context).text();
      $(".mobile-menu-center .mobile-menu-center__title", context).text(title); // toggle back buttons

      $(".cms-mainnav__back--level-1", context).removeClass("d-none");
      $(".cms-mainnav__back--level-2", context).addClass("d-none"); // Mobile slide in animation

      $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.active-sub-item").animate({
        right: 0
      }, "slow"); // Desktop only Interactions

      if ($(window).width() > 1279) {
        // Open hamburger menu
        $("#mainnav").addClass("cms-mainnav__menu--open"); // width update for right menu absolute container

        let containerWidth = $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.right-nav-target", context).width();
        $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.cms-mainnav__menu-item--sub-item__right-nav--container").width(containerWidth - 65);
      }
    }); //  Hamburger menu open

    $(".cms-mainnav__hamburger", context).on("click", function () {
      $(".nav-search.aegon-search-bar").addClass("d-none");
    }); // left menu interactions

    $(".cms-mainnav__menu-item--sub-item--heading-link", context).on("click", function () {
      if ($(window).width() > 1279) {
        // reset left menu active state and right menu active item
        $(".cms-mainnav__menu-item--sub-item--heading-link", context).removeClass("active-state");
        $(".cms-mainnav__menu-item--sub-item__right-nav", context).removeClass("active-right-menu-item active-right-menu-item--mobile"); // hide all left menu items on mobile

        $(".cms-mainnav__menu-item.active-item", context).find("a.cms-mainnav__menu-item--sub-item--heading-link").addClass("d-none");
        $(".cms-mainnav__menu-item.active-item", context).find("div.cms-mainnav__menu-item--sub-item--external-link").addClass("d-none"); // add left menu active state to selected left menu item

        $(this, context).addClass("active-state"); // set active state on right menu item of selected left menu item

        $(this, context).closest(".aeon-grid__row").find(".cms-mainnav__menu-item--sub-item__right-nav").addClass("active-right-menu-item active-right-menu-item--mobile"); // toggle back buttons

        $(".cms-mainnav__back--level-1", context).addClass("d-none");
        $(".cms-mainnav__back--level-2", context).removeClass("d-none"); // check menu height

        let height = $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.active-right-menu-item").height();
        $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.cms-mainnav__menu-item--sub-item").height(height); // width update for right menu absolute container

        let containerWidth = $(this, context).closest(".aeon-grid__row").find("div.right-nav-target", context).width();
        $(this, context).closest(".aeon-grid__row").find("div.cms-mainnav__menu-item--sub-item__right-nav--container").width(containerWidth - 65);
      }
    });
    $(".cms-mainnav__menu-item--sub-item--heading-link", context).on("mouseenter", function () {
      if ($(window).width() > 1279) {
        $(this).click();
      }
    }); // left menu mobile interactions

    $(".cms-mainnav__menu-item--sub-item--heading-link", context).on("click", function () {
      if ($(window).width() < 1280) {
        // reset left menu active state and right menu active item
        $(".cms-mainnav__menu-item--sub-item--heading-link", context).removeClass("active-state");
        $(".cms-mainnav__menu-item--sub-item__right-nav", context).removeClass("active-right-menu-item  active-right-menu-item--mobile"); // add left menu active state to selected left menu item

        $(this, context).addClass("active-state"); // hide all left menu items on mobile

        $(".cms-mainnav__menu-item.active-item", context).find("a.cms-mainnav__menu-item--sub-item--heading-link").addClass("d-none");
        $(".cms-mainnav__menu-item.active-item", context).find("div.cms-mainnav__menu-item--sub-item--external-link").addClass("d-none"); // set active state on right menu item of selected left menu item

        $(this, context).closest(".aeon-grid__row").find(".cms-mainnav__menu-item--sub-item__right-nav").addClass("active-right-menu-item active-right-menu-item--mobile"); // width update for right menu absolute container

        let containerWidth = $(this, context).closest(".aeon-grid__row").find("div.right-nav-target", context).width();
        $(".cms-mainnav__menu-item--sub-item__right-nav--container", context).width(containerWidth); // toggle back buttons

        $(".cms-mainnav__back--level-1", context).addClass("d-none");
        $(".cms-mainnav__back--level-2", context).removeClass("d-none"); // check menu height

        let height = $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.active-right-menu-item").height();
        $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.cms-mainnav__menu-item--sub-item").height(height); // slide in mobile animation

        $(this, context).closest(".cms-mainnav__menu-item.active-item").find("div.active-right-menu-item").animate({
          right: 0
        }, "slow");
      }
    }); // Close desktop expanded nav when you click away from the sub item menu

    $("#backdrop", context).on("click", function () {
      $("#backdrop").removeClass("cms__backdrop--open-by-mainnav");
      $("#backdrop").removeClass("cms__backdrop--open-by-topnav");
      $("#mainnav").removeClass("cms-mainnav__menu--open"); //  set aria expanded false

      $(".cms-mainnav__menu-link").attr("aria-expanded", "false"); // Close search

      $(".nav-search.aegon-search-bar").addClass("d-none");
      $(".nav-search.aegon-search-bar").removeClass("active"); // reset active items

      $(".cms-mainnav__menu-item", context).removeClass("active-item");
    }); // On close mobile menu

    $(".cms-mainnav__wrapper--mobile .cms-mainnav__close").on("click", function () {
      $("#mainnav").removeClass("cms-mainnav__menu--open");
      $("#backdrop").removeClass("cms__backdrop--open-by-mainnav"); //  reset menu to level 1

      $(".cms-mainnav__back--level-2", context).click();
      $(".cms-mainnav__back--level-1", context).click();
    }); //  Close nav on escape key press

    $(document).on("keydown", function (event) {
      if (event.key == "Escape") {
        $("#backdrop", context).click();
      }
    }); // back button level 1, hide left menu show main menu

    $(".cms-mainnav__back--level-1", context).on("click", function () {
      // show main menu items
      $(".cms-mainnav__menu-link", context).removeClass("d-none d-lg-flex"); // reset active items

      $(".cms-mainnav__menu-item", context).removeClass("active-item"); // toggle back button

      $(".cms-mainnav__back--level-1", context).addClass("d-none"); // mobile menu toggle aegon logo

      $(".mobile-menu-center .cms-mainnav__logo--mobile", context).removeClass("d-none"); // mobile menu toggle title text

      $(".mobile-menu-center .mobile-menu-center__title", context).addClass("d-none"); // reverse slide in animation

      $(".cms-mainnav__menu-item .active-sub-item", context).removeAttr("style");
    }); // back button level 2, hide right menu show left menu

    $(".cms-mainnav__back--level-2", context).on("click", function () {
      // show left menu
      $(".cms-mainnav__menu-item.active-item", context).find("a.cms-mainnav__menu-item--sub-item--heading-link").removeClass("d-none");
      $(".cms-mainnav__menu-item.active-item", context).find("div.cms-mainnav__menu-item--sub-item--external-link").removeClass("d-none"); // reverse slide in animation

      $(".cms-mainnav__menu-item.active-item .cms-mainnav__menu-item--sub-item__right-nav", context).removeAttr("style"); // hide right menu

      $(".cms-mainnav__menu-item--sub-item__right-nav", context).removeClass("active-right-menu-item--mobile"); // toggle back button

      $(".cms-mainnav__back--level-1", context).toggleClass("d-none");
      $(".cms-mainnav__back--level-2", context).toggleClass("d-none");
    });
  }

  function aegonResize(context) {
    $(window, context).once("aegonResize").resize(function () {
      // width update for right menu absolute container
      let containerWidth = $(".active-sub-item", context).find("div.right-nav-target", context).width();

      if ($(window).width() > 1279) {
        $(".active-right-menu-item", context).find("div.cms-mainnav__menu-item--sub-item__right-nav--container").width(containerWidth - 65); // Reset Mobile slide in animation left menu

        $(".cms-mainnav__menu-item.active-item", context).find("div.active-sub-item").css("right", ""); // Reset Mobile slide in animation right menu

        $(".cms-mainnav__menu-item", context).find("div.active-right-menu-item").css("right", "");
      } else {
        $(".cms-mainnav__menu-item--sub-item__right-nav--container").width(containerWidth); // Reset Mobile slide in animation left menu

        $(".cms-mainnav__menu-item.active-item", context).find("div.active-sub-item").css("right", 0); // Reset Mobile slide in animation right menu

        $(".cms-mainnav__menu-item.active-item", context).find("div.active-right-menu-item").css("right", 0);
      }

      if ($('.aeon-navigation-wrapper').length > 0) {
        toggleSideNavigationControls();
      }
    });
  }

  function aegonCollapse(context) {
    $(".collapsible", context).click(function () {
      $(".collapsible", context).toggleClass("active");
      $(".collapsible__content", context).slideToggle(300, function () {});
    });
  }

  function aegonFirstSecondLastComp(context) {
    $(".aeon-grid.component-spacing:first", context).addClass("first");
    $(".aeon-grid.component-spacing", context).eq(1).addClass("second");
    $(".aeon-grid.component-spacing:last", context).addClass("last"); // copy-block

    $(".copy-block", context).each(function () {
      $(this, context).find(".aeon-grid.component-spacing:first", context).addClass("copy-block__first");
      $(this, context).find(".aeon-grid.component-spacing", context).last().addClass("copy-block__last");
    });
  }

  function aegonHeroImageShadow(context) {
    if ($(".aegon-hero-with-image")) {
      $(".aegon-hero-with-image picture").once("aegonHeroImageShadow").after('<div class="cms-image-shadow"></div>');
    }

    if ($(".aegon-hero-with-full-image")) {
      $(".aegon-hero-with-full-image picture").once("aegonHeroImageShadow").after('<div class="cms-image-shadow"></div>');
    }
  }

  function aegonDeepDive(context) {
    $(".aeon-deep-dive__close", context).on("click", function () {
      let deepdive = $(".aeon-deep-dive", context);
      deepdive.removeClass("aeon-deep-dive--open"); // Push custom GTM event.

      let deepdiveID = deepdive.attr("id");
      pushDeepdiveGtmEvent(deepdiveID, "close");
    });
    $(".aeon-link", context).on("click", function (e) {
      if ($(this).data("deepdive")) {
        e.preventDefault();
        let deepdiveID = $(this).data("deepdive");
        document.getElementById(deepdiveID).classList.add("aeon-deep-dive--open"); // Push custom GTM event.

        pushDeepdiveGtmEvent(deepdiveID, "open");
      }
    });
    $(".aeon-button", context).on("click", function (e) {
      if ($(this).data("deepdive")) {
        e.preventDefault();
        let deepdiveID = $(this).data("deepdive");
        document.getElementById(deepdiveID).classList.add("aeon-deep-dive--open"); // Push custom GTM event.

        pushDeepdiveGtmEvent(deepdiveID, "open");
      }
    });
  }

  function aegonForms(context) {
    $("input.aeon-input__native-control").keyup(function () {
      if ($(this).val()) {
        $(this).addClass("hasValue");
      } else {
        $(this).removeClass("hasValue");
      }
    });
    $("input.aeon-input__native-control").on("change", function () {
      if ($(this).val()) {
        $(this).addClass("hasValue");
      } else {
        $(this).removeClass("hasValue");
      }
    });
    $("select.aeon-select__native-control").on("change", function () {
      if ($(this).val()) {
        $(this).addClass("hasValue");
      } else {
        $(this).removeClass("hasValue");
      }
    });
    $(":input").each(function () {
      if ($(this).val()) {
        $(this).addClass("hasValue");
      } else {
        $(this).removeClass("hasValue");
      }
    });
  }

  function aegonFundTabs(context) {
    $(".funds-listing-table-component").each(function (index) {
      let id = $(this).attr("id");
      $("#" + id + " li a:not(:first)").addClass("inactive");
      $("#" + id + " .fundtabcontent").hide();
      $("#" + id + " .fundtabcontent:first").show();
      $("#" + id + " li a").click(function () {
        var t = $(this).attr("id");

        if ($(this).hasClass("inactive")) {
          //this is the start of our condition
          $("#" + id + " li a").addClass("inactive");
          $(this).removeClass("inactive");
          $("#" + id + " .fundtabcontent").hide();
          $("#" + id + " #" + t + "Content").fadeIn("slow");
        }
      });
    });
  }

  function aegonDsTabs(context) {
    $(".aeon-tabs", context).each(function (index, tabsItem) {
      let tabsTitles = "";
      let tabsContent = "";
      let tabsTitlesWrapper = "ul.aeon-tabs__list";
      let tabsContentWrapper = ".aeon-tabs__panels";
      let tabCanvas = $(tabsItem, context).find(".tab-canvas");
      tabCanvas.each(function (tabIndex, item) {
        let tabTitle = {
          content: $(item).find(".tab-title").html(),
          tabId: $(item).find(".tab-title").data("tab-id")
        };
        let tabContent = {
          content: $(item).find(".tab-content").html(),
          tabId: $(item).find(".tab-content").data("tab-id")
        };
        tabsTitles += Drupal.theme.DsTabTitle(tabTitle["content"], tabTitle["tabId"], tabIndex);
        tabsContent += Drupal.theme.DsTabContent(tabContent["content"], tabContent["tabId"], tabIndex);
      });
      $(this).find(tabsTitlesWrapper).html(tabsTitles);
      $(this).find(tabsContentWrapper).html(tabsContent);
    });

    if ($(".aeon-tabs", context).length) {
      aeon.tabs.init(); // Set default tab for klantenservice page.

      setDefaultTab(); // Call deepdive function to register events.

      aegonDeepDive(context);
    }
  }

  Drupal.theme.DsTabTitle = function (content, tabId, index) {
    let active = index === 0 ? "aeon-tabs__tab--active" : "";
    let elementTitle = content.trim().replace(/ /g, "_").replace("/[^wd_-]+/g", "").toLowerCase();
    return "" + " <li class='aeon-tabs__list-item'>" + `  <button class='aeon-tabs__tab ${active}' id='tab-${tabId}' role="tab" aria-controls="panel-${tabId}" data-cat="tab" data-lab="${elementTitle}">` + "   <span class='aeon-tabs__tab-title'>" + content + "   </span>" + "  </button>" + "</li>";
  };

  Drupal.theme.DsTabContent = function (content, tabId, index) {
    let active = index === 0 ? "aeon-tabs__panel--active" : "";
    return "" + `<div class='aeon-tabs__panel ${active}' id='panel-${tabId}' role="tabpanel" aria-labelledby="tab-${tabId}">` + content + "</div>";
  };

  function aegonNavigationItems(context) {
    $(".aeon-navigation-items", context).once('aeon-side-navigation').each(function () {
      // Hide wrapper until render is done.
      $('.aeon-navigation-wrapper').parent().hide();
      let sideNavigationList = $('.aeon-side-navigation__list');
      let sideNavigationSelectList = $('div.aeon-side-navigation__select-list');
      let sideNavigationContent = $('.aeon-side-navigation-content');
      let navItemLinks = '',
          navContents = '',
          navSelectListContents = '';
      $('.aeon-navigation-items .nav-item-wrapper').each(function (index, item) {
        let nid = 'nav-item-' + index;
        let navItemContent = {
          content: $(item).find('.nav-item-content').html(),
          id: nid
        };
        let navItemTitle = {
          content: $(item).find('.nav-item-title').html(),
          navItemId: nid
        };
        navItemLinks += Drupal.theme.navItemLink(navItemTitle['content'], navItemTitle['navItemId'], index);
        navContents += Drupal.theme.navItemContent(navItemContent['content'], navItemContent['id'], index);
        navSelectListContents += Drupal.theme.navSelectListItem(navItemTitle['content'], navItemTitle['navItemId'], index);
      });
      sideNavigationList.html(navItemLinks);
      sideNavigationContent.html(navContents);
      sideNavigationSelectList.find('select').html(navSelectListContents);
      registerSideNavigationEvents(); // Hide component loader.

      $('.aeon-load-more__spinner').hide();
      $('.aeon-navigation-wrapper').parent().show();
      toggleSideNavigationControls();
    });
  }

  function toggleSideNavigationControls() {
    if (window.matchMedia("only screen and (max-width: 840px)").matches) {
      $('div.aeon-side-navigation__select-list').removeClass('visually-hidden');
      $('ul.aeon-side-navigation__list').addClass('visually-hidden');
    } else {
      $('ul.aeon-side-navigation__list').removeClass('visually-hidden');
      $('div.aeon-side-navigation__select-list').addClass('visually-hidden');
    }
  }

  Drupal.theme.navItemLink = function (content, navItemId, index) {
    let fragment = window.location.hash.substring(1);
    let active = fragment === '' && index === 0 || fragment === navItemId ? 'aeon-side-navigation--active' : '';
    return '' + '<li class="aeon-side-navigation__item">' + `<a class="${active} aeon-side-navigation__link" href="#${navItemId}">` + content.trim() + '<svg class="aeon-side-navigation__icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><use href="#forward"></use></svg>' + '</a>' + '</li>';
  };

  Drupal.theme.navItemContent = function (content, navItemId, index) {
    let fragment = window.location.hash.substring(1);
    let active = fragment === '' && index === 0 || fragment === navItemId ? '' : 'visually-hidden';
    return `<div class="aegon-nav-item-content-wrapper ${active}" id="${navItemId}">${content}</div>`;
  };

  Drupal.theme.navSelectListItem = function (content, navItemId, index) {
    return '<option value="' + index + '" data-target-content-id="' + navItemId + '">' + content.trim() + '</option>';
  };

  function registerSideNavigationEvents() {
    // Default select value when fragment is present.
    let fragment = window.location.hash.substring(1);

    if (fragment === '') {
      $('.aeon-side-navigation__select-list select').val(0);
    } else {
      $('.aeon-side-navigation__select-list select').val(fragment.slice(-1));
    } // Register click event.


    $('.aeon-side-navigation__link').click(function () {
      let href = $(this).attr('href');

      if (!$(this).hasClass('aeon-side-navigation--active')) {
        $(this).closest('ul').find('.aeon-side-navigation__link').removeClass('aeon-side-navigation--active');
        $(this).addClass('aeon-side-navigation--active');
        $('.aegon-nav-item-content-wrapper').addClass('visually-hidden');
        $(href).removeClass('visually-hidden');
        $('.aeon-side-navigation__select-list select').val(href.slice(-1));
      }
    }); // Register select event.

    $('.aeon-side-navigation__select-list .aeon-select__native-control').on('change', function () {
      let id = $(this).find(":selected").data('target-content-id');
      $('.aegon-nav-item-content-wrapper').addClass('visually-hidden');
      $('#' + id).removeClass('visually-hidden');
      $('#' + id).closest('.aeon-navigation-wrapper').find('.aeon-side-navigation__link').removeClass('aeon-side-navigation--active');
      $('[href="#' + id + '"]').addClass('aeon-side-navigation--active');
    });
  }

  function aegonInit(context) {
    const addIcons = function () {
      var i = document.querySelectorAll("span[class^=icon--]");
      i.forEach(addAnIcon);
    };

    const addAnIcon = function (s) {
      /* s = span tag element. add the svg. */
      s.innerHTML = '<svg class="aeon-link__icon"><use xlink:href="#' + s.classList[0].replace("icon--", "") + '" /></svg>';
    };

    const initMenus = function () {
      const topNavActiveLink = document.getElementById("topnav-activelink");
      const hamburgerElement = document.getElementById("hamburger");
      const backdrop = document.getElementById("backdrop");

      if (topNavActiveLink) {
        /* The first child element within in the list-item is a hyperlink. */
        topNavActiveLink.addEventListener("click", function (e) {
          e.preventDefault();
          /* = do NOT follow this link, but only open the top navigation. */
          // this.nextElementSibling.classList.toggle(
          //   "cms-topnav__menu-icon--close"
          // ); /* chevron */

          document.getElementById("topbar").classList.toggle("cms-topbar--open");
          document.getElementById("topnav").classList.toggle("cms-topnav__menu--open");
          document.getElementById("backdrop").classList.toggle("cms__backdrop--open-by-topnav");
        });
      }

      if (hamburgerElement) {
        /* The hamburger of the main navigation can NOT be clicked when topnav menu is open (overlapping the hamburger). */
        hamburgerElement.addEventListener("click", function (e) {
          document.getElementById("mainnav").classList.toggle("cms-mainnav__menu--open");
          document.getElementById("backdrop").classList.toggle("cms__backdrop--open-by-mainnav");
        });
      }

      if (backdrop) {
        /* Clicking on the backdrop layer will close both top and main navigation, and remove itself. */
        backdrop.addEventListener("click", function (e) {
          document.getElementById("topbar").classList.remove("cms-topbar--open");
          document.getElementById("topnav").classList.remove("cms-topnav__menu--open"); // document
          //   .getElementById("topnav-activelink")
          //   .nextSibling.classList.remove("cms-topnav__menu-icon--close");

          document.getElementById("mainnav").classList.remove("cms-mainnav__menu--open");
          document.getElementById("backdrop").classList.remove("cms__backdrop--open-by-topnav", "cms__backdrop--open-by-mainnav");
        });
      }
    };
    /* Close a specific backdrop layer if clicked. */


    const addBdClose = function (s) {
      s.addEventListener("click", function () {
        this.parentElement.classList.remove("aeon-deep-dive--open"); // Push custom GTM event.

        pushDeepdiveGtmEvent(this.parentElement.id, "close");
      });
    };
    /* Select all backdrop div's for adding click event (if present). */


    const addBdClicks = function () {
      /* add click-event to back-drop layers */
      var i = document.querySelectorAll("div[class^=aeon-deep-dive__backdrop]");
      i.forEach(addBdClose);
    };

    const initSite = function () {
      addIcons();
      initMenus();
      addBdClicks();
    };

    $(window, context).once("aegonInit").each(function () {
      initSite();
    });
  }

  function pushDeepdiveGtmEvent(deepdiveID, action) {
    let title = $('[data-deepdive="' + deepdiveID + '"]').first().text().trim(); // Push event to dataLayer.

    window.dataLayer.push({
      event: "custom_event",
      event_category: "deep_dive",
      event_action: action,
      event_label: title,
      event_type: "element",
      event_non_interaction: action === "open"
    });
  }

  function SaveToDisk(fileURL, fileName) {
    // for non-IE
    if (!window.ActiveXObject) {
      var save = document.createElement("a");
      save.href = fileURL;
      save.target = "_blank";
      save.download = fileName || "unknown";
      var evt = new MouseEvent("click", {
        view: window,
        bubbles: true,
        cancelable: false
      });
      save.dispatchEvent(evt);
      (window.URL || window.webkitURL).revokeObjectURL(save.href);
    } // for IE < 11
    else if (!!window.ActiveXObject && document.execCommand) {
      var _window = window.open(fileURL, "_blank");

      _window.document.close();

      _window.document.execCommand("SaveAs", true, fileName || fileURL);

      _window.close();
    }
  }

  function aegonFileDownload(context) {
    $(".file a", context).on("click", function (e) {
      e.preventDefault();
      let fileUrl = $(this, context).attr("href");
      let fileName = $(this, context).text();
      SaveToDisk(fileUrl, fileName);
    });
  }

  function setDefaultTab() {
    let index = getUrlParameter('qt');

    if (Number.isInteger(parseInt(index)) === true) {
      let tabs = $(".aeon-tabs__list li button");
      let maxLength = tabs.length;
      index -= 1;

      if (index > 0 && index <= maxLength) {
        tabs[index].click();
      }
    }
  }

  function getUrlParameter(sParam) {
    let sPageURL = window.location.search.substring(1),
        sURLVariables = sPageURL.split('&'),
        sParameterName,
        i;

    for (i = 0; i < sURLVariables.length; i++) {
      sParameterName = sURLVariables[i].split('=');

      if (sParameterName[0] === sParam) {
        return typeof sParameterName[1] === undefined ? true : decodeURIComponent(sParameterName[1]);
      }
    }

    return false;
  }

  ;

  function aegonLimitedBreadcrumb(context) {
    let breadcrumbWrapper = $($('.aegon-breadcrumb').closest('.aeon-grid')[0]);

    if (!breadcrumbWrapper.length) {
      return;
    } // Override padding-top property (set to zero) in case of component spacing.


    let element = breadcrumbWrapper.next().find('.component-spacing');

    if (element.length > 0) {
      $(element[0]).css('padding-top', '0');
    } // In case of multiple rendered breadcrumbs due to USP banners, keep only the first one.


    $('.aegon-breadcrumb').closest('.aeon-grid').not(':first').remove();
  }
})(jQuery, Drupal);;
/*
  Cookiewall usage.

  Right below where jquery is loaded add the cookiewall.js script import tag.

  After that add the following below the cookiewall.js import.
    * When a page needs to be excluded from the cookiewall, don't run the initialize function.

  <script>cookieWall.initialize('/', 'aegon.nl', 'http://my/optional/custom/content/url');</script>

  The initialize function parameters are:
    * Cookie path
    * Cookie domain
    * Optional custom content URL that contains the JSON data for the cookiewall popup content.

  The initialize function will check if the cookie exists and if not will render the cookiewall. A choice then needs
  to be made for basis ('S'), optimaal ('E') or realistic ('R')

  Depending on what choice has been made scripts can be loaded or not. The cookiewall can
  handle this. Instead of injecting the js file with a normal <script> tag. Use the following:

  <script>cookieWall.addScript('scripts/aegon-somescript.js', 'E', { async: false, attrs: { some: 'thing'} })</script>

  The addScript function needs the url and cookie value (E,R or S) and loads js files async or not. Attrs will be added
  to the element being created.

*/


//create global namespace.
window.cookieWall = {};
cookieWallInit = false;

(function ($, CW) {

  var getScriptHostname = function () {
    // Retrieve script src and use regex to match the hostname of the url.
    let url = document.querySelector('script[src*="aegon-cookie-compliance.js"]');
    if (url) {
      let matches = url.src.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i);
      return matches && matches[0];
    }
    else {
      return '/';
    }

  }

  $(document).ready(function() {
    if (!cookieWallInit) {
      params = {
        basePath: '/',
        cookieEndpoint: getScriptHostname() + 'data/cookiewall/cookieribbon/cookieribbon.json',
        domain: 'aegon.nl'
      };

      cookieWall.initialize(params.basePath, params.domain, params.cookieEndpoint);
      cookieWallInit = true;
    }
  })

  'use strict';
  // When retrieving the cookie and it exist, store the value.
  var cookieValue,
    whitelisted = true,
    path,
    domain,
    hostname = getScriptHostname() || '/',
    customCookieContentURL,
    COOKIE_NAME = 'AEGON.Cookie.OptIn',
    COOKIE_VALUE_LIST = 'SRE',
    COOKIE_VALUE_STANDARD = 'S',
    COOKIE_VALUE_REALISTIC = 'R',
    COOKIE_VALUE_EXTENDED = 'E',
    COOKIE_12MONTHS_FLAG = 'OptIn.12m',
    DEFAULT_COOKIE_CONTENT_URL = hostname + 'data/cookiewall/cookie/cookietext.json', /* Cookie wall */
    DEFAULT_COOKIE_RIBBON_URL = hostname + 'data/cookiewall/cookieribbon/cookieribbon.json'; /* Cookie ribbon */

  /**
   * Cookie helper functions.
   * Creates a cookie that expires in a certain amount of days.
   * @param name {string} the name of the cookie
   * @param value {any} the value of the cookie
   * @param days {number} the expiration date in days
   */
  CW.setCookie = function (name, value, days) {
    days = days ? days : 3;
    var d = new Date();
    d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
    var expires = 'expires=' + d.toUTCString();

    var _path = path || '/';
    var cookie = name + '=' + value + ';' + expires + ';path=' + _path + ';SameSite=None;Secure';

    if (domain && domain !== 'localhost') {
      cookie += ';domain=' + domain;
    }
    cookie += '; ';

    document.cookie = cookie;
  };

  /**
   * Searches for the specified cookie and returns its value if exists
   * or null if it does not exist.
   * @param name {string} the name of the cookie
   * @returns {*}
   */
  CW.getCookie = function (name) {
    name = name + '=';
    var cookieArray = document.cookie.split(';');
    for (var i = 0; i < cookieArray.length; i++) {
      var cookie = cookieArray[i];
      // Remove space between cookies.
      while (cookie.charAt(0) === ' ') {
        cookie = cookie.substring(1);
      }
      // Cookie found? Return the cookie value.
      if (cookie.indexOf(name) === 0) {
        return cookie.substring(name.length, cookie.length);
      }
    }
    // No cookie found.
    return null;
  };

  /**
   * Gets the content from Drupal and adds the cookie content
   * element to the DOM if request is successful.
   *
   * @param pageToShow section to show. advanced or basic.
   */
  CW.showCookieWall = function (pageToShow) {

    if (pageToShow === void 0 || !pageToShow.toUpperCase().match(/^(?:S|E)$/)) {
      pageToShow = (this.cookieValue && this.cookieValue.toUpperCase() === COOKIE_VALUE_EXTENDED) ? 'advanced' : null;
    }

    var cookieWallElm = $('.blocking-popup.cookie-wall');
    if (cookieWallElm.length > 0) {
      // The cookiewall is already visible.
      return;
    }

    // Fetch cookiewall content.
    $.ajax({
      type: 'GET',
      dataType: 'json',
      global: false,
      crossDomain: true,
      url: customCookieContentURL || DEFAULT_COOKIE_CONTENT_URL,
      success: function (response) {
        // response = JSON.parse(response);
        if (response.cookietext) {
          // Create and add container elements for the cookiewall content.
          var rootElm = $('<div class="cookie-wall blocking-popup"></div>');
          var containerElm = $('<div class="popup-container"></div>').appendTo(rootElm);
          $('body').prepend(rootElm);

          // The cookiewall is going to be presented. Make sure the page cannot scroll.
          var styleElm = document.createElement('style');
          styleElm.innerHTML = 'body, html { height: 100%; }';
          $('head').append(styleElm);
          containerElm.html(response.cookietext);

          if (Drupal && Drupal.settings && Drupal.settings.fromPagesNotInDrupal) {
            $('head').append('<link rel="stylesheet" type="text/css" href="/sites/all/themes/aegon_theme/dist/css/aegon_theme-additions.css">');
          }

          // accordion effect for content
          $('.cookie-options-container .accordion-head, .cookie-options-container .cx-accordion-header-arrow').on('click', function () {
            $(this).closest('.cookie-option').find('.accordion-content').slideToggle();
            $(this).closest('.cookie-option').siblings().find('.accordion-content').slideUp();

            $(this).closest('.cookie-option').find('.cookie-option-header span').toggleClass('cx-icon-chevron-up');
            if ($(this).closest('.cookie-option').siblings().find('.accordion-content')) {
              $(this).closest('.cookie-option').siblings().find('span').removeClass('cx-icon-chevron-up').addClass('cx-icon-chevron-down');
            }
          });
          dataLayer.push({
            'event': 'custom_event',
            'event_category': 'modal',
            'event_action': 'show',
            'event_label': 'cookie_wall',
            'event_value': '',
            'event_type': 'consent',
            'event_non_interaction': 'true'
          });

          aeon.accordion.init();
        }
      },
      error: function () {
        console.warn('Cannot get cookie wall content');
      }
    });
  };

  CW.showCookieRibbon = function () {
    var cookieRibbonElm = $('#cribbon');
    if (cookieRibbonElm.length > 0) {
      // The cookie ribbon is already visible.
      return;
    }
    $.ajax({
      type: 'GET',
      dataType: 'json',
      global: false,
      crossDomain: true,
      url: DEFAULT_COOKIE_RIBBON_URL,
      success: function (response) {
        if (response.cookieribbon) {
          // Add cookie ribbon html to body. That's all.
          $('body').append(response.cookieribbon);
          dataLayer.push({
            'event': 'custom_event',
            'event_category': 'modal',
            'event_action': 'show',
            'event_label': 'cookie_ribbon',
            'event_value': '',
            'event_type': 'consent',
            'event_non_interaction': 'true'
          });
        }
      },
      error: function () {
        console.warn('Cannot get cookie ribbon content');
      }
    });
  }

  /**
   * Indicates whether the cookie was saved or not.
   * @type {boolean}
   */
  CW.cookieOptionSaved = false;
  /**
   * Sets a cookie with the user's choice for cookies.
   */
  CW.saveCookieChoice = function (ribbonchoice) {
    if (this.cookieOptionSaved) {
      return;
    }

    let selectedOption;
    if (ribbonchoice && COOKIE_VALUE_LIST.indexOf(ribbonchoice) >= 0) {
      selectedOption = ribbonchoice;
    } else {
      var selectedRadioButton = $('.cookie-options-container input:radio[name=cookieval]:checked').val();
      var selectedCookie = selectedRadioButton ? selectedRadioButton.toLowerCase() : null;

      // Assigning selected cookie option
      selectedOption = selectedCookie === 'optimaal' ? COOKIE_VALUE_EXTENDED : selectedCookie === 'redelijk' ? COOKIE_VALUE_REALISTIC : selectedCookie === 'basic' ? COOKIE_VALUE_STANDARD : null;
    }

    if (selectedOption) {
      /**
       * AEVA-573 | overwrite the existing cookie duration to 12 months,
       * and create one cookie (COOKIE_12MONTHS_FLAG) for updation status.
       **/
      this.setCookie(COOKIE_NAME, selectedOption, 12 * 30);
      this.setCookie(COOKIE_12MONTHS_FLAG, 'true', 12 * 30);

      this.cookieOptionSaved = true;

      var reload = function () {
        window.location.reload();
      };

      $.ajax({
        type: 'POST',
        dataType: 'text',
        global: false,
        url: hostname + 'lpa/CookieVoorkeur',
        data: 'ans=' + selectedOption,
        success: reload,
        error: reload,
        always: reload
      });

    }
  };

  /*
   * Transfers the control to load the cookie wall from the ribbon
   */
  CW.linkToCookieWall = function () {
    document.getElementById('cribbon').style.display = 'none';
    this.initialize('/', 'aegon.nl', DEFAULT_COOKIE_CONTENT_URL, 'advanced', 'ribbon');
  };

  /*
   Run the initialize function prior to scripts that need to be included conditionally. Make sure Jquery is available.
   <script>cookieWall.initialize('/', 'aegon.nl')<script>
   */
  CW.initialize = function (_path, _domain, _customCookieContentURL, pageToShow, redirectFrom) {
    path = _path;
    domain = _domain;
    whitelisted = false;
    cookieValue = this.getCookie(COOKIE_NAME);
    var styleElm = document.createElement('style');

    if (cookieValue === null && redirectFrom === undefined) {
      this.showCookieRibbon();
    } else if (cookieValue === null && redirectFrom) {
      this.showCookieWall();
    } else {
      this.cookieValue = cookieValue;
      if (this.cookieValue.toUpperCase() === COOKIE_VALUE_STANDARD || this.cookieValue.toUpperCase() === COOKIE_VALUE_REALISTIC) {
        styleElm.innerHTML = '[data-cookie-optimal] { display: none !important; }';
      }

      // Check for the flag cookie COOKIE_12MONTHS_FLAG exists or overwrite the COOKIE_NAME cookie to 12 months duration
      var cookieFlagVal = this.getCookie(COOKIE_12MONTHS_FLAG);
      if (cookieFlagVal === null) {
        var cookieStoredOption = this.getCookie(COOKIE_NAME);
        this.setCookie(COOKIE_NAME, cookieStoredOption, 12 * 30);
        this.setCookie(COOKIE_12MONTHS_FLAG, 'true', 12 * 30);
      }
    }
    $('head').append(styleElm);

    if (pageToShow && cookieValue) {
      this.showCookieWall(pageToShow);
    }
  };

  CW.getOptions = function (options) {

    if (options === void 0) {
      options = {};
    }
    if (options.async === void 0) {
      options.async = true;
    }
    if (options.attrs === void 0) {
      options.attrs = {};
    }

    return options;
  };

  CW.isAppendable = function (requiredCookieOption) {

    var append = false;
    if (requiredCookieOption === void 0) {
      requiredCookieOption = COOKIE_VALUE_STANDARD;
    }
    if (!cookieValue) {
      cookieValue = this.getCookie(COOKIE_NAME);
    }

    if (cookieValue) {
      var indexOfCookieValue = COOKIE_VALUE_LIST.indexOf(cookieValue.toUpperCase());
      var indexOfrequiredCookieOption = COOKIE_VALUE_LIST.indexOf(requiredCookieOption.toUpperCase());

      if (indexOfCookieValue >= indexOfrequiredCookieOption) {
        append = true;
      }
    } else if (whitelisted && requiredCookieOption.toUpperCase() === COOKIE_VALUE_STANDARD) {
      // No cookie was set, but because the page is whitelisted (the initialize function hasn't been called yet)
      // and the desired cookie option is standard, we can append the script.
      append = true;
    }

    return append;
  };

  CW.addScript = function (url, requiredCookieOption, options) {
    /* Add the following line in the head to load a script in the page.
     <script>cookieWall.addScript('scripts/aegon-angular2.js', 'E', { async: false, attrs: {} })</script>
     Scripts with async false will be loaded immediately before dom rendering.
     Attrs will be added on the generated element if needed.
     */
    var append = this.isAppendable(requiredCookieOption);
    var appendOptions = this.getOptions(options);
    if (append) {
      var elm = document.createElement('script');
      elm.src = url;
      var attrKeys = Object.keys(appendOptions.attrs);
      for (var i = 0; i < attrKeys.length; i++) {
        elm[attrKeys[i]] = appendOptions.attrs[attrKeys[i]];
      }
      if (appendOptions.async) {
        $('head').append(elm);
      } else {
        document.write(elm.outerHTML);// jshint ignore:line
      }
    }
  };

  CW.addContent = function (content, requiredCookieOption, options) {
    /* Appends the recieved content to the id send by the Drupal Backend
     */
    var append = this.isAppendable(requiredCookieOption);
    var appendOptions = this.getOptions(options);
    if (content && append && appendOptions.attrs.id) {
      $('#' + appendOptions.attrs.id).append(content);
      $('iframe[src*="youtube"]').parent().fitVids();
    } else {
      console.log(appendOptions.attrs.id + ' Id not available on document');
    }
  };
})(jQuery, window.cookieWall);
;
// Complete port of D7 implementation.
(function ($) {
  let masks = [
    /(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/g,
    /[+]?\d{10,18}/g,
    /(\d{4})\s*(([a-z]{2})|([A-Z]{2}))/g
  ];

  Drupal.behaviors.usabilla_button = {
    attach: function (context, settings) {
        $('#usbl-integrated-button', context).click(function () {
        window.usabilla_live("click");
        window.usabilla_live("setDataMasking", masks);
    });
   }
  };
}(jQuery));
;
// Complete port of D7 implementation.
// @todo: Needs rewrite.
(function ($, Drupal) {
  function loadCss(css) {
    var s = document.createElement('link');
    s.rel = 'stylesheet';
    s.type = 'text/css';
    s.href = css;
    s.media = 'all';
    document.getElementsByTagName('head')[0].appendChild(s);
  }

  function loadChatbot(js, integrity, crossorigin, options) {
    var s = document.createElement('script');
    s.src = js;
    s.type = 'text/javascript';
    s.async = false;
    /* if (typeof(integrity)==='string') { s.integrity=integrity; } */
    /* if (typeof(crossorigin)==='string') { s.crossorigin=crossorigin; } */
    if (typeof (options) === 'string') {
      document.addEventListener('va:init', function (event) {
        var bot_json = {
          audience: "customer",
          knowledgeDB: "kare",
          dialog: "dialog.default",
          clientContext: "",
          openOnInit: false,
          zIndex: 1000
        };
        /* check for Zakelijk, to set the context */
        var isZakelijk = (window.location.pathname.substring(0, 10) === "/zakelijk/");
        if (isZakelijk) {
          bot_json.clientContext = (drupalSettings.page_context.va.product) ? drupalSettings.page_context.va.product : "Aegon_zakelijk";
          /* For Zakelijk, always use digitalCX, regardless of what happened on a previous (particulier) page. */
          bot_json.knowledgeDB = "digitalCX";
          bot_json.audience = "business";
        }
        /* pass skill url param to init for new bot (if present).  */
        var botV2dialog = new URL(document.location).searchParams.get("botV2_chat_skill");
        if (botV2dialog) {
          bot_json.dialog = "dialog.livechat." + botV2dialog;
          bot_json.openOnInit = true;
        }
        /* pass kyc dialog on 3 pages */
        var kycpath = new RegExp("^\/particulier\/klantenservice\/(id|waarom-stopt-aegon-sparen|informatie-aanleveren)");
        if (kycpath.test(window.location.pathname)) {
          console.log('Start the KYC dialog.');
          bot_json.dialog = "dialog.kyc";
        }
        VA.init(bot_json);
        setTimeout(function () {
          window.dispatchEvent(new Event('startLiveChatIfRequired'));
        }, 2000);
      });
    }
    document.getElementsByTagName('body')[0].appendChild(s);
  }

  function initbot20(context) {
    $("#virtual-assistant-new", context).attr("style", "display:initial;padding:0");
    $('#va-component', context).attr('visibility', 'visible');
    $('#va-button-panel', context).attr('style','display:none');
    $('#va-sidenav', context).attr('style', 'z-index:10003');
    var bgovl = $('background-overlay', context);
    bgovl.remove();
    document.getElementById('va-sidenav').style.top = "0px";
    if (document.cookie.indexOf('AEGON.Cookie.OptIn') >= 0) {
      /* only load chatbot if cookies were already accepted. */
      loadCss('https://cdn.axlops.nl.aegon.io/css/icons.css');
      loadChatbot('https://cdn.botframework.com/botframework-webchat/4.13.0/webchat.js');
      loadChatbot(drupalSettings.aegon_chatbot_app_url, false, false, 'initbot');
    }
  }

  var countupdatechatbutton = 0;

  function updatechatbutton() {
    countupdatechatbutton++;
    cb = document.querySelectorAll("div.button-bottom>a[href='#chat-met-medewerker']");
    var advicepath = new RegExp("^\/particulier\/hypotheek\/advies-van-aegon");
    if (cb.length === 1) {
      cb[0].href = advicepath.test(window.location.pathname) ?
        "javascript:VA.sendMessage({ value: { dialog: 'dialog.livechat.advice' } });" :
        "javascript:VA.startLiveChat();"
      cb[0].removeAttribute("onclick");
      console.log('chatbutton in content is changed to call new bot');
    } else {
      console.log('chatbutton in content not found.');
      if (countupdatechatbutton < 5) {
        console.log('try again after 1 second.');
        setTimeout(updatechatbutton, 1000);
      }
    }
  }

  function conditionallyStartLiveChat() {
    if ((/^(#chat-met-medewerker)/).test(location.hash) &&
      (new RegExp("^\/particulier\/hypotheek\/advies-van-aegon")).test(location.pathname)) {
      VA.sendMessage({value: {dialog: 'dialog.livechat.advice'}});
    } else if ((/^(#chat-met-medewerker)/).test(location.hash)) {
      VA.startLiveChat();
    }
  }

  window.addEventListener('startLiveChatIfRequired', conditionallyStartLiveChat, {
    once: true
  });

  Drupal.behaviors.aegonChatbot = {
    attach: function (context, settings) {
      let path = new RegExp("^\/(part|over|zoek|search|voor-adviseurs)");
      if (path.test(window.location.pathname)) {
        initbot20(context);
        setTimeout(updatechatbutton, 1000);
      }
    }
  }

}(jQuery, Drupal));
;
// Complete port of D7 implementation.
// @todo: Needs rewrite.
(function($, Drupal) {
  Drupal.Chatbot = {};

  /**
   * Open/Close sidebar logic
   * @param action: string
   */
  Drupal.Chatbot.chatbot_sidebar_actions = function(action) {
    var $html = $('html');
    var $sidenav = $('#va-sidenav');
    var $overlay = $('#background-overlay');
    var $notifications = $('.notifications');

    switch(action) {
      case 'open':
        $sidenav.addClass('va-sidenav--expanded');
        $notifications.removeClass('notifications--visible');
        $overlay.show();

        //clear the unread notifications counter
        sessionStorage.setItem('vaIsOpened', 'true');
        sessionStorage.setItem('unreadMessages', '0');

        if(drupalSettings.chatbot.page_context.domain === 'zakelijk'){
          const product = window && window.Drupal && window.drupalSettings &&
            window.drupalSettings.page_context;
          if(window && window.VA) {
            product ? window.VA.startLiveChat({ skill: product}) : window.VA.startLiveChat()
          }
        }

        //hide the general scrollbar, prevent ui from 'jumping' effect by adding right padding replacing the hidden scrollbar
        $html.css('padding-right', window.innerWidth - $html.width()); // calculate the scrollbar width as it is different for different browsers
        $html.css('overflow-y', 'hidden');
        break;
      case 'close':
        $sidenav.removeClass('va-sidenav--expanded');
        $overlay.hide();
        sessionStorage.setItem('vaIsOpened', 'false');

        //show the general scroll back
        $html.css('padding-right', '0');
        $html.css('overflow-y', 'auto');
        break;
      case 'display-va-popup':
        // displays the popup to open VA
        var chatbotModalContainer = $('.chatbot-popup-container');
        chatbotModalContainer = chatbotModalContainer.length > 0 && chatbotModalContainer[0];
        chatbotModalContainer && chatbotModalContainer.classList && chatbotModalContainer.classList.remove('chatbot-hideModal');
        break;
      case 'display-va-popup-with-chatagent':
        // displays the popup to open VA, with option to liveagent triggered
        var livechatContainer = $('.livechat-popup-container');
        livechatContainer = livechatContainer.length > 0 && livechatContainer[0];
        livechatContainer && livechatContainer.classList && livechatContainer.classList.remove('livechat-hideModal');
        break;
    }
  };

  /**
   * Check the URL hash part. Drupal and Angular app have interaction between each other via link hash, so depending on it different dialogue of VA will be shown.
   * @param trigger: string
   */
  Drupal.Chatbot.checkHash = function(trigger) {
    if(window.location.hash === '#chat-met-medewerker' || window.location.hash === '#chat-met-medewerker-skill') {
      Drupal.Chatbot.analytics(trigger);
      Drupal.Chatbot.chatbot_sidebar_actions('open');
    }
  };

  /**
   * Bouncing sidebar logic
   */
  Drupal.Chatbot.bounce = function() {
    var $vaButtonPanel = $('#va-button-panel');

    $vaButtonPanel.addClass('bounce-animation');
    setTimeout(function() {
      $vaButtonPanel.removeClass('bounce-animation');
    }, 1500);
  };

  /**
   * Bounce the sidebar when user reach the bottom of the page. So user will notice the sidebar and know that chatbot can help with his struggle
   */
  Drupal.Chatbot.setBottomOfPageTrigger = function() {
    var scrolledToTheBottom = false;

    $(window).scroll(function() {
      if(scrolledToTheBottom) {
        Drupal.Chatbot.bounce();
        scrolledToTheBottom = false;
      }

      if($(window).scrollTop() + $(window).height() === $(document).height()) {
        scrolledToTheBottom = true;
      }
    });
  };

  /**
   * Bounce the sidebar if no action on a page for a long time. So user will notice the sidebar and know that chatbot can help with his struggle
   * @param millis: number
   * @param onIdle: function
   */
  Drupal.Chatbot.setIdleTimeout = function(millis, onIdle) {
    var timeout = 0;

    function onExpires() {
      timeout = 0;
      onIdle();
    }

    function onActivity() {
      if(timeout) {
        clearTimeout(timeout);
      }
      //since the user is active, we turn off our event hooks for 1 second
      $(document).off('mousemove scroll keypress click', onActivity);
      setTimeout(startTimer, 1000);
    }

    function startTimer() {
      timeout = setTimeout(onExpires, millis);
      $(document).on('mousemove scroll keypress click', onActivity);
    }

    startTimer();
  };

  /**
   * Tealium Analytics logic
   * @param trigger: string
   */
  Drupal.Chatbot.analytics = function(trigger) {
    var obj = Object.assign({}, drupalSettings.tealiumViews);
    // send to  analytics
    switch(trigger) {
      case 'load':
        obj.event_category = 'contact intentie';
        obj.event_action = 'aegon direct link';
        obj.event_label = 'chat';
        if (Drupal.aegon_gtm && typeof Drupal.aegon_gtm.sendData === 'function') {
          Drupal.aegon_gtm.sendData(obj);
        }
        break;
      case 'change':
        // @todo - Check with Smulders
        // this is already handled in page, so obsolete
        break;
    }
  };

  /**
   * Hide the sidebar before going to the next page so user will know that VA is still there in the new page
   */
  Drupal.Chatbot.linkClickTriggerInit = function() {
    var $va = $('.va-dialogue');
    var observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'class' && $(mutation.target).hasClass('link-clicked')) {
          $('#va-sidenav').removeClass('va-sidenav--expanded');
        }
      });
    });
    if($va[0]) {
      observer.observe($va[0], {
        attributes: true
      });
    }
  };


  /**
   * Listeners for the buttons & icons in the blueconic pop for opening VA.
   */
  Drupal.Chatbot.initiateVAPopupListeners = function() {
    /* Dick. Rewritten this function because it did not work in Safari 9 and iOS 9. */
    let chatbotModalContainer = $('.chatbot-popup-container');
    let chatbotButtonYes = $('.chatbot-button-yes');
    let chatbotButtonNo = $('.chatbot-button-no');
    let chatbotIconClose = $('.chatbot-close');

    if (chatbotModalContainer.length > 0 && chatbotButtonYes.length > 0 && chatbotButtonNo.length > 0 && chatbotIconClose.length > 0) {

      let chatbotHideModal = function() {
        chatbotModalContainer[0].className += ' chatbot-hideModal';
      };

      $(chatbotButtonYes[0]).click(function() {
        window && window.Drupal && window.Drupal.Chatbot && window.Drupal.Chatbot.chatbot_sidebar_actions && window.Drupal.Chatbot.chatbot_sidebar_actions('open');
        chatbotHideModal();
      });

      $(chatbotButtonNo[0]).click(function() {
        chatbotHideModal();
      });

      $(chatbotIconClose[0]).click(function() {
        chatbotHideModal();
      });
    }
  };

  /**
   * Listeners for the buttons in the blueconic pop for opening VA with connection to LiveAgent chat.
   */
  Drupal.Chatbot.initiateVAPopupWithChatAgentListeners = function() {
    let livechatButtonYes = $('.livechat-button-yes');
    let livechatButtonNo = $('.livechat-button-no');
    let livechatContainer = $('.livechat-popup-container');

    livechatButtonYes = livechatButtonYes.length > 0 && livechatButtonYes[0];
    livechatButtonNo = livechatButtonNo.length > 0 && livechatButtonNo[0];
    livechatContainer = livechatContainer.length > 0 && livechatContainer[0];

    let hideModalForLiveChat = function() {
      livechatContainer && livechatContainer.classList && livechatContainer.classList.add('livechat-hideModal');
    };

    $(livechatButtonYes).click(function() {
      const product = window && window.Drupal && window.drupalSettings &&
        window.drupalSettings.page_context && window.drupalSettings.page_context.va &&
        window.drupalSettings.page_context.va.product;
      if(window && window.VA) {
        product ? window.VA.startLiveChat({ skill: product}) : window.VA.startLiveChat()
      };
      window && window.Drupal && window.Drupal.Chatbot && window.Drupal.Chatbot.chatbot_sidebar_actions && window.Drupal.Chatbot.chatbot_sidebar_actions('open');
      hideModalForLiveChat();
    });

    $(livechatButtonNo).click(function() {
      hideModalForLiveChat();
    });
  };

  /**
   * Initiator for VALeading (VABanner) to listen to form submit
   */
  Drupal.Chatbot.initiateVALeading = function () {
    const form = $('.va-leading-form').get(0);
    if (!form) {
      return;
    }

    const input = $(form).find('.va-leading-input').get(0);

    $(form).on('submit', function (event) {
      event.preventDefault();

      if (window.VA === undefined || typeof window.VA.sendMessage !== "function") {
        return;
      }

      if (input === undefined) {
        return;
      }

      window.VA.sendMessage(Drupal.checkPlain($(input)).val());

      Drupal.Chatbot.chatbot_sidebar_actions('open');
      $(input).val('');
    });

    /* Event listener for links */
    $('#va-leading-livechat').on('click', function (event) {
      event.preventDefault();

      if (window.VA === undefined || typeof window.VA.sendMessage !== "function") {
        return;
      }

      const product = window && window.Drupal && window.drupalSettings &&
        window.drupalSettings.page_context && window.drupalSettings.page_context.va &&
        window.drupalSettings.page_context.va.product;
      product ? window.VA.startLiveChat({ skill: product }): window.VA.startLiveChat();
      Drupal.Chatbot.chatbot_sidebar_actions('open');
    });
  };

  /**
   * General sidebar initialization and listeners attachment
   */
  Drupal.behaviors.chatbot_sidebar = {
    attach: function(context) {
      sessionStorage.setItem('vaIsOpened', 'false');

      // Because VA is integrated differently in different places and it is not guarantee that at the moment these
      // functions runs all the DOM elements are presented, we do the event delegation.
      $('body', context).on('click', '#va-button-panel, #va-banner-button, .open-direct-chat', function() {
        Drupal.Chatbot.chatbot_sidebar_actions('open');
      });

      $('body', context).on('click', '#va-close-btn, #background-overlay', function() {
        Drupal.Chatbot.chatbot_sidebar_actions('close');
      });

      Drupal.Chatbot.checkHash('load');

      window.addEventListener('hashchange', function() {
        Drupal.Chatbot.checkHash('change');
      });

      Drupal.Chatbot.setBottomOfPageTrigger();
      Drupal.Chatbot.setIdleTimeout(10000, Drupal.Chatbot.bounce);

      Drupal.Chatbot.linkClickTriggerInit();

      Drupal.Chatbot.initiateVAPopupListeners();
      Drupal.Chatbot.initiateVAPopupWithChatAgentListeners();

      $('body').on('drupal-panels-manage-hours-loaded', function() {
        Drupal.Chatbot.initiateVALeading();
      })
    }
  };
}(jQuery, Drupal));
;
/**
 * jQuery plugin paroller.js v1.3.1
 * https://github.com/tgomilar/paroller.js
 * preview: https://tgomilar.github.io/paroller/
 **/
(function (factory) {
  'use strict';

  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = factory(require('jquery'));
  }
  else {
    factory(jQuery);
  }
})(function ($) {
  'use strict';

  var setDirection = {
    bgVertical: function (elem, bgOffset, bgStart) {
      return elem.css({'backgroundPositionY': 'calc(' + -bgOffset + 'px + ' + bgStart + ')'});
    },
    bgHorizontal: function (elem, bgOffset, bgStart) {
      return elem.css({'backgroundPositionX': 'calc(' + -bgOffset + 'px + ' + bgStart + ')'});
    },
    vertical: function (elem, elemOffset, oldTransform) {
      (oldTransform === 'none' ? oldTransform = '' : true);
      return elem.css({
        '-webkit-transform': 'translateY(' + elemOffset + 'px)' + oldTransform,
        '-moz-transform': 'translateY(' + elemOffset + 'px)' + oldTransform,
        'transform': 'translateY(' + elemOffset + 'px)' + oldTransform,
        'transition': 'transform linear',
        'will-change': 'transform'
      });
    },
    horizontal: function (elem, elemOffset, oldTransform) {
      (oldTransform === 'none' ? oldTransform = '' : true);
      return elem.css({
        '-webkit-transform': 'translateX(' + elemOffset + 'px)' + oldTransform,
        '-moz-transform': 'translateX(' + elemOffset + 'px)' + oldTransform,
        'transform': 'translateX(' + elemOffset + 'px)' + oldTransform,
        'transition': 'transform linear',
        'will-change': 'transform'
      });
    }
  };

  $.fn.paroller = function (options) {
    var windowHeight = $(window).height();
    var documentHeight = $(document).height();

    // default options
    options = $.extend({
      factor: 0, // - to +
      type: 'background', // foreground
      direction: 'vertical', // horizontal
      bgstart: 0
    }, options);

    return this.each(function () {
      var working = false;
      var $this = $(this);
      var offset = $this.offset().top;
      var height = $this.outerHeight();
      var dataFactor = $this.data('paroller-factor');
      var dataType = $this.data('paroller-type');
      var dataDirection = $this.data('paroller-direction');
      var dataBgStart = $this.data('paroller-bg-start');
      var factor = (dataFactor) ? dataFactor : options.factor;
      var type = (dataType) ? dataType : options.type;
      var direction = (dataDirection) ? dataDirection : options.direction;
      var bgStart = (dataBgStart) ? dataBgStart : options.bgstart;
      var bgOffset = Math.round(offset * factor);
      var transform = Math.round((offset - (windowHeight / 2) + height) * factor);

      /* Transform directive of element before paroller */
      var oldTransform = $this.css('transform');

      if (type === 'background') {

        if(typeof bgStart === 'number') {
          bgStart = bgStart + 'px';
        }

        if(!bgStart.length) {
          bgStart = '0';
        }
        //if last char is a number, there is no unit specified, add px.
        if($.isNumeric(bgStart.slice(-1)) ) {
          bgStart = bgStart + 'px';
        }

        if (direction === 'vertical') {
          setDirection.bgVertical($this, bgOffset, bgStart);
        }
        else if (direction === 'horizontal') {
          setDirection.bgHorizontal($this, bgOffset, bgStart);
        }
      }
      else if (type === 'foreground') {
        if (direction === 'vertical') {
          setDirection.vertical($this, transform, oldTransform);
        }
        else if (direction === 'horizontal') {
          setDirection.horizontal($this, transform, oldTransform);
        }
      }

      $(window).on('scroll.paroller', onScroll).trigger('scroll');

      function scrollAction() {
        working = false;
      }

      function onScroll() {
        if (!working) {
          var scrolling = $(this).scrollTop();
          documentHeight = $(document).height();

          bgOffset = Math.round((offset - scrolling) * factor);
          transform = Math.round(((offset - (windowHeight / 2) + height) - scrolling) * factor);

          if (type === 'background') {
            if (direction === 'vertical') {
              setDirection.bgVertical($this, bgOffset, bgStart);
            }
            else if (direction === 'horizontal') {
              setDirection.bgHorizontal($this, bgOffset, bgStart);
            }
          }
          else if ((type === 'foreground') && (scrolling <= documentHeight)) {
            if (direction === 'vertical') {
              setDirection.vertical($this, transform, oldTransform);
            }
            else if (direction === 'horizontal') {
              setDirection.horizontal($this, transform, oldTransform);
            }
          }

          window.requestAnimationFrame(scrollAction);
          working = true;
        }
      }
    });
  };
});;
(function($, Drupal, drupalSettings){
  "use strict";

  Drupal.behaviors.DX8ParallaxScrolling = {

    attach: function (context, settings){

      var cmm = new Drupal.CohesionResponsiveBreakpoints();
            
      var resetCSS = {
        'background': '',
        'transform': '',
        'transition': '',
        'will-change': '',
        'background-position-y': '',
        'background-position-x': ''
      };

      var count = 0;
      var total = 0;
                
      function initParoller(settings) {
            
        var key = settings.cohesion.key,
          settings = settings.cohesion.settings,
          $el = settings.$el;
                
        if(!count) {
          total = $('[data-coh-paroller]', context).length;
          count = total;
        }

        if(count === total) {
          //Ensure that unbind only happens the first time we loop round the elements.
          $(window).off('.paroller');
        }

        count--;

        // Always wipe the CSS when changing between breakpoints
        $el.css(resetCSS);
            
        if(settings.breakpoints[key].enabled){
                    
          // Init the paroller elements
          $el.paroller({
            factor: settings.breakpoints[key].factor,
            direction: settings.breakpoints[key].direction,
            type: settings.breakpoints[key].type,
            bgstart: settings.breakpoints[key].bgstart
          });
        }
      }

      $.each($('[data-coh-paroller]', context).once('dx8-js-parallax-init'), function(){
        var $el = $(this);
        var responsiveSettings = $el.data('coh-paroller');
        var key, previous;
        var settings = {
          $el: $el,
          breakpoints: {}
        };

        for (var i = 0; i < cmm.breakpoints.length; i++) {

          key = cmm.breakpoints[i].key;

          // Populate all breakpoints regardless of whether the settings are set or not to simulate inheritance
          settings.breakpoints[key] = {};
          if (typeof responsiveSettings[key] !== 'undefined') {

            settings.breakpoints[key] = responsiveSettings[key];

            previous = responsiveSettings[key];

          } else {

            if (typeof cmm.breakpoints[i - 1] !== 'undefined' && typeof previous !== 'undefined') {
              settings.breakpoints[key] = previous;
            }
          }
        }

        cmm.addListeners(settings, initParoller);
      });
    }
  };

})(jQuery, Drupal, drupalSettings);;
/*!
 * jQuery.scrollTo
 * Copyright (c) 2007 Ariel Flesler - aflesler  gmail  com | https://github.com/flesler
 * Licensed under MIT
 * https://github.com/flesler/jquery.scrollTo
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.2
 */
;(function(factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['jquery'], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    // CommonJS
    module.exports = factory(require('jquery'));
  } else {
    // Global
    factory(jQuery);
  }
})(function($) {
  'use strict';

  var $scrollTo = $.scrollTo = function(target, duration, settings) {
    return $(window).scrollTo(target, duration, settings);
  };

  $scrollTo.defaults = {
    axis:'xy',
    duration: 0,
    limit:true
  };

  function isWin(elem) {
    return !elem.nodeName ||
			$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;
  }

  $.fn.scrollTo = function(target, duration, settings) {
    if (typeof duration === 'object') {
      settings = duration;
      duration = 0;
    }
    if (typeof settings === 'function') {
      settings = { onAfter:settings };
    }
    if (target === 'max') {
      target = 9e9;
    }

    settings = $.extend({}, $scrollTo.defaults, settings);
    // Speed is still recognized for backwards compatibility
    duration = duration || settings.duration;
    // Make sure the settings are given right
    var queue = settings.queue && settings.axis.length > 1;
    if (queue) {
      // Let's keep the overall duration
      duration /= 2;
    }
    settings.offset = both(settings.offset);
    settings.over = both(settings.over);

    return this.each(function() {
      // Null target yields nothing, just like jQuery does
      if (target === null) return;

      var win = isWin(this),
        elem = win ? this.contentWindow || window : this,
        $elem = $(elem),
        targ = target,
        attr = {},
        toff;

      switch (typeof targ) {
        // A number will pass the regex
        case 'number':
        case 'string':
          if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
            targ = both(targ);
            // We are done
            break;
          }
          // Relative/Absolute selector
          targ = win ? $(targ) : $(targ, elem);
          /* falls through */
        case 'object':
          if (targ.length === 0) return;
          // DOMElement / jQuery
          if (targ.is || targ.style) {
            // Get the real position of the target
            toff = (targ = $(targ)).offset();
          }
      }

      var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

      $.each(settings.axis.split(''), function(i, axis) {
        var Pos	= axis === 'x' ? 'Left' : 'Top',
          pos = Pos.toLowerCase(),
          key = 'scroll' + Pos,
          prev = $elem[key](),
          max = $scrollTo.max(elem, axis);

        if (toff) {// jQuery / DOMElement
          attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

          // If it's a dom element, reduce the margin
          if (settings.margin) {
            attr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;
            attr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;
          }

          attr[key] += offset[pos] || 0;

          if (settings.over[pos]) {
            // Scroll to a fraction of its width/height
            attr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];
          }
        } else {
          var val = targ[pos];
          // Handle percentage values
          attr[key] = val.slice && val.slice(-1) === '%' ?
            parseFloat(val) / 100 * max
            : val;
        }

        // Number or 'number'
        if (settings.limit && /^\d+$/.test(attr[key])) {
          // Check the limits
          attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
        }

        // Don't waste time animating, if there's no need.
        if (!i && settings.axis.length > 1) {
          if (prev === attr[key]) {
            // No animation needed
            attr = {};
          } else if (queue) {
            // Intermediate animation
            animate(settings.onAfterFirst);
            // Don't animate this axis again in the next iteration.
            attr = {};
          }
        }
      });

      animate(settings.onAfter);

      function animate(callback) {
        var opts = $.extend({}, settings, {
          // The queue setting conflicts with animate()
          // Force it to always be true
          queue: true,
          duration: duration,
          complete: callback && function() {
            callback.call(elem, targ, settings);
          }
        });
        $elem.animate(attr, opts);
      }
    });
  };

  // Max scrolling position, works on quirks mode
  // It only fails (not too badly) on IE, quirks mode.
  $scrollTo.max = function(elem, axis) {
    var Dim = axis === 'x' ? 'Width' : 'Height',
      scroll = 'scroll'+Dim;

    if (!isWin(elem))
      return elem[scroll] - $(elem)[Dim.toLowerCase()]();

    var size = 'client' + Dim,
      doc = elem.ownerDocument || elem.document,
      html = doc.documentElement,
      body = doc.body;

    return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
  };

  function both(val) {
    return $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };
  }

  // Add special hooks so that window scroll properties can be animated
  $.Tween.propHooks.scrollLeft =
	$.Tween.propHooks.scrollTop = {
	  get: function(t) {
	    return $(t.elem)[t.prop]();
	  },
	  set: function(t) {
	    var curr = this.get(t);
	    // If interrupt is true and user scrolled, stop animating
	    if (t.options.interrupt && t._last && t._last !== curr) {
	      return $(t.elem).stop();
	    }
	    var next = Math.round(t.now);
	    // Don't waste CPU
	    // Browsers don't render floating point scroll
	    if (curr !== next) {
	      $(t.elem)[t.prop](next);
	      t._last = this.get(t);
	    }
	  }
	};

  // AMD requirement
  return $scrollTo;
});;
// https://tc39.github.io/ecma262/#sec-array.prototype.find
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, "find", {
    value: function(predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== "function") {
        throw new TypeError("predicate must be a function");
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    },
    configurable: true,
    writable: true
  });
}

(function($) {
  "use strict";

  Drupal.behaviors.CohesionLink = {
    attach: function(context) {
      // Libs
      var cmm = new Drupal.CohesionResponsiveBreakpoints();

      // Scroll to functionality.
      $.each(
        $(".coh-js-scroll-to", context).once("coh-js-scroll-to-init"),
        bindScrollTo
      );

      // Scroll to top functionality.
      $.each(
        $(".coh-js-scroll-top", context).once("coh-js-scroll-top-init"),
        bindScrollTop
      );

      // Toggle modifier interactivity.
      $.each(
        $(".coh-interaction", context).once("coh-toggle-modifier-init"),
        bindModifier
      );

      // Animation interactivity.
      $.each(
        $(".coh-interaction", context).once("coh-animation-init"),
        bindAnimation
      );

      // Function from David Walsh: http://davidwalsh.name/css-animation-callback
      function whichTransitionEvent() {
        var t,
          el = document.createElement("fakeelement");

        var transitions = {
          transition: "transitionend",
          OTransition: "oTransitionEnd",
          MozTransition: "transitionend",
          WebkitTransition: "webkitTransitionEnd"
        };

        for (t in transitions) {
          if (el.style[t] !== undefined) {
            return transitions[t];
          }
        }
      }

      function getComponentClass($el) {
        if (!$el || !$el.length) {
          return undefined;
        }
        for (var i = 0; i < $el.prop("classList").length; i++) {
          if (
            $el
              .prop("classList")
              [i].match(
                /coh-component-instance-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/
              )
          ) {
            return $el.prop("classList")[i];
          }
        }
      }

      function bindScrollTo() {
        var $this = $(this);

        $this.on("click", function(e) {
          // Don't click through to the page.
          e.preventDefault();

          var defaultSettings = {
            duration: 450,
            offset: 0
          };

          var scrollTarget = $this.data("cohScrollTo");
          var scrollDuration = $this.data("cohScrollDuration");

          /**
           * Offset can either be a jQuery selector (in which cas return elements height) or a number
           * @returns {*}
           */
          var scrollOffset = function() {
            var offset = $this.data("cohScrollOffset");

            if (typeof offset === "string") {
              var $el = $(offset);

              if ($el.length) {
                return 0 - $el.height();
              }

              return 0;
            }

            // plugin expects negative value, when positive value is better UX - reverses logic
            return offset * -1;
          };
          var scrollSettings = {
            duration: scrollDuration,
            offset: scrollOffset()
          };

          var settings = $.extend(defaultSettings, scrollSettings);

          // And smoothly scroll.
          $("html, body").scrollTo(scrollTarget, settings);
        });
      }

      function bindScrollTop() {
        $(this).on("click", function(e) {
          // Don't click through to the page.
          e.preventDefault();

          // And smoothly scroll.
          $("html, body").scrollTo(0, 450);
        });
      }

      function bindModifier() {
        var settings = $(this).data("interactionModifiers");

        // If there are no settings just return
        if (!settings || settings[0].modifierType === "") {
          return;
        }

        $(this).on("click.coh.modifier", function(e) {
          var $this = $(this);
          // Don't click through to the page.
          e.preventDefault();

          var modifier_types = {
            "add-modifier": "addClass",
            "remove-modifier": "removeClass",
            "toggle-modifier": "toggleClass",
            "toggle-modifier-accessible-collapsed": "toggleClass",
            "toggle-modifier-accessible-expanded": "toggleClass"
          };

          for (var i = 0; i < settings.length; i++) {
            if (!settings[i].modifierName) {
              console.warn(
                'Link element is set to toggle a modifier class on a target element but no "Modifier class name" was specified. You must specify a "Modifier class name".'
              );
              return;
            }

            var modifier_name = settings[i].modifierName.replace(/^\./, ""); // Check for and remove leading dot character
            var interaction_target = settings[i].interactionTarget;
            var modifier_type = settings[i].modifierType;
            var transitionEvent = whichTransitionEvent();
            var $interaction_scope;
            var $target;

            // If the scope is something other than 'this' but a target isn't supplied, don't do anything.
            if (
              settings[i].interactionScope !== "this" &&
              !interaction_target
            ) {
              console.warn(
                'Link element is set to "' +
                  modifier_type +
                  '" but does not have a "Target (jQuery selector)" specified. You must specify a "Target (jQuery selector)" or set "Scope to" to "This element"'
              );
              return;
            }

            $interaction_scope = getScope(
              $this,
              settings[i].interactionScope,
              settings[i].interactionParent
            );

            $target = getTarget(
              $this,
              interaction_target,
              $interaction_scope,
              settings[i].interaction_scope
            );

            if ($target.length) {
              $this.data("clickedModifier", !$this.data.clickedModifier);
              // Get jQuery method from modifier types object based on model and apply transition class
              $target[modifier_types[modifier_type]](modifier_name).addClass(
                "coh-transition"
              );

              $target.on(transitionEvent, function() {
                // Remove transition class once transition has finished
                $(this)
                  .removeClass("coh-transition")
                  .off(transitionEvent);
              });

              // If the modifier is an accessible popup
              if (modifier_type.indexOf("toggle-modifier-accessible-") === 0) {
                // Toggle aria-expanded attribute value
                $(this).attr(
                  "aria-expanded",
                  $(this).attr("aria-expanded") === "true" ? "false" : "true"
                );
              }
              // Run Drupal behaviors for anything that is hidden
              Drupal.attachBehaviors($target[0]);
            }
          }
        });
      }

      /**
       * Called when moving between breakpoints. This function compares the breakpoint you have just moved to with the
       * breakpoint you've just come from (stored in previousBreakPointAnimSettings). If you are moving from a breakpoint
       * that has animation to a breakpoint that does not have settings for a matching animationTarget
       * then the css display property is removed. https://cohesion-dev.atlassian.net/browse/COH-4794
       * @param mm
       */
      function cohCheckDisplayResize(mm) {
        var currentSettings =
          mm.cohesion.settings.breakpoints[mm.cohesion.key] || {};
        var animSettings =
          currentSettings.linkAnimation ||
          currentSettings.buttonAnimation ||
          [];
        mm.cohesion.settings.element
          .data("previousBreakPointAnimSettings")
          .forEach(function(prevSetting) {
            // if prevSetting.target doesn't exist in any of the current settings
            var matchedSetting = animSettings.find(function(setting) {
              return prevSetting.animationTarget === setting.animationTarget;
            });

            // In future we can add `displayReset` as a bool/toggle to the JSON form and control this behaviour
            if (!matchedSetting && prevSetting.displayReset !== false) {
              if (mm.cohesion.settings.element.data("clickedAnimation")) {
                // mm.cohesion.settings.element.trigger('click.coh.animation');
                runAnimation(mm.cohesion.settings.element, prevSetting, true);
                if (mm.cohesion.settings.element.data("clickedModifier")) {
                  mm.cohesion.settings.element.trigger("click.coh.modifier");
                }
              } else {
                if (prevSetting.animationTarget) {
                  var $interaction_scope = getScope(
                    mm.cohesion.settings.element,
                    prevSetting.animationScope,
                    prevSetting.animationParent
                  );
                  var $target = getTarget(
                    mm.cohesion.settings.element,
                    prevSetting.animationTarget,
                    $interaction_scope,
                    prevSetting.animationScope
                  );
                  $target.css("display", "");
                }
              }
            }
          });

        mm.cohesion.settings.element.data(
          "previousBreakPointAnimSettings",
          animSettings || []
        );
      }

      function bindAnimation() {
        var $this = $(this),
          data = $this.data("cohSettings"),
          settings = {
            element: $this,
            breakpoints: {}
          },
          key;

        $this.data("previousBreakPointAnimSettings", []);

        for (var i = 0; i < cmm.breakpoints.length; i++) {
          key = cmm.breakpoints[i].key;

          // Populate all breakpoints regardless of whether the settings are set or not to simulate inheritance
          settings.breakpoints[key] = {};
          if (typeof data[key] !== "undefined" && !$.isEmptyObject(data[key])) {
            settings.breakpoints[key] = data[key];

            var previous = data[key];
          } else {
            if (
              typeof cmm.breakpoints[i - 1] !== "undefined" &&
              typeof previous !== "undefined"
            ) {
              settings.breakpoints[key] = previous;
            }
          }
        }

        cmm.addListeners(settings, cohCheckDisplayResize);

        $this.on("click.coh.animation", function(e) {
          e.preventDefault();

          var currentSettings =
            settings.breakpoints[cmm.getCurrentBreakpoint().key];
          currentSettings =
            currentSettings.linkAnimation || currentSettings.buttonAnimation;

          if (currentSettings) {
            for (var i = 0; i < currentSettings.length; i++) {
              var currentSetting = currentSettings[i];

              if (currentSetting.animationType !== "none") {
                runAnimation($this, currentSetting);
              }
            }
          }
        });
      }

      function runAnimation($this, settings, removeDisplay) {
        var $interaction_scope;
        var $target, origin;

        $interaction_scope = getScope(
          $this,
          settings.animationScope,
          settings.animationParent
        );
        $target = getTarget(
          $this,
          settings.animationTarget,
          $interaction_scope,
          settings.animationScope
        );

        if ($target.length) {
          $this.data("clickedAnimation", !$this.data("clickedAnimation"));

          if (settings.animationOrigin) {
            origin = settings.animationOrigin.split(",");
          }

          $.each($($target), function() {
            var $that = $(this);

            $that.toggle({
              effect: settings.animationType,
              direction: settings.animationDirection,
              distance: settings.animationDistance,
              pieces: settings.animationPieces,
              percent: settings.animationScale,
              origin: origin,
              size: settings.animationFoldHeight,
              horizFirst: settings.animationHorizontalFirst,
              times: settings.animationIterations,
              easing: settings.animationEasing,
              duration: removeDisplay ? 0 : settings.animationDuration,
              complete: function() {
                // Run Drupal behaviors for anything that is hidden
                Drupal.attachBehaviors($(this)[0]);
                if (removeDisplay) {
                  $that.css("display", "");
                }
              }
            });
          });
        }
      }

      function getScope($this, scope, parent) {
        var $interaction_scope;
        switch (scope) {
          case "this":
            $interaction_scope = $this;
            break;
          case "parent":
            $interaction_scope = $this.closest(parent);
            break;
          case "component":
            var componentClass = getComponentClass(
              $this.closest(".coh-component")
            );

            if (componentClass) {
              $interaction_scope = $("." + componentClass);
            } else {
              // 'component' scope was chosen but there isn't a parent component. (i.e. element is just sat on a layout canvas).
              $interaction_scope = $(document);
            }
            break;
          default:
            $interaction_scope = $(document);
            break;
        }
        return $interaction_scope;
      }

      function getTarget(
        $this,
        interaction_target,
        $interaction_scope,
        interaction_scope
      ) {
        var $target = $();
        if (interaction_scope === "this" && !interaction_target) {
          $target = $this;
        } else if (!interaction_target) {
          console.warn(
            'Element does not have a "Target (jQuery selector)" specified. You must specify a "Target (jQuery selector)" or set "Scope to" to "This element".'
          );
          return $target;
        }

        if (!$target.length) {
          // Process the interaction target as a jQuery selector
          $target = $(interaction_target, $interaction_scope);
        }

        // Is it one of the top level elements in a component
        if (!$target.length) {
          $target = $interaction_scope.filter(interaction_target);
        }

        // Is it a child of the scope?
        if (!$target.length) {
          $target = $interaction_scope.find($(interaction_target));
        }

        // Try the interaction target as a className (legacy - we used to except a class, unprefixed with . instead of a jquery selector.
        if (interaction_target.indexOf(".") !== 0) {
          if (!$target.length) {
            $target = $interaction_scope.filter("." + interaction_target);
          }

          if (!$target.length) {
            $target = $interaction_scope.find($("." + interaction_target));
          }
        }

        if (!$target.length) {
          console.warn(
            'Element has "Target (jQuery selector)" set to "' +
              interaction_target +
              '", but no matching element was found on the page.'
          );
        }

        return $target;
      }
    }
  };
})(jQuery);
;
(function ($, Drupal) {

  Drupal.behaviors.CohesionScroll = {

    attach: function (context) {

      if(drupalSettings.cohesion.add_animation_classes === 'ENABLED') {

        function getWindowOffset() {
          return window.pageYOffset || document.documentElement.scrollTop;
        }

        var previous = getWindowOffset();

        $('body', context).once('cohWindowScroll').each(function() {

          var $body = $(this);
          var timeout, flag = false;

          // Add the class onload if there is an offset
          if(getWindowOffset() > 0) {
            $body.addClass('is-scrolled');
          }

          // Bind the listener
          //window.onscroll = function() {
          $(window).scroll(function() {
            var current = getWindowOffset();

            // Determine if the user is scrolling up or down
            var state = current > previous;

            // These classes should only be applied when the event is taking place
            if(!flag) {
              flag = true;
              $body.addClass('is-scrolling');
            }

            // These class should persist even once scrolling has ceased
            if(current !== previous)    {
              $body.addClass('is-scrolled').toggleClass('is-scrolled-down', state).toggleClass('is-scrolled-up', !state);
            }

            // Store the previous position (handles mobile or negative scrolling)
            previous = current <= 0 ? 0 : current;

            // Remove is-scrolling on scroll stop (no event for scrollStop)
            clearTimeout(timeout);
            timeout = setTimeout(function() {
              $body.removeClass('is-scrolling');
              flag = false;
            }, 200);

            // Remove 'is-scrolled' class if there is no offset
            if(previous === 0) {
              $body.removeClass('is-scrolled');
            }
          });
        });
      }
    }
  };
})(jQuery, Drupal, drupalSettings);
;
/**!
* jquery-match-height 0.7.2 by @liabru
* http://brm.io/jquery-match-height/
* License: MIT
*/

;(function(factory) { // eslint-disable-line no-extra-semi
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['jquery'], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    // CommonJS
    module.exports = factory(require('jquery'));
  } else {
    // Global
    factory(jQuery);
  }
})(function($) {
  /*
    *  internal
    */

  var _previousResizeWidth = -1,
    _updateTimeout = -1;

  /*
    *  _parse
    *  value parse utility function
    */

  var _parse = function(value) {
    // parse value and convert NaN to 0
    return parseFloat(value) || 0;
  };

  /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

  var _rows = function(elements) {
    var tolerance = 1,
      $elements = $(elements),
      lastTop = null,
      rows = [];

    // group elements by their top position
    $elements.each(function(){
      var $that = $(this),
        top = $that.offset().top - _parse($that.css('margin-top')),
        lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

      if (lastRow === null) {
        // first item on the row, so just push it
        rows.push($that);
      } else {
        // if the row top is the same, add to the row group
        if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
          rows[rows.length - 1] = lastRow.add($that);
        } else {
          // otherwise start a new row group
          rows.push($that);
        }
      }

      // keep track of the last row top
      lastTop = top;
    });

    return rows;
  };

  /*
    *  _parseOptions
    *  handle plugin options
    */

  var _parseOptions = function(options) {
    var opts = {
      byRow: true,
      property: 'height',
      target: null,
      remove: false
    };

    if (typeof options === 'object') {
      return $.extend(opts, options);
    }

    if (typeof options === 'boolean') {
      opts.byRow = options;
    } else if (options === 'remove') {
      opts.remove = true;
    }

    return opts;
  };

  /*
    *  matchHeight
    *  plugin definition
    */

  var matchHeight = $.fn.matchHeight = function(options) {
    var opts = _parseOptions(options);

    // handle remove
    if (opts.remove) {
      var that = this;

      // remove fixed height from all selected elements
      this.css(opts.property, '');

      // remove selected elements from all groups
      $.each(matchHeight._groups, function(key, group) {
        group.elements = group.elements.not(that);
      });

      matchHeight._groups = matchHeight._groups.filter(function(group) {
        return group.elements.length > 0;
      })

      return this;
    }

    if (this.length <= 1 && !opts.target) {
      return this;
    }

    // keep track of this group so we can re-apply later on load and resize events
    matchHeight._groups.push({
      elements: this,
      options: opts
    });

    // match each element's height to the tallest element in the selection
    matchHeight._apply(this, opts);

    return this;
  };

  /*
    *  plugin global options
    */

  matchHeight.version = '0.7.2';
  matchHeight._groups = [];
  matchHeight._throttle = 80;
  matchHeight._maintainScroll = false;
  matchHeight._beforeUpdate = null;
  matchHeight._afterUpdate = null;
  matchHeight._rows = _rows;
  matchHeight._parse = _parse;
  matchHeight._parseOptions = _parseOptions;
  matchHeight.$window = $(window);
  matchHeight.$html = $('html');

  /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

  matchHeight._apply = function(elements, options) {
    var opts = _parseOptions(options),
      $elements = $(elements),
      rows = [$elements];

    // take note of scroll position
    var scrollTop = matchHeight.$window.scrollTop();
    var htmlHeight = matchHeight.$html.outerHeight(true);

    // get hidden parents
    var $hiddenParents = $elements.parents().filter(':hidden');

    // cache the original inline style
    $hiddenParents.each(function() {
      var $that = $(this);
      $that.data('style-cache', $that.attr('style'));
    });

    // temporarily must force hidden parents visible
    $hiddenParents.css('display', 'block');

    // get rows if using byRow, otherwise assume one row
    if (opts.byRow && !opts.target) {

      // must first force an arbitrary equal height so floating elements break evenly
      $elements.each(function() {
        var $that = $(this),
          display = $that.css('display');

        // temporarily force a usable display value
        if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
          display = 'block';
        }

        // cache the original inline style
        $that.data('style-cache', $that.attr('style'));

        $that.css({
          'display': display,
          'padding-top': '0',
          'padding-bottom': '0',
          'margin-top': '0',
          'margin-bottom': '0',
          'border-top-width': '0',
          'border-bottom-width': '0',
          'height': '100px',
          'overflow': 'hidden'
        });
      });

      // get the array of rows (based on element top position)
      rows = _rows($elements);

      // revert original inline styles
      $elements.each(function() {
        var $that = $(this);
        $that.attr('style', $that.data('style-cache') || '');
      });
    }

    $.each(rows, function(key, row) {
      var $row = $(row),
        targetHeight = 0;

      if (!opts.target) {
        // skip apply to rows with only one item
        if (opts.byRow && $row.length <= 1) {
          $row.css(opts.property, '');
          return;
        }

        // iterate the row and find the max height
        $row.each(function(){
          var $that = $(this),
            style = $that.attr('style'),
            display = $that.css('display');

          // temporarily force a usable display value
          if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
            display = 'block';
          }

          // ensure we get the correct actual height (and not a previously set height value)
          var css = { 'display': display };
          css[opts.property] = '';
          $that.css(css);

          // find the max height (including padding, but not margin)
          if ($that.outerHeight(false) > targetHeight) {
            targetHeight = $that.outerHeight(false);
          }

          // revert styles
          if (style) {
            $that.attr('style', style);
          } else {
            $that.css('display', '');
          }
        });
      } else {
        // if target set, use the height of the target element
        targetHeight = opts.target.outerHeight(false);
      }

      // iterate the row and apply the height to all elements
      $row.each(function(){
        var $that = $(this),
          verticalPadding = 0;

        // don't apply to a target
        if (opts.target && $that.is(opts.target)) {
          return;
        }

        // handle padding and border correctly (required when not using border-box)
        if ($that.css('box-sizing') !== 'border-box') {
          verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
          verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
        }

        // set the height (accounting for padding and border)
        $that.css(opts.property, (targetHeight - verticalPadding) + 'px');
      });
    });

    // revert hidden parents
    $hiddenParents.each(function() {
      var $that = $(this);
      $that.attr('style', $that.data('style-cache') || null);
    });

    // restore scroll position if enabled
    if (matchHeight._maintainScroll) {
      matchHeight.$window.scrollTop((scrollTop / htmlHeight) * matchHeight.$html.outerHeight(true));
    }

    return this;
  };

  /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

  matchHeight._applyDataApi = function() {
    var groups = {};

    // generate groups by their groupId set by elements using data-match-height
    $('[data-match-height], [data-mh]').each(function() {
      var $this = $(this),
        groupId = $this.attr('data-mh') || $this.attr('data-match-height');

      if (groupId in groups) {
        groups[groupId] = groups[groupId].add($this);
      } else {
        groups[groupId] = $this;
      }
    });

    // apply matchHeight to each group
    $.each(groups, function() {
      this.matchHeight(true);
    });
  };

  /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

  var _update = function(event) {
    if (matchHeight._beforeUpdate) {
      matchHeight._beforeUpdate(event, matchHeight._groups);
    }

    $.each(matchHeight._groups, function() {
      matchHeight._apply(this.elements, this.options);
    });

    if (matchHeight._afterUpdate) {
      matchHeight._afterUpdate(event, matchHeight._groups);
    }
  };

  matchHeight._update = function(event) {
      if (matchHeight.updateCall) {
          window.cancelAnimationFrame(matchHeight.updateCall);
      }
      matchHeight.updateCall = window.requestAnimationFrame(function () {
          _update(event);
      });
  };

  /*
    *  bind events
    */

  // apply on DOM ready event
  $(matchHeight._applyDataApi);

  // use on or bind where supported
  var on = $.fn.on ? 'on' : 'bind';

  // update heights on load and resize events
  matchHeight.$window[on]('load orientationchange', function(event) {
    matchHeight._update(event);
  });

  // throttled update heights on resize events
  matchHeight.$window[on]('resize', function(event) {
    matchHeight._update(event);
  });

});
;
(function ($, Drupal, drupalSettings) {

  "use strict";

  Drupal.CohesionResponsiveBreakpoints = function (settings) {

    this.constants = {
      'desktop': 'desktop-first',
      'mobile': 'mobile-first',
      'widthType': {
        'fluid': 'fluid',
        'fixed': 'fixed'
      },
      'mediaQuery': {
        'all': 'all',
        'max': 'max-width',
        'min': 'min-width'
      }
    };

    // Custom responsive grid settings
    this.settings = settings || drupalSettings.cohesion.responsive_grid_settings;

    // Array of breakpoints in the correct order
    this.breakpoints = [];
        
    // Keyed list of listeners
    this.listeners = {};

    /**
         * Init when first loaded to do some setup
         */
    this.init = function () {

      this.sortBreakpoints();
    };

    /**
         * Returns the current media query depending on the breakpoint "key" passed
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         */
    this.getBreakpointMediaQuery = function (breakpoint) {

      if (this.getGridType() === this.constants.mobile) {

        if (breakpoint === this.getFirstBreakpoint()) {

          return this.constants.mediaQuery.all;

        } else {

          if (typeof this.getBreakpoints()[breakpoint] !== 'undefined') {

            return '(min-width: ' + this.getBreakpointWidth(breakpoint) + 'px)';

          } else {

            // Custom breakpoint
            return '(min-width: ' + breakpoint + 'px)';
          }
        }
      }

      if (this.getGridType() === this.constants.desktop) {

        var breakpointIndex = this.getBreakpointIndex(breakpoint);

        var minWidth = 0;
        var breakpointMaxWidth = false;

        if (breakpoint !== this.getLastBreakpoint()) {
          minWidth = this.getBreakpointWidth(this.breakpoints[breakpointIndex].key);
        }

        if (breakpoint !== this.getFirstBreakpoint()) {
          breakpointMaxWidth = this.getBreakpointWidth(this.breakpoints[breakpointIndex - 1].key) - 1;
        }

        var mediaQuery = '(min-width: ' + minWidth + 'px)';
        if (breakpointMaxWidth) {
          mediaQuery = mediaQuery + ' and (max-width: ' + breakpointMaxWidth + 'px)';
        }

        return mediaQuery;
      }
    };

    /**
         * Returns the key for the first breakpoint (xs||ps) etc
         * @returns {string}
         */
    this.getFirstBreakpoint = function () {
      return this.breakpoints[0].key;
    };

    /**
         * Returns the key for the last breakpoint (xs||ps) etc
         * @returns {string}
         */
    this.getLastBreakpoint = function () {
      return this.breakpoints[this.breakpoints.length - 1].key;
    };

    /**
         * Get the current grid type mobile / desktop first
         * @return {string} dekstop-fist || mobile-first
         */
    this.getGridType = function () {
      return this.settings.gridType;
    };
        
    /**
         * Simple helper function to determine if we are mobile first
         * @returns {Boolean}
         */
    this.isMobileFirst = function() {
      return this.settings.gridType === this.constants.mobile;
    };
        
    /**
         * Simple helper function to determine if we are desktop first
         * @returns {Boolean}
         */
    this.isDesktopFirst = function()    {
      return this.settings.gridType === this.constants.desktop;
    }

    /**
         * Gets the responsive width type - fluid || fixed
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         * @returns {string} fixed || fluid
         */
    this.getBreakpointType = function (breakpoint) {
      return this.settings.breakpoints[breakpoint].widthType;
    };

    /**
         * Returns the current breakpoint width depending on the breakpoint "key" passed
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         * @returns {int} breakpoint width
         */
    this.getBreakpointWidth = function (breakpoint) {
      return this.settings.breakpoints[breakpoint].width;
    };

    /**
         * Returns the min-width breakpoint
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         * @returns {int}
         */
    this.getBreakpointMediaWidth = function (breakpoint) {

      if (this.getGridType() === this.constants.mobile) {

        if (breakpoint === this.getFirstBreakpoint()) {

          return 0;

        } else {

          if (typeof this.getBreakpoints()[breakpoint] !== 'undefined') {

            return this.getBreakpointWidth(breakpoint);

          } else {

            // Custom breakpoint
            return breakpoint;
          }
        }
      }

      if (this.getGridType() === this.constants.desktop) {

        var breakpointIndex = this.getBreakpointIndex(breakpoint);

        var minWidth = 0;
        var breakpointMaxWidth = false;

        if (typeof this.breakpoints[breakpointIndex - 1] !== 'undefined') {
          minWidth = this.getBreakpointWidth(this.breakpoints[breakpointIndex].key);
        }

        if (breakpoint !== this.getFirstBreakpoint()) {
          breakpointMaxWidth = this.getBreakpointWidth(this.breakpoints[breakpointIndex - 1].key) - 1;
        }

        var mediaQuery = '(min-width: ' + minWidth + 'px)';
        if (breakpointMaxWidth) {
          mediaQuery = mediaQuery + ' and (max-width: ' + breakpointMaxWidth + 'px)';
        }

        return breakpointMaxWidth;
      }

    };

    /**
         * Returns the current breakpoint outerGutter depending on the breakpoint "key" passed
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         * @returns {int} outerGutter width
         */
    this.getBreakpointOuterGutter = function (breakpoint) {
      return this.settings.breakpoints[breakpoint].outerGutter;
    };

    /**
         * Returns the current breakpoint index depending on the breakpoint "key" passed
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         * @returns {int} position of the breakpoint
         */
    this.getBreakpointIndex = function (breakpoint) {
      for (var i = 0; i < this.breakpoints.length; i++) {
        if (this.breakpoints[i].key === breakpoint) {
          return i;
        }
      }
    };

    /**
         * Returns a list of the breakpoint settings
         * @returns {object}
         */
    this.getBreakpoints = function () {
      return this.settings.breakpoints;
    };

    /**
         * Returns the settings for a specific breakpoint depending on the breakpoint "key" passed
         * @param {string} breakpoint xs|ps|sm|md|lg|xl
         */
    this.getBreakpointSettings = function (breakpoint) {
      return this.settings.breakpoints[breakpoint];
    };

    /**
         * Returns the settings for the current matched breakpoint
         * @returns {object}
         */
    this.getCurrentBreakpoint = function () {

      var match = false;

      for (var i = 0; i < this.breakpoints.length; i++) {
        // Set the first item to match as this is the default
        if (i === 0) {
          match = this.breakpoints[i];
        }

        // Check for matches
        var m = window.matchMedia(this.getBreakpointMediaQuery(this.breakpoints[i].key));
        if (m.matches) {
          match = this.breakpoints[i];
        }
      }
      return match;
    };

    /**
         * Patch to help out Safari understand where the object actually is
         * @param {Object} - The returned `MediaQueryListEvent` from the `window`
         * @returns {Object} - `MediaQueryListEvent`
         */
    this.getMediaQueryListEventObject = function (mql) {
      return typeof mql.target !== 'undefined' ? mql.target : mql;
    };

    /**
         * Shorthand method for this.getMediaQueryListEventObject()
         * @param {Object} - The returned `MediaQueryListEvent` from the `window`
         * @returns {Object} - `MediaQueryListEvent`
         */
    this.getMql = function (mql) {
      return this.getMediaQueryListEventObject(mql);
    };

    /**
         * @param {function} cb - the callback function to be executed at each breakpoint
         * @returns {object}
         */
    this.addListener = function (breakpoint, cb) {

    };

    /**
         * Run the callback with the correct settings
         * @param {type} mql
         * @param {type} key
         * @param {type} callback
         * @param {type} settings
         * @returns {undefined}
         */
    this.handleListener = function(mql, key, callback, callbackSettings)   {
            
      var _this = this;
            
      if (!mql.matches && this.isDesktopFirst())    {
        return;
      }
            
      // If there is no match in mobile first manually grab the current breakpoint settings as the user is most likely scaling down
      if(!mql.matches && this.isMobileFirst())  {
        key = _this.getCurrentBreakpoint().key;
        mql = _this.listeners[key];
      }
            
      mql = _this.getMql(mql);
            
      mql.cohesion = {
        'key': key,
        'settings': callbackSettings
      };
            
      return callback(mql);
    };

    /**
         * Binding of the native window.addListener
         * @param {type} cb - the callback function to be executed at each breakpoint
         * @returns {undefined}
         */
    this.addListeners = function (settings, callback) {
      var _this = this;
      var i, breakpointKey, mq, match;

      for (i = 0; i < _this.breakpoints.length; i++) {

        breakpointKey = _this.breakpoints[i].key;
        mq = _this.getBreakpointMediaQuery(breakpointKey);

        var listener;
        listener = window.matchMedia(mq);
                    
        // Keep a record of the listeners
        _this.listeners[breakpointKey] = listener;

        listener.addListener(this.handleListener.bind(this, listener, breakpointKey, callback, settings));

        // Store a current match
        if(listener.matches)    {
          match = listener;
          match.key = breakpointKey;
        }
      }
            
      // Run the callback for the first time
      if(match)   {
        this.handleListener(match, match.key, callback, settings);
      }
    };

    /**
         * Sorts the responsive breakpoints into the correct order
         * @returns {array}
         */
    this.sortBreakpoints = function () {

      var _this = this;

      var i = 0;
      // Pass breakpoints into an array ready to be sorted
      for (var k in _this.settings.breakpoints) {
        if (_this.settings.breakpoints.hasOwnProperty(k)) {
          _this.breakpoints.push(_this.settings.breakpoints[k]);
          _this.breakpoints[i].key = k;
          i++;
        }
      }
      // Sort the array depending on mobile || desktop first
      if (_this.getGridType() === _this.constants.mobile) {

        _this.breakpoints.sort(function (a, b) {
          return a.width - b.width;
        });

      } else if (_this.getGridType() === _this.constants.desktop) {

        _this.breakpoints.sort(function (a, b) {
          return b.width - a.width;
        });

      } else {

        throw 'Mobile or Desktop first must be set in Website settings > Responsive grid settings';
      }
    };

    // Init the
    this.init();
  };

})(jQuery, Drupal, drupalSettings);
;
(function ($, Drupal) {

  "use strict";

  Drupal.behaviors.CohesionMatchHeights = {

    attach: function (context) {

      var cmm = new Drupal.CohesionResponsiveBreakpoints();

      var once = '';

      // List of possible elements that could be loaded into the DOM onload
      var loaders = [
        'img',
        'frame',
        'iframe',
        'input[type="image"]',
        'link',
        'script',
        'style'
      ];

      /**
             * Applies match height to the given and current DOM objects
             * @param {object} settings - the settings
             * @returns {object} the match height object
             */
      function cohInitMatchHeights(settings) {

        var s = settings.cohesion.settings;
        var $this = s.element;
        var target = s.breakpoints[settings.cohesion.key].target.match(/^[.]/) ? s.breakpoints[settings.cohesion.key].target : '.' + s.breakpoints[settings.cohesion.key].target;
        var $el;

        // Should we target the children
        if(typeof s.breakpoints[settings.cohesion.key].children !== 'undefined' && s.breakpoints[settings.cohesion.key].children === true)  {
          $el = $(target, $this);
        } else {
          $el =  s.element.add(target);
        }

        // Save the current matches so we can destroy it later
        if (typeof $this.data('currentMatchHeight') !== 'undefined') {

          // If $el is the same there is not point in matching again
          if ($this.data('currentMatchHeight') === $el) {
            return;
          }

          cohUnsetMatchHeight($this.data('currentMatchHeight'));

          // If none is set then just return as well
          if (s.breakpoints[settings.cohesion.key].target === 'none') {
            return;
          }
        }

        $this.data('currentMatchHeight', $el);

        return $el.matchHeight({
          byRow: false
        });
      }

      /**
             * Unset match heights to just the current active DOM objects
             * @param {type} $this
             * @returns {undefined}
             */
      function cohUnsetMatchHeight($this) {
        return $this.matchHeight({
          remove: true
        });
      }

      // Trigger match heights to update - this will be called when behaviors are reattached
      $.fn.matchHeight._update();

      $.each($('[data-coh-match-heights]', context).once('coh-js-matchheights-init'), function () {

        var $this = $(this),
          targets = $this.data('cohMatchHeights'),
          key;

        var settings = {};
        settings.element = $this;
        settings.breakpoints = {};

        // Update the settings prior to attaching the listeners
        for (var i = 0; i < cmm.breakpoints.length; i++) {

          key = cmm.breakpoints[i].key;

          // Populate all breakpoints regardless of whether the settings are set or not to simulate inheritance
          settings.breakpoints[key] = {};
          if (typeof targets[key] !== 'undefined') {

            settings.breakpoints[key] = targets[key];

            var previous = targets[key];

          } else {

            if (typeof cmm.breakpoints[i - 1] !== 'undefined' && typeof previous !== 'undefined') {
              settings.breakpoints[key] = previous;
            }
          }
        }

        // Bind the listeners to our callback
        cmm.addListeners(settings, cohInitMatchHeights);

        // Once the ajax has finished loading AND anything else that could effect the layout (onload)
        $(context).ajaxComplete(function (event, xhr, settings) {

          $.fn.matchHeight._update();

          $(loaders.toString(), context).on('load', function () {
            // if the triggering element was a react/styled-component, don't refresh match heights.
            if ($(this).length && this.dataset.styled !== "active") {
              $.fn.matchHeight._update();
            }
          });
        });
      });
    }
  };

})(jQuery, Drupal);
;
(function ($, Drupal) {

  if (typeof AEGON === 'undefined') {
    AEGON = {};
  }

  AEGON.search = {
    searchBarSelector: '.nav-search.aegon-search-bar',
    searchInput: '#aegon-search-input',
    searchComponentInput : '#aegon-search-component-input',
    searchViewInput: '.aegon-search-bar #edit-keywords',
    liveSearchResultsWrapper: '.aegon-search-results--results',
    inputDelay: 500,
    keywords: '',
    active: false,
    search: function () {
      let pageCategoryParamVal = drupalSettings.aegon.pageCategory ? 'page_category:' + drupalSettings.aegon.pageCategory : null;
      let pageCategoryParam = pageCategoryParamVal ? '&f[0]=' + pageCategoryParamVal : '';
      let keywordsParam = 'keywords=' + AEGON.search.keywords;
      if (pageCategoryParamVal) {
        $('#aegon-search-category[name="f[0]"]').val(pageCategoryParamVal);
      }
      else {
        $('#aegon-search-category[name="f[0]"]').remove();
      }
      $('#aegon-search-input[name="keywords"]').val(AEGON.search.keywords);

      if (AEGON.search.keywords.length < 3) {
        return;
      }

      let settings = {
        url: Drupal.url('live-search?' + keywordsParam + pageCategoryParam),
      };

      Drupal.ajax(settings).execute();
    },
    activateSearch: function () {
      AEGON.search.active = !AEGON.search.active;
      $(AEGON.search.searchBarSelector).toggleClass('d-none');
      $(AEGON.search.searchInput).val('');
      $(AEGON.search.searchInput).focus();
      $(AEGON.search.liveSearchResultsWrapper).empty();
      $('#backdrop').addClass('cms__backdrop--open-by-mainnav');
      $('#mainnav').removeClass('cms-mainnav__menu--open');
      $('.cms-mainnav__menu-item').removeClass('active-item');

      if ($('#aegon-search-bar').hasClass('active')) {
        $('#backdrop').removeClass('cms__backdrop--open-by-mainnav');
        $(AEGON.search.searchBarSelector).removeClass('active');
      }
      else {
        $(AEGON.search.searchBarSelector).addClass('active');
      }

    },
    clearSearch: function () {
      $(AEGON.search.searchInput).val('');
      $(AEGON.search.searchComponentInput).val('');
      $(AEGON.search.searchViewInput).val('');

    }
  }

  Drupal.behaviors.aegonSearch = {
    attach: function (context, settings) {
      let searchBarIcon = $(context).find('.aegon-search__search-icon');
      if (searchBarIcon.length > 0){
        searchBarIcon.on('click', function () {
          AEGON.search.activateSearch();
        });
      }
      let searchCloseIcon =  $(context).find('.aegon-search-bar .icon--close');
      if (searchCloseIcon.length > 0){
        searchCloseIcon.on('click', function () {
          AEGON.search.clearSearch();
        });
      }

      let searchInput = $(context).find('.aegon-search-bar #aegon-search-input');
      if (searchInput.length > 0) {
        searchInput.on('input', function (event) {
          event.preventDefault();
          AEGON.search.keywords = this.value;

          setTimeout(AEGON.search.search, AEGON.search.inputDelay);
        })
      }

      let searchPageInput = $(context).find('.path-search-results #aegon-search-input');
      if (searchPageInput.length > 0) {
        searchPageInput.on('input', function (event) {
          event.preventDefault();
          AEGON.search.keywords = this.value;

          setTimeout(AEGON.search.search, AEGON.search.inputDelay);
        })
      }
    }
  }

  Drupal.AjaxCommands.prototype.liveSearchResults = function (ajax, response, status) {
    let wrapper = $(AEGON.search.liveSearchResultsWrapper);
    let settings = response.settings || ajax.settings || drupalSettings;
    let newContent = $($.parseHTML(response.content, document, true));

    wrapper.html(newContent);
  }

}(jQuery, Drupal));
;
